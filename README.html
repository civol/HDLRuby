<h1 id="about-hdlruby">About HDLRuby</h1>
<p>HDLRuby is a library for describing and simulating digital electronic systems.</p>
<p><strong>Note</strong>:</p>
<p>If you are new to HDLRuby, it is recommended that you consult first the following tutorial (even if you are a hardware person):</p>
<ul>
<li><p><a href="tuto/tutorial_sw.md">HDLRuby tutorial for software people</a> [md]</p></li>
<li><p><a href="tuto/tutorial_sw.html">HDLRuby tutorial for software people</a> [html]</p></li>
</ul>
<p><strong>What’s new</strong></p>
<p>For HDLRuby version 3.3.0:</p>
<ul>
<li><p>Remade the description of software components using the program construct. Now the Code objects are deprecated.</p></li>
<li><p>Added HW-SW co-simulation capability for Ruby and compiled C-compatible software programs.</p></li>
<li><p>Added a browser-based graphical interface simulating simulates a development board that interacts with the HDLRuby simulator.</p></li>
<li><p>Updated the documentation and tutorial accordingly and fixed several typos.</p></li>
</ul>
<p>For HDLRuby version 3.2.0:</p>
<ul>
<li><p>Added component for declaring BRAM and BRAM-based stacks. The goal is to allocate memories inside FPGAs efficiently.</p></li>
<li><p>Inner code overhaul for preparing version 4.0.0</p></li>
<li><p>Multiple bug fixes</p></li>
</ul>
<p>For HDLRuby version 3.1.0:</p>
<ul>
<li><p><a href="#sequencer-specific-function-std-sequencer_func-rb">Functions for sequencers</a> supporting recursion;</p></li>
<li><p>The <code>function</code> keyword was replaced with <code>hdef</code> for better consistency with the new functions for sequencers;</p></li>
<li><p>The <code>steps</code> command was added for waiting several steps in a sequencer;</p></li>
<li><p>Verilog HDL code generation was improved to preserve as much as possible the original names of the signals;</p></li>
<li><p>Several bug fixes for the sequencers.</p></li>
</ul>
<p>For HDLRuby version 3.0.0:</p>
<ul>
<li><p>This section;</p></li>
<li><p><a href="#sequencer-software-like-hardware-coding-stdsequencerrb">The sequencers</a> for software-like hardware design;</p></li>
<li><p>A <a href="tuto/tutorial_sw.md">tutorial</a> for software people;</p></li>
<li><p>The stable <a href="#standard-libraries">standard libraries</a> are loaded by default.</p></li>
</ul>
<p><strong>Install</strong>:</p>
<p>The recommended installation method is from rubygems as follows:</p>
<pre><code>gem install HDLRuby</code></pre>
<p>Developers willing to contribute to HDLRuby can install the sources from GitHub as follows:</p>
<pre><code>git clone HDLRuby</code></pre>
<p><strong>Warning</strong>:</p>
<ul>
<li>This is still preliminary work which may change before we release a stable version.</li>
<li>It is highly recommended to have both basic knowledge of the Ruby language and hardware description languages before using HDLRuby.</li>
</ul>
<h1 id="compiling-hdlruby-descriptions">Compiling HDLRuby descriptions</h1>
<h2 id="using-the-hdlruby-compiler">Using the HDLRuby compiler</h2>
<p>‘hdrcc’ is the HDLRuby compiler. It takes as input an HDLRuby file, checks it, and can produce as output a Verilog HDL, VHDL, or a YAML low-level description of HW components but it can also simulate the input description.</p>
<p><strong>Usage</strong>:</p>
<pre><code>hdrcc [options] &lt;input file&gt; &lt;output directory&gt;</code></pre>
<p>Where:</p>
<ul>
<li><code>options</code> is a list of options</li>
<li><code>&lt;input file&gt;</code> is the initial file to compile (mandatory)</li>
<li><code>&lt;output directory&gt;</code> is the directory where the generated files will be put</li>
</ul>
<table>
<colgroup>
<col style="width: 26%" />
<col style="width: 73%" />
</colgroup>
<thead>
<tr class="header">
<th style="text-align: left;">Options</th>
<th style="text-align: left;"></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><code>-I, --interactive</code></td>
<td style="text-align: left;">Run in interactive mode</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>-y, --yaml</code></td>
<td style="text-align: left;">Output in YAML format</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>-v, --verilog</code></td>
<td style="text-align: left;">Output in Verilog HDL format</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>-V, --vhdl</code></td>
<td style="text-align: left;">Output in VHDL format</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>-s, --syntax</code></td>
<td style="text-align: left;">Output the Ruby syntax tree</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>-C, --clang</code></td>
<td style="text-align: left;">Output the C code of the standalone simulator</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>-S, --sim</code></td>
<td style="text-align: left;">Perform the simulation with the default engine</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>--csim</code></td>
<td style="text-align: left;">Perform the simulation with the standalone engine</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>--rsim</code></td>
<td style="text-align: left;">Perform the simulation with the Ruby engine</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>--rcsim</code></td>
<td style="text-align: left;">Perform the simulation with the Hybrid engine</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>--vcd</code></td>
<td style="text-align: left;">Make the simulator generate a VCD file</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>-d, --directory</code></td>
<td style="text-align: left;">Specify the base directory for loading the HDLRuby files</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>-D, --debug</code></td>
<td style="text-align: left;">Set the HDLRuby debug mode</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>-t, --top system</code></td>
<td style="text-align: left;">Specify the top system describing the circuit to compile</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>-p, --param x,y,z</code></td>
<td style="text-align: left;">Specify the generic parameters</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>--get-samples</code></td>
<td style="text-align: left;">Copy the sample directory (hdr_samples) to current one, then exit</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>--version</code></td>
<td style="text-align: left;">Show the version number, then exit</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>-h, --help</code></td>
<td style="text-align: left;">Show the help message</td>
</tr>
</tbody>
</table>
<p><strong>Notes</strong>:</p>
<ul>
<li><p>If no top system is given, it is automatically looked for from the input file.</p></li>
<li><p>If no option is given, it simply checks the input file.</p></li>
<li><p>If you are new to HDLRuby, or if you want to see how new features work, we strongly encourage you to get a local copy of the test HDLRuby sample using:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode bash"><code class="sourceCode bash"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="ex">hdrcc</span> <span class="at">--get-samples</span></span></code></pre></div>
<p>Then in your current directory (folder) the <code>hdr_samples</code> subdirectory will appear that contains several HDLRuby example files. Details about the samples can be found here: <a href="#sample-hdlruby-descriptions">samples</a>.</p></li>
</ul>
<p><strong>Examples</strong>:</p>
<ul>
<li>Compile system named <code>adder</code> from <code>adder.rb</code> input file and generate a low-level YAML description into directory <code>adder</code>:</li>
</ul>
<div class="sourceCode" id="cb5"><pre class="sourceCode bash"><code class="sourceCode bash"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="ex">hdrcc</span> <span class="at">--yaml</span> <span class="at">--top</span> adder adder.rb adder</span></code></pre></div>
<ul>
<li>Compile <code>adder.rb</code> input file and generate a low-level Verilog HDL description into the directory <code>adder</code>:</li>
</ul>
<div class="sourceCode" id="cb6"><pre class="sourceCode bash"><code class="sourceCode bash"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="ex">hdrcc</span> <span class="at">-v</span> adder.rb adder</span></code></pre></div>
<ul>
<li>Compile system <code>adder</code> whose bit width is generic from <code>adder_gen.rb</code> input file to a 16-bit circuit low-level VHDL description into directory <code>adder</code>:</li>
</ul>
<div class="sourceCode" id="cb7"><pre class="sourceCode bash"><code class="sourceCode bash"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="ex">hdrcc</span> <span class="at">-V</span> <span class="at">-t</span> adder <span class="at">--param</span> 16 adder_gen.rb adder</span></code></pre></div>
<ul>
<li>Compile system <code>multer</code> with inputs and output bit width is generic from <code>multer_gen.rb</code> input file to a 16x16-&gt;32-bit circuit whose low-level YAML description into directory <code>multer</code>:</li>
</ul>
<div class="sourceCode" id="cb8"><pre class="sourceCode bash"><code class="sourceCode bash"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="ex">hdrcc</span> <span class="at">-y</span> <span class="at">-t</span> multer <span class="at">-p</span> 16,16,32 multer_gen.rb multer</span></code></pre></div>
<ul>
<li>Simulate the circuit described in file <code>counter_bench.rb</code> using the default simulation engine and putting the simulator’s files in the directory <code>counter</code>:</li>
</ul>
<div class="sourceCode" id="cb9"><pre class="sourceCode bash"><code class="sourceCode bash"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="ex">hdrcc</span> <span class="at">-S</span> counter_bench.rb counter</span></code></pre></div>
<p>As a policy, the default simulation engine is set to the fastest one (currently it is the hybrid engine).</p>
<ul>
<li>Run in interactive mode.</li>
</ul>
<div class="sourceCode" id="cb10"><pre class="sourceCode bash"><code class="sourceCode bash"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="ex">hdrcc</span> <span class="at">-I</span></span></code></pre></div>
<ul>
<li>Run in interactive mode using pry as UI.</li>
</ul>
<div class="sourceCode" id="cb11"><pre class="sourceCode bash"><code class="sourceCode bash"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="ex">hdrcc</span> <span class="at">-I</span> pry</span></code></pre></div>
<h2 id="using-hdlruby-in-interactive-mode">Using HDLRuby in interactive mode</h2>
<p>When running in interactive mode, the HDLRuby framework starts a REPL prompt and creates a working directory called ‘HDLRubyWorkspace’. By default, the REPL is ‘irb’, but it can be set to ‘pry’. Within this prompt, HDLRuby code can be written like in an HDLRuby description file. However, to process this code the following commands are added:</p>
<ul>
<li>Compile an HDLRuby module:</li>
</ul>
<div class="sourceCode" id="cb12"><pre class="sourceCode ruby"><code class="sourceCode ruby"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a>hdr_make(<span class="kw">&lt;</span><span class="cf">module</span><span class="kw">&gt;</span>)</span></code></pre></div>
<ul>
<li>Generate and display the IR of the compiled module in YAML form:</li>
</ul>
<div class="sourceCode" id="cb13"><pre class="sourceCode ruby"><code class="sourceCode ruby"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a>hdr_yaml</span></code></pre></div>
<ul>
<li>Regenerate and display the HDLRuby description of the compiled module:</li>
</ul>
<div class="sourceCode" id="cb14"><pre class="sourceCode ruby"><code class="sourceCode ruby"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a>hdr_hdr</span></code></pre></div>
<ul>
<li>Generate and output in the working directory the Verilog HDL RTL of the compiled module:</li>
</ul>
<div class="sourceCode" id="cb15"><pre class="sourceCode ruby"><code class="sourceCode ruby"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a>hdr_verilog</span></code></pre></div>
<ul>
<li>Generate and output in the working directory the Verilog HDL RTL of the compiled module:</li>
</ul>
<div class="sourceCode" id="cb16"><pre class="sourceCode ruby"><code class="sourceCode ruby"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a>hdr_vhdl</span></code></pre></div>
<ul>
<li>Simulate the compiled module:</li>
</ul>
<div class="sourceCode" id="cb17"><pre class="sourceCode ruby"><code class="sourceCode ruby"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a>hdr_sim</span></code></pre></div>
<h1 id="hdlruby-programming-guide">HDLRuby programming guide</h1>
<p>HDLRuby has been designed to bring the high flexibility of the Ruby language to hardware descriptions while ensuring that they remain synthesizable. In this context, all the abstractions provided by HDLRuby are in the way of describing hardware, but not in its execution model, this latter being RTL by construction.</p>
<p>The second specificity of HDLRuby is that it supports natively all the features of the Ruby language.</p>
<p><strong>Notes</strong>:</p>
<ul>
<li>It is still possible to extend HDLRuby to support hardware descriptions of a higher level than RTL, please refer to section <a href="#extending-hdlruby">Extending HDLRuby</a> for more details.</li>
<li>In this document, HDLRuby constructs will often be compared to their Verilog HDL or VHDL equivalents for simpler explanations.</li>
</ul>
<h2 id="introduction">Introduction</h2>
<p>This introduction gives a glimpse of the possibilities of the language. However, we do recommend consulting the section about the <a href="#high-level-programming-features">high-level programming features</a> to have a more complete view of the advanced possibilities of this language.</p>
<p>At first glance, HDLRuby appears like any other HDL (like Verilog HDL or VHDL), for instance, the following code describes a simple D-FF:</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode ruby"><code class="sourceCode ruby"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a><span class="fu">system</span> <span class="wa">:dff</span> <span class="cf">do</span></span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true" tabindex="-1"></a>   bit<span class="at">.input</span> <span class="wa">:clk</span>, <span class="wa">:rst</span>, <span class="wa">:d</span></span>
<span id="cb18-3"><a href="#cb18-3" aria-hidden="true" tabindex="-1"></a>   bit<span class="at">.output</span> <span class="wa">:q</span></span>
<span id="cb18-4"><a href="#cb18-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-5"><a href="#cb18-5" aria-hidden="true" tabindex="-1"></a>   par(clk<span class="at">.posedge</span>) <span class="cf">do</span></span>
<span id="cb18-6"><a href="#cb18-6" aria-hidden="true" tabindex="-1"></a>      q <span class="kw">&lt;=</span> d <span class="kw">&amp;</span> <span class="kw">~</span>rst</span>
<span id="cb18-7"><a href="#cb18-7" aria-hidden="true" tabindex="-1"></a>   <span class="cf">end</span></span>
<span id="cb18-8"><a href="#cb18-8" aria-hidden="true" tabindex="-1"></a><span class="cf">end</span></span></code></pre></div>
<p>As can be seen in the code above, <code>system</code> is the keyword used for describing a digital circuit. This keyword is the equivalent of the Verilog HDL <code>module</code>. In such a system, signals are declared using a <code>&lt;type&gt;.&lt;direction&gt;</code> construct where <code>type</code> is the data type of the signal (e.g., <code>bit</code> as in the code above) and <code>direction</code> indicates if the signal is an input, an output, an inout or an inner one; and executable blocks (similar to <code>always</code> block of Verilog HDL) are described using the <code>par</code> keyword when they are parallel and <code>seq</code> when they are sequential (i.e., with respectively non-blocking and blocking assignments).</p>
<p>After such a system has been defined, it can be instantiated. For example, a single instance of the <code>dff</code> system named <code>dff0</code> can be declared as follows:</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode ruby"><code class="sourceCode ruby"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a>dff <span class="wa">:dff0</span></span></code></pre></div>
<p>The ports of this instance can then be accessed to be used like any other signals, e.g., <code>dff0.d</code> for accessing the <code>d</code> input of the FF.</p>
<p>Several instances can also be declared in a single statement. For example, a 2-bit counter based on the previous <code>dff</code> circuits can be described as follows:</p>
<div class="sourceCode" id="cb20"><pre class="sourceCode ruby"><code class="sourceCode ruby"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true" tabindex="-1"></a><span class="fu">system</span> <span class="wa">:counter2</span> <span class="cf">do</span></span>
<span id="cb20-2"><a href="#cb20-2" aria-hidden="true" tabindex="-1"></a>   input <span class="wa">:clk</span>,<span class="wa">:rst</span></span>
<span id="cb20-3"><a href="#cb20-3" aria-hidden="true" tabindex="-1"></a>   output <span class="wa">:q</span></span>
<span id="cb20-4"><a href="#cb20-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-5"><a href="#cb20-5" aria-hidden="true" tabindex="-1"></a>   dff <span class="kw">[</span> <span class="wa">:dff0</span>, <span class="wa">:dff1</span> <span class="kw">]</span></span>
<span id="cb20-6"><a href="#cb20-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-7"><a href="#cb20-7" aria-hidden="true" tabindex="-1"></a>   dff0<span class="at">.clk</span> <span class="kw">&lt;=</span> clk</span>
<span id="cb20-8"><a href="#cb20-8" aria-hidden="true" tabindex="-1"></a>   dff0<span class="at">.rst</span> <span class="kw">&lt;=</span> rst</span>
<span id="cb20-9"><a href="#cb20-9" aria-hidden="true" tabindex="-1"></a>   dff0<span class="at">.d</span>   <span class="kw">&lt;=</span> <span class="kw">~</span>dff0<span class="at">.q</span></span>
<span id="cb20-10"><a href="#cb20-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-11"><a href="#cb20-11" aria-hidden="true" tabindex="-1"></a>   dff1<span class="at">.clk</span> <span class="kw">&lt;=</span> <span class="kw">~</span>dff0<span class="at">.q</span> </span>
<span id="cb20-12"><a href="#cb20-12" aria-hidden="true" tabindex="-1"></a>   dff1<span class="at">.rst</span> <span class="kw">&lt;=</span> rst</span>
<span id="cb20-13"><a href="#cb20-13" aria-hidden="true" tabindex="-1"></a>   dff1<span class="at">.d</span>   <span class="kw">&lt;=</span> <span class="kw">~</span>dff1<span class="at">.q</span></span>
<span id="cb20-14"><a href="#cb20-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-15"><a href="#cb20-15" aria-hidden="true" tabindex="-1"></a>   q <span class="kw">&lt;=</span> dff1<span class="at">.q</span></span>
<span id="cb20-16"><a href="#cb20-16" aria-hidden="true" tabindex="-1"></a><span class="cf">end</span></span></code></pre></div>
<p>The instances can also be connected while being declared. For example, the code above can be rewritten as follows:</p>
<div class="sourceCode" id="cb21"><pre class="sourceCode ruby"><code class="sourceCode ruby"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true" tabindex="-1"></a><span class="fu">system</span> <span class="wa">:counter2</span> <span class="cf">do</span></span>
<span id="cb21-2"><a href="#cb21-2" aria-hidden="true" tabindex="-1"></a>   input <span class="wa">:clk</span>, <span class="wa">:rst</span></span>
<span id="cb21-3"><a href="#cb21-3" aria-hidden="true" tabindex="-1"></a>   output <span class="wa">:q</span></span>
<span id="cb21-4"><a href="#cb21-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-5"><a href="#cb21-5" aria-hidden="true" tabindex="-1"></a>   dff(<span class="wa">:dff0</span>)<span class="kw">.</span>(<span class="wa">clk: </span>clk, <span class="wa">rst: </span>rst, <span class="wa">d: </span><span class="kw">~</span>dff0<span class="at">.q</span>)</span>
<span id="cb21-6"><a href="#cb21-6" aria-hidden="true" tabindex="-1"></a>   dff(<span class="wa">:dff1</span>)<span class="kw">.</span>(<span class="kw">~</span>dff0<span class="at">.q</span>, rst, <span class="kw">~</span>dff1<span class="at">.q</span>, q)</span>
<span id="cb21-7"><a href="#cb21-7" aria-hidden="true" tabindex="-1"></a><span class="cf">end</span></span></code></pre></div>
<p>In the code above, two possible connection methods are shown: for <code>dff0</code> ports are connected by name, and for <code>dff1</code> ports are connected in declaration order. Please notice that it is also possible to connect only a subset of the ports while declaring, as well as to reconnect already connected ports in further statements.</p>
<p>While a circuit can be generated from the code given above, a benchmark must be provided to test it. Such a benchmark is described by constructs called timed behavior that give the evolution of signals depending on the time. For example, the following code simulates the previous D-FF for 4 cycles of 20ns each, with a reset on the first cycle, set of signal <code>d</code> to 1 for the third cycle and set this signal to 0 for the last.</p>
<div class="sourceCode" id="cb22"><pre class="sourceCode ruby"><code class="sourceCode ruby"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true" tabindex="-1"></a><span class="fu">system</span> <span class="wa">:dff_bench</span> <span class="cf">do</span></span>
<span id="cb22-2"><a href="#cb22-2" aria-hidden="true" tabindex="-1"></a>   </span>
<span id="cb22-3"><a href="#cb22-3" aria-hidden="true" tabindex="-1"></a>   dff <span class="wa">:dff0</span></span>
<span id="cb22-4"><a href="#cb22-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-5"><a href="#cb22-5" aria-hidden="true" tabindex="-1"></a>   timed <span class="cf">do</span></span>
<span id="cb22-6"><a href="#cb22-6" aria-hidden="true" tabindex="-1"></a>      dff0<span class="at">.clk</span> <span class="kw">&lt;=</span> <span class="dv">0</span></span>
<span id="cb22-7"><a href="#cb22-7" aria-hidden="true" tabindex="-1"></a>      dff0<span class="at">.rst</span> <span class="kw">&lt;=</span> <span class="dv">1</span></span>
<span id="cb22-8"><a href="#cb22-8" aria-hidden="true" tabindex="-1"></a>      !<span class="dv">10</span><span class="at">.ns</span></span>
<span id="cb22-9"><a href="#cb22-9" aria-hidden="true" tabindex="-1"></a>      dff0<span class="at">.clk</span> <span class="kw">&lt;=</span> <span class="dv">1</span></span>
<span id="cb22-10"><a href="#cb22-10" aria-hidden="true" tabindex="-1"></a>      !<span class="dv">10</span><span class="at">.ns</span></span>
<span id="cb22-11"><a href="#cb22-11" aria-hidden="true" tabindex="-1"></a>      dff0<span class="at">.clk</span> <span class="kw">&lt;=</span> <span class="dv">0</span></span>
<span id="cb22-12"><a href="#cb22-12" aria-hidden="true" tabindex="-1"></a>      dff0<span class="at">.rst</span> <span class="kw">&lt;=</span> <span class="dv">0</span></span>
<span id="cb22-13"><a href="#cb22-13" aria-hidden="true" tabindex="-1"></a>      dff0<span class="at">.d</span>   <span class="kw">&lt;=</span> <span class="dv">1</span></span>
<span id="cb22-14"><a href="#cb22-14" aria-hidden="true" tabindex="-1"></a>      !<span class="dv">10</span><span class="at">.ns</span></span>
<span id="cb22-15"><a href="#cb22-15" aria-hidden="true" tabindex="-1"></a>      dff0<span class="at">.clk</span> <span class="kw">&lt;=</span> <span class="dv">1</span></span>
<span id="cb22-16"><a href="#cb22-16" aria-hidden="true" tabindex="-1"></a>      !<span class="dv">10</span><span class="at">.ns</span></span>
<span id="cb22-17"><a href="#cb22-17" aria-hidden="true" tabindex="-1"></a>      dff0<span class="at">.clk</span> <span class="kw">&lt;=</span> <span class="dv">0</span></span>
<span id="cb22-18"><a href="#cb22-18" aria-hidden="true" tabindex="-1"></a>      !<span class="dv">10</span><span class="at">.ns</span></span>
<span id="cb22-19"><a href="#cb22-19" aria-hidden="true" tabindex="-1"></a>      dff0<span class="at">.clk</span> <span class="kw">&lt;=</span> <span class="dv">1</span></span>
<span id="cb22-20"><a href="#cb22-20" aria-hidden="true" tabindex="-1"></a>      !<span class="dv">10</span><span class="at">.ns</span></span>
<span id="cb22-21"><a href="#cb22-21" aria-hidden="true" tabindex="-1"></a>      dff0<span class="at">.clk</span> <span class="kw">&lt;=</span> <span class="dv">0</span></span>
<span id="cb22-22"><a href="#cb22-22" aria-hidden="true" tabindex="-1"></a>      dff0<span class="at">.d</span>   <span class="kw">&lt;=</span> <span class="dv">1</span></span>
<span id="cb22-23"><a href="#cb22-23" aria-hidden="true" tabindex="-1"></a>      !<span class="dv">10</span><span class="at">.ns</span></span>
<span id="cb22-24"><a href="#cb22-24" aria-hidden="true" tabindex="-1"></a>      dff0<span class="at">.clk</span> <span class="kw">&lt;=</span> <span class="dv">1</span></span>
<span id="cb22-25"><a href="#cb22-25" aria-hidden="true" tabindex="-1"></a>      !<span class="dv">10</span><span class="at">.ns</span></span>
<span id="cb22-26"><a href="#cb22-26" aria-hidden="true" tabindex="-1"></a>   <span class="cf">end</span></span>
<span id="cb22-27"><a href="#cb22-27" aria-hidden="true" tabindex="-1"></a><span class="cf">end</span></span></code></pre></div>
<hr />
<p>The code describing a <code>dff</code> given above is not much different from its equivalent in any other HDL. However, HDLRuby provides several features for achieving higher productivity when describing hardware. We will now describe a few of them.</p>
<p>First, several syntactic sugars exist that allow shorter code, for instance, the following code is strictly equivalent to the previous description of <code>dff</code>:</p>
<div class="sourceCode" id="cb23"><pre class="sourceCode ruby"><code class="sourceCode ruby"><span id="cb23-1"><a href="#cb23-1" aria-hidden="true" tabindex="-1"></a><span class="fu">system</span> <span class="wa">:dff</span> <span class="cf">do</span></span>
<span id="cb23-2"><a href="#cb23-2" aria-hidden="true" tabindex="-1"></a>   input <span class="wa">:clk</span>, <span class="wa">:rst</span>, <span class="wa">:d</span></span>
<span id="cb23-3"><a href="#cb23-3" aria-hidden="true" tabindex="-1"></a>   output <span class="wa">:q</span></span>
<span id="cb23-4"><a href="#cb23-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-5"><a href="#cb23-5" aria-hidden="true" tabindex="-1"></a>   (q <span class="kw">&lt;=</span> d <span class="kw">&amp;</span> <span class="kw">~</span>rst)<span class="at">.at</span>(clk<span class="at">.posedge</span>)</span>
<span id="cb23-6"><a href="#cb23-6" aria-hidden="true" tabindex="-1"></a><span class="cf">end</span></span></code></pre></div>
<p>Then, it often happens that a system will end up with only one instance. In such a case, the system declaration can be omitted, and an instance can be directly declared as follows:</p>
<div class="sourceCode" id="cb24"><pre class="sourceCode ruby"><code class="sourceCode ruby"><span id="cb24-1"><a href="#cb24-1" aria-hidden="true" tabindex="-1"></a>instance <span class="wa">:dff_single</span> <span class="cf">do</span></span>
<span id="cb24-2"><a href="#cb24-2" aria-hidden="true" tabindex="-1"></a>   input <span class="wa">:clk</span>, <span class="wa">:rst</span>, <span class="wa">:d</span></span>
<span id="cb24-3"><a href="#cb24-3" aria-hidden="true" tabindex="-1"></a>   output <span class="wa">:q</span></span>
<span id="cb24-4"><a href="#cb24-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-5"><a href="#cb24-5" aria-hidden="true" tabindex="-1"></a>   (q <span class="kw">&lt;=</span> d <span class="kw">&amp;</span> <span class="kw">~</span>rst)<span class="at">.at</span>(clk<span class="at">.posedge</span>)</span>
<span id="cb24-6"><a href="#cb24-6" aria-hidden="true" tabindex="-1"></a><span class="cf">end</span></span></code></pre></div>
<p>In the example above, <code>dff_single</code> is an instance describing, again, a D-FF, but whose system is anonymous.</p>
<p>Furthermore, generic parameters can be used for anything in HDLRuby. For instance, the following code describes an 8-bit register without any parameterization:</p>
<div class="sourceCode" id="cb25"><pre class="sourceCode ruby"><code class="sourceCode ruby"><span id="cb25-1"><a href="#cb25-1" aria-hidden="true" tabindex="-1"></a><span class="fu">system</span> <span class="wa">:reg8</span> <span class="cf">do</span></span>
<span id="cb25-2"><a href="#cb25-2" aria-hidden="true" tabindex="-1"></a>   input <span class="wa">:clk</span>, <span class="wa">:rst</span></span>
<span id="cb25-3"><a href="#cb25-3" aria-hidden="true" tabindex="-1"></a>   <span class="kw">[</span><span class="dv">7</span><span class="kw">..</span><span class="dv">0</span><span class="kw">]</span><span class="at">.input</span> <span class="wa">:d</span></span>
<span id="cb25-4"><a href="#cb25-4" aria-hidden="true" tabindex="-1"></a>   <span class="kw">[</span><span class="dv">7</span><span class="kw">..</span><span class="dv">0</span><span class="kw">]</span><span class="at">.output</span> <span class="wa">:q</span></span>
<span id="cb25-5"><a href="#cb25-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-6"><a href="#cb25-6" aria-hidden="true" tabindex="-1"></a>   (q <span class="kw">&lt;=</span> d <span class="kw">&amp;</span> <span class="kw">[~</span>rst<span class="kw">]*</span><span class="dv">8</span>)<span class="at">.at</span>(clk<span class="at">.posedge</span>)</span>
<span id="cb25-7"><a href="#cb25-7" aria-hidden="true" tabindex="-1"></a><span class="cf">end</span></span></code></pre></div>
<p>But it is also possible to describe a register of arbitrary size as follows, where <code>n</code> is the parameter giving the number of bits of the register:</p>
<div class="sourceCode" id="cb26"><pre class="sourceCode ruby"><code class="sourceCode ruby"><span id="cb26-1"><a href="#cb26-1" aria-hidden="true" tabindex="-1"></a><span class="fu">system</span> <span class="wa">:regn</span> <span class="cf">do</span> <span class="kw">|</span>n<span class="kw">|</span></span>
<span id="cb26-2"><a href="#cb26-2" aria-hidden="true" tabindex="-1"></a>   input <span class="wa">:clk</span>, <span class="wa">:rst</span></span>
<span id="cb26-3"><a href="#cb26-3" aria-hidden="true" tabindex="-1"></a>   <span class="kw">[</span>n<span class="dv">-1</span><span class="kw">..</span><span class="dv">0</span><span class="kw">]</span><span class="at">.input</span> <span class="wa">:d</span></span>
<span id="cb26-4"><a href="#cb26-4" aria-hidden="true" tabindex="-1"></a>   <span class="kw">[</span>n<span class="dv">-1</span><span class="kw">..</span><span class="dv">0</span><span class="kw">]</span><span class="at">.output</span> <span class="wa">:q</span></span>
<span id="cb26-5"><a href="#cb26-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-6"><a href="#cb26-6" aria-hidden="true" tabindex="-1"></a>   (q <span class="kw">&lt;=</span> d <span class="kw">&amp;</span> <span class="kw">[~</span>rst<span class="kw">]*</span>n)<span class="at">.at</span>(clk<span class="at">.posedge</span>)</span>
<span id="cb26-7"><a href="#cb26-7" aria-hidden="true" tabindex="-1"></a><span class="cf">end</span></span></code></pre></div>
<p>Or, even further, it is possible to describe a register of arbitrary type (not only bit vectors) as follows:</p>
<div class="sourceCode" id="cb27"><pre class="sourceCode ruby"><code class="sourceCode ruby"><span id="cb27-1"><a href="#cb27-1" aria-hidden="true" tabindex="-1"></a><span class="fu">system</span> <span class="wa">:reg</span> <span class="cf">do</span> <span class="kw">|</span>typ<span class="kw">|</span></span>
<span id="cb27-2"><a href="#cb27-2" aria-hidden="true" tabindex="-1"></a>   input <span class="wa">:clk</span>, <span class="wa">:rst</span></span>
<span id="cb27-3"><a href="#cb27-3" aria-hidden="true" tabindex="-1"></a>   typ<span class="at">.input</span> <span class="wa">:d</span></span>
<span id="cb27-4"><a href="#cb27-4" aria-hidden="true" tabindex="-1"></a>   typ<span class="at">.output</span> <span class="wa">:q</span></span>
<span id="cb27-5"><a href="#cb27-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-6"><a href="#cb27-6" aria-hidden="true" tabindex="-1"></a>   (q <span class="kw">&lt;=</span> d <span class="kw">&amp;</span> <span class="kw">[~</span>rst<span class="kw">]*</span>typ<span class="at">.width</span>)<span class="at">.at</span>(clk<span class="at">.posedge</span>)</span>
<span id="cb27-7"><a href="#cb27-7" aria-hidden="true" tabindex="-1"></a><span class="cf">end</span></span></code></pre></div>
<p>Wait… I have just realized that D-FF without any inverted output does not look very serious. So, let us extend the existing <code>dff</code> to provide an inverted output. There are three ways to do this. First, inheritance can be used: a new system is built inheriting from <code>dff</code> as it is done in the following code.</p>
<div class="sourceCode" id="cb28"><pre class="sourceCode ruby"><code class="sourceCode ruby"><span id="cb28-1"><a href="#cb28-1" aria-hidden="true" tabindex="-1"></a><span class="fu">system</span> <span class="wa">:dff_full</span>, dff <span class="cf">do</span></span>
<span id="cb28-2"><a href="#cb28-2" aria-hidden="true" tabindex="-1"></a>   output <span class="wa">:qb</span></span>
<span id="cb28-3"><a href="#cb28-3" aria-hidden="true" tabindex="-1"></a>   qb <span class="kw">&lt;=</span> <span class="kw">~</span>q</span>
<span id="cb28-4"><a href="#cb28-4" aria-hidden="true" tabindex="-1"></a><span class="cf">end</span></span></code></pre></div>
<p>The second possibility is to modify <code>dff</code> afterward. In HDLRuby, this is achieved using the <code>open</code> method as it is done in the following code:</p>
<div class="sourceCode" id="cb29"><pre class="sourceCode ruby"><code class="sourceCode ruby"><span id="cb29-1"><a href="#cb29-1" aria-hidden="true" tabindex="-1"></a>dff<span class="at">.open</span> <span class="cf">do</span></span>
<span id="cb29-2"><a href="#cb29-2" aria-hidden="true" tabindex="-1"></a>   output <span class="wa">:qb</span></span>
<span id="cb29-3"><a href="#cb29-3" aria-hidden="true" tabindex="-1"></a>   qb <span class="kw">&lt;=</span> <span class="kw">~</span>q</span>
<span id="cb29-4"><a href="#cb29-4" aria-hidden="true" tabindex="-1"></a><span class="cf">end</span></span></code></pre></div>
<p>The third possibility is to modify directly a single instance of <code>dff</code> which requires an inverted output, using again the <code>open</code> method, as in the following code:</p>
<div class="sourceCode" id="cb30"><pre class="sourceCode ruby"><code class="sourceCode ruby"><span id="cb30-1"><a href="#cb30-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Declare dff0 as an instance of dff</span></span>
<span id="cb30-2"><a href="#cb30-2" aria-hidden="true" tabindex="-1"></a>dff <span class="wa">:dff0</span></span>
<span id="cb30-3"><a href="#cb30-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-4"><a href="#cb30-4" aria-hidden="true" tabindex="-1"></a><span class="co"># Modify it</span></span>
<span id="cb30-5"><a href="#cb30-5" aria-hidden="true" tabindex="-1"></a>dff0<span class="at">.open</span> <span class="cf">do</span></span>
<span id="cb30-6"><a href="#cb30-6" aria-hidden="true" tabindex="-1"></a>   output <span class="wa">:qb</span></span>
<span id="cb30-7"><a href="#cb30-7" aria-hidden="true" tabindex="-1"></a>   qb <span class="kw">&lt;=</span> <span class="kw">~</span>q</span>
<span id="cb30-8"><a href="#cb30-8" aria-hidden="true" tabindex="-1"></a><span class="cf">end</span></span></code></pre></div>
<p>In this latter case, only <code>dff0</code> will have an inverted output, the other instances of <code>dff</code> will not change.</p>
<p>Now assuming we opted for the first solution, we have now <code>dff_full</code>, a highly advanced D-FF with such unique features as an inverted output. So, we would like to use it in other designs, for example, a shift register of <code>n</code> bits. Such a system will include a generic number of <code>dff_full</code> instances and can be described as follows making use of the native Ruby method <code>each_cons</code> for connecting them:</p>
<div class="sourceCode" id="cb31"><pre class="sourceCode ruby"><code class="sourceCode ruby"><span id="cb31-1"><a href="#cb31-1" aria-hidden="true" tabindex="-1"></a><span class="fu">system</span> <span class="wa">:shifter</span> <span class="cf">do</span> <span class="kw">|</span>n<span class="kw">|</span></span>
<span id="cb31-2"><a href="#cb31-2" aria-hidden="true" tabindex="-1"></a>   input <span class="wa">:clk</span>, <span class="wa">:rst</span></span>
<span id="cb31-3"><a href="#cb31-3" aria-hidden="true" tabindex="-1"></a>   input <span class="wa">:i0</span></span>
<span id="cb31-4"><a href="#cb31-4" aria-hidden="true" tabindex="-1"></a>   output <span class="wa">:o0</span>, <span class="wa">:o0b</span></span>
<span id="cb31-5"><a href="#cb31-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb31-6"><a href="#cb31-6" aria-hidden="true" tabindex="-1"></a>   <span class="co"># Instantiating n D-FF</span></span>
<span id="cb31-7"><a href="#cb31-7" aria-hidden="true" tabindex="-1"></a>   <span class="kw">[</span>n<span class="kw">]</span><span class="at">.dff_full</span> <span class="wa">:dffIs</span></span>
<span id="cb31-8"><a href="#cb31-8" aria-hidden="true" tabindex="-1"></a>   </span>
<span id="cb31-9"><a href="#cb31-9" aria-hidden="true" tabindex="-1"></a>   <span class="co"># Connect the clock and the reset.</span></span>
<span id="cb31-10"><a href="#cb31-10" aria-hidden="true" tabindex="-1"></a>   dffIs<span class="at">.each</span> <span class="kw">{</span> <span class="kw">|</span>ff<span class="kw">|</span> ff<span class="at">.clk</span> <span class="kw">&lt;=</span> clk ; ff<span class="at">.rst</span> <span class="kw">&lt;=</span> rst <span class="kw">}</span></span>
<span id="cb31-11"><a href="#cb31-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb31-12"><a href="#cb31-12" aria-hidden="true" tabindex="-1"></a>   <span class="co"># Interconnect them as a shift register</span></span>
<span id="cb31-13"><a href="#cb31-13" aria-hidden="true" tabindex="-1"></a>   dffIs<span class="kw">[</span><span class="dv">0</span><span class="kw">..-</span><span class="dv">1</span><span class="kw">]</span><span class="at">.each_cons</span>(<span class="dv">2</span>) <span class="kw">{</span> <span class="kw">|</span>ff0,ff1<span class="kw">|</span> ff1<span class="at">.d</span> <span class="kw">&lt;=</span> ff0<span class="at">.q</span> <span class="kw">}</span></span>
<span id="cb31-14"><a href="#cb31-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb31-15"><a href="#cb31-15" aria-hidden="true" tabindex="-1"></a>   <span class="co"># Connects the input and output of the circuit</span></span>
<span id="cb31-16"><a href="#cb31-16" aria-hidden="true" tabindex="-1"></a>   dffIs<span class="kw">[</span><span class="dv">0</span><span class="kw">]</span><span class="at">.d</span> <span class="kw">&lt;=</span> i0</span>
<span id="cb31-17"><a href="#cb31-17" aria-hidden="true" tabindex="-1"></a>   o0 <span class="kw">&lt;=</span> dffIs<span class="kw">[-</span><span class="dv">1</span><span class="kw">]</span><span class="at">.q</span></span>
<span id="cb31-18"><a href="#cb31-18" aria-hidden="true" tabindex="-1"></a>   o0b <span class="kw">&lt;=</span> dffIs<span class="kw">[-</span><span class="dv">1</span><span class="kw">]</span><span class="at">.qb</span></span>
<span id="cb31-19"><a href="#cb31-19" aria-hidden="true" tabindex="-1"></a><span class="cf">end</span></span></code></pre></div>
<p>As can be seen in the above examples, in HDLRuby, any construct is an object and therefore includes methods. For instance, declaring a signal of a given <code>type</code> and direction (input, output, or inout) is done as follows so that <code>direction</code> is a method of the type, and the signal names are the arguments of this method (symbols or string are supported.)</p>
<div class="sourceCode" id="cb32"><pre class="sourceCode ruby"><code class="sourceCode ruby"><span id="cb32-1"><a href="#cb32-1" aria-hidden="true" tabindex="-1"></a><span class="kw">&lt;</span>type<span class="kw">&gt;.&lt;</span>direction<span class="kw">&gt;</span> <span class="kw">&lt;</span>list of symbols representing the signal<span class="kw">&gt;</span></span></code></pre></div>
<p>Of course, if you do not need to use the specific component <code>dff_full</code> you can describe a shift register more simply as follows:</p>
<div class="sourceCode" id="cb33"><pre class="sourceCode ruby"><code class="sourceCode ruby"><span id="cb33-1"><a href="#cb33-1" aria-hidden="true" tabindex="-1"></a><span class="fu">system</span> <span class="wa">:shifter</span> <span class="cf">do</span> <span class="kw">|</span>n<span class="kw">|</span></span>
<span id="cb33-2"><a href="#cb33-2" aria-hidden="true" tabindex="-1"></a>   input <span class="wa">:clk</span>, <span class="wa">:rst</span></span>
<span id="cb33-3"><a href="#cb33-3" aria-hidden="true" tabindex="-1"></a>   input <span class="wa">:i0</span></span>
<span id="cb33-4"><a href="#cb33-4" aria-hidden="true" tabindex="-1"></a>   output <span class="wa">:o0</span></span>
<span id="cb33-5"><a href="#cb33-5" aria-hidden="true" tabindex="-1"></a>   <span class="kw">[</span>n<span class="kw">]</span><span class="at">.inner</span> <span class="wa">:sh</span></span>
<span id="cb33-6"><a href="#cb33-6" aria-hidden="true" tabindex="-1"></a>   </span>
<span id="cb33-7"><a href="#cb33-7" aria-hidden="true" tabindex="-1"></a>   par (clk<span class="at">.posedge</span>) <span class="cf">do</span></span>
<span id="cb33-8"><a href="#cb33-8" aria-hidden="true" tabindex="-1"></a>      hif(rst) <span class="kw">{</span> sh <span class="kw">&lt;=</span> <span class="dv">0</span> <span class="kw">}</span></span>
<span id="cb33-9"><a href="#cb33-9" aria-hidden="true" tabindex="-1"></a>      helse <span class="kw">{</span> sh <span class="kw">&lt;=</span> <span class="kw">[</span>sh<span class="kw">[</span>n<span class="dv">-2</span><span class="kw">..</span><span class="dv">0</span><span class="kw">]</span>, i0<span class="kw">]</span> <span class="kw">}</span></span>
<span id="cb33-10"><a href="#cb33-10" aria-hidden="true" tabindex="-1"></a>   <span class="cf">end</span></span>
<span id="cb33-11"><a href="#cb33-11" aria-hidden="true" tabindex="-1"></a>   </span>
<span id="cb33-12"><a href="#cb33-12" aria-hidden="true" tabindex="-1"></a>   o0 <span class="kw">&lt;=</span> sh<span class="kw">[</span>n<span class="dv">-1</span><span class="kw">]</span></span>
<span id="cb33-13"><a href="#cb33-13" aria-hidden="true" tabindex="-1"></a><span class="cf">end</span></span></code></pre></div>
<p>Now, let us assume you want to design a circuit that performs a sum of products of several inputs with constant coefficients. For the case of 4 16-bit signed inputs and given coefficients as 3, 4, 5, and 6. The corresponding basic code could be as follows:</p>
<div class="sourceCode" id="cb34"><pre class="sourceCode ruby"><code class="sourceCode ruby"><span id="cb34-1"><a href="#cb34-1" aria-hidden="true" tabindex="-1"></a><span class="fu">system</span> <span class="wa">:sumprod_16_3456</span> <span class="cf">do</span></span>
<span id="cb34-2"><a href="#cb34-2" aria-hidden="true" tabindex="-1"></a>   signed<span class="kw">[</span><span class="dv">16</span><span class="kw">]</span><span class="at">.input</span> <span class="wa">:i0</span>, <span class="wa">:i1</span>, <span class="wa">:i2</span>, <span class="wa">:i3</span></span>
<span id="cb34-3"><a href="#cb34-3" aria-hidden="true" tabindex="-1"></a>   signed<span class="kw">[</span><span class="dv">16</span><span class="kw">]</span><span class="at">.output</span> <span class="wa">:o</span></span>
<span id="cb34-4"><a href="#cb34-4" aria-hidden="true" tabindex="-1"></a>   </span>
<span id="cb34-5"><a href="#cb34-5" aria-hidden="true" tabindex="-1"></a>   o <span class="kw">&lt;=</span> i0<span class="kw">*</span><span class="dv">3</span> <span class="kw">+</span> i1<span class="kw">*</span><span class="dv">4</span> <span class="kw">+</span> i2<span class="kw">*</span><span class="dv">5</span> <span class="kw">+</span> i3<span class="kw">*</span><span class="dv">6</span></span>
<span id="cb34-6"><a href="#cb34-6" aria-hidden="true" tabindex="-1"></a><span class="cf">end</span></span></code></pre></div>
<p>The description above is straightforward, but it would be necessary to rewrite it if another circuit with different bit widths or coefficients is to be designed. Moreover, if the number of coefficients is large an error in the expression will be easy to make and hard to find. A better approach would be to use a generic description of such a circuit as follows:</p>
<div class="sourceCode" id="cb35"><pre class="sourceCode ruby"><code class="sourceCode ruby"><span id="cb35-1"><a href="#cb35-1" aria-hidden="true" tabindex="-1"></a><span class="fu">system</span> <span class="wa">:sumprod</span> <span class="cf">do</span> <span class="kw">|</span>typ,coefs<span class="kw">|</span></span>
<span id="cb35-2"><a href="#cb35-2" aria-hidden="true" tabindex="-1"></a>   typ<span class="kw">[</span>coefs<span class="at">.size</span><span class="kw">]</span><span class="at">.input</span> <span class="wa">:ins</span></span>
<span id="cb35-3"><a href="#cb35-3" aria-hidden="true" tabindex="-1"></a>   typ<span class="at">.output</span> <span class="wa">:o</span></span>
<span id="cb35-4"><a href="#cb35-4" aria-hidden="true" tabindex="-1"></a>   </span>
<span id="cb35-5"><a href="#cb35-5" aria-hidden="true" tabindex="-1"></a>   o <span class="kw">&lt;=</span> coefs<span class="at">.each_with_index.reduce</span>(_b0) <span class="cf">do</span> <span class="kw">|</span>sum,(coef,i)<span class="kw">|</span></span>
<span id="cb35-6"><a href="#cb35-6" aria-hidden="true" tabindex="-1"></a>      sum <span class="kw">+</span> ins<span class="kw">[</span>i<span class="kw">]*</span>coef</span>
<span id="cb35-7"><a href="#cb35-7" aria-hidden="true" tabindex="-1"></a>   <span class="cf">end</span></span>
<span id="cb35-8"><a href="#cb35-8" aria-hidden="true" tabindex="-1"></a><span class="cf">end</span></span></code></pre></div>
<p>In the code above, there are two generic parameters, <code>typ</code>, which indicates the data type of the circuit, and <code>coefs</code>, which is assumed to be an array of coefficients. Since the number of inputs depends on the number of provided coefficients, it is declared as an array of <code>width</code> bit signed whose size is equal to the number of coefficients.</p>
<p>The description of the sum of products may be more difficult to understand for people not familiar with the Ruby language. The <code>each_with_index</code> method iterates over the coefficients adding their index as an iteration variable, the resulting operation (i.e., the iteration loop) is then modified by the <code>reduce</code> method that accumulates the code passed as arguments. This code, starting by <code>|sum,coef,i|</code> performs the addition of the current accumulation result (<code>sum</code>) with the product of the current coefficient (<code>coef</code>) and input (<code>ins[i]</code>, where <code>i</code> is the index) in the iteration. The argument <code>_b0</code> initializes the sum to <code>0</code>.</p>
<p>While slightly longer than the previous description, this description allows declaring a circuit implementing a sum of products with any bit width and any number of coefficients. For instance, the following code describes a signed 32-bit sum of products with 16 coefficients (just random numbers here).</p>
<div class="sourceCode" id="cb36"><pre class="sourceCode ruby"><code class="sourceCode ruby"><span id="cb36-1"><a href="#cb36-1" aria-hidden="true" tabindex="-1"></a>sumprod(signed<span class="kw">[</span><span class="dv">32</span><span class="kw">]</span>, <span class="kw">[</span><span class="dv">3</span>,<span class="dv">78</span>,<span class="dv">43</span>,<span class="dv">246</span>, <span class="dv">3</span>,<span class="dv">67</span>,<span class="dv">1</span>,<span class="dv">8</span>, <span class="dv">47</span>,<span class="dv">82</span>,<span class="dv">99</span>,<span class="dv">13</span>, <span class="dv">5</span>,<span class="dv">77</span>,<span class="dv">2</span>,<span class="dv">4</span><span class="kw">]</span>)<span class="kw">.</span>(<span class="wa">:my_circuit</span>)  </span></code></pre></div>
<p>As seen in the code above, when passing a generic argument for instantiating a generic system, the name of the instance is put between brackets to avoid confusion.</p>
<p>While the description <code>sumprod</code> is already usable in a wide range of cases, it still uses standard addition and multiplication. However, there are cases where specific components are to be used for these operations, either for the sake of performance, compliance with constraints, or because functionally different operations are required (e.g., saturated computations). This can be solved by using functions implementing such computation in place of operators, for example, as follows:</p>
<div class="sourceCode" id="cb37"><pre class="sourceCode ruby"><code class="sourceCode ruby"><span id="cb37-1"><a href="#cb37-1" aria-hidden="true" tabindex="-1"></a><span class="fu">system</span> <span class="wa">:sumprod_func</span> <span class="cf">do</span> <span class="kw">|</span>typ,coefs<span class="kw">|</span></span>
<span id="cb37-2"><a href="#cb37-2" aria-hidden="true" tabindex="-1"></a>   typ<span class="kw">[</span>coefs<span class="at">.size</span><span class="kw">]</span><span class="at">.input</span> ins</span>
<span id="cb37-3"><a href="#cb37-3" aria-hidden="true" tabindex="-1"></a>   typ<span class="at">.output</span> <span class="wa">:o</span></span>
<span id="cb37-4"><a href="#cb37-4" aria-hidden="true" tabindex="-1"></a>   </span>
<span id="cb37-5"><a href="#cb37-5" aria-hidden="true" tabindex="-1"></a>   o <span class="kw">&lt;=</span> coefs<span class="at">.each_with_index.reduce</span>(_b0) <span class="cf">do</span> </span>
<span id="cb37-6"><a href="#cb37-6" aria-hidden="true" tabindex="-1"></a>   <span class="kw">|</span>sum,(coef,i)<span class="kw">|</span></span>
<span id="cb37-7"><a href="#cb37-7" aria-hidden="true" tabindex="-1"></a>      add(sum, mult(ins<span class="kw">[</span>i<span class="kw">]*</span>coef))</span>
<span id="cb37-8"><a href="#cb37-8" aria-hidden="true" tabindex="-1"></a>   <span class="cf">end</span></span>
<span id="cb37-9"><a href="#cb37-9" aria-hidden="true" tabindex="-1"></a><span class="cf">end</span></span></code></pre></div>
<p>Where <code>add</code> and <code>mult</code> are functions implementing the required specific operations. HDLRuby functions are equivalent to the Verilog HDL ones. In our example, an addition that saturates at 1000 could be described as follows:</p>
<div class="sourceCode" id="cb38"><pre class="sourceCode ruby"><code class="sourceCode ruby"><span id="cb38-1"><a href="#cb38-1" aria-hidden="true" tabindex="-1"></a>hdef <span class="wa">:add</span> <span class="cf">do</span> <span class="kw">|</span>x,y<span class="kw">|</span></span>
<span id="cb38-2"><a href="#cb38-2" aria-hidden="true" tabindex="-1"></a>   inner <span class="wa">:res</span></span>
<span id="cb38-3"><a href="#cb38-3" aria-hidden="true" tabindex="-1"></a>   seq <span class="cf">do</span></span>
<span id="cb38-4"><a href="#cb38-4" aria-hidden="true" tabindex="-1"></a>      res <span class="kw">&lt;=</span> x <span class="kw">+</span> y</span>
<span id="cb38-5"><a href="#cb38-5" aria-hidden="true" tabindex="-1"></a>      (res <span class="kw">&lt;=</span> <span class="dv">1000</span>)<span class="at">.hif</span>(res <span class="kw">&gt;</span> <span class="dv">1000</span>)</span>
<span id="cb38-6"><a href="#cb38-6" aria-hidden="true" tabindex="-1"></a>   <span class="cf">end</span></span>
<span id="cb38-7"><a href="#cb38-7" aria-hidden="true" tabindex="-1"></a><span class="cf">end</span></span></code></pre></div>
<p>With HDLRuby functions, the result of the last statement in the return value, in this case, that will be the value of res. The code above is also an example of the usage of the postfixed if statement, it is an equivalent of the following code:</p>
<div class="sourceCode" id="cb39"><pre class="sourceCode ruby"><code class="sourceCode ruby"><span id="cb39-1"><a href="#cb39-1" aria-hidden="true" tabindex="-1"></a>      hif(res<span class="kw">&gt;</span><span class="dv">1000</span>) <span class="kw">{</span> res <span class="kw">&lt;=</span> <span class="dv">1000</span> <span class="kw">}</span></span></code></pre></div>
<p>With functions, it is enough to change their content to obtain a new kind of circuit without changing the main code. This approach suffers from two drawbacks though: first, the level of saturation is hard coded in the function, and second, it would be preferable to be able to select the function to execute instead of modifying its code. For the first problem, a simple approach is to add an argument to the function given the saturation level. Such an add function would therefore be as follows:</p>
<div class="sourceCode" id="cb40"><pre class="sourceCode ruby"><code class="sourceCode ruby"><span id="cb40-1"><a href="#cb40-1" aria-hidden="true" tabindex="-1"></a>hdef <span class="wa">:add</span> <span class="cf">do</span> <span class="kw">|</span>max, x, y<span class="kw">|</span></span>
<span id="cb40-2"><a href="#cb40-2" aria-hidden="true" tabindex="-1"></a>   inner <span class="wa">:res</span></span>
<span id="cb40-3"><a href="#cb40-3" aria-hidden="true" tabindex="-1"></a>   seq <span class="cf">do</span></span>
<span id="cb40-4"><a href="#cb40-4" aria-hidden="true" tabindex="-1"></a>      res <span class="kw">&lt;=</span> x <span class="kw">+</span> y</span>
<span id="cb40-5"><a href="#cb40-5" aria-hidden="true" tabindex="-1"></a>      (res <span class="kw">&lt;=</span> max)<span class="at">.hif</span>(res <span class="kw">&gt;</span> max)</span>
<span id="cb40-6"><a href="#cb40-6" aria-hidden="true" tabindex="-1"></a>   <span class="cf">end</span></span>
<span id="cb40-7"><a href="#cb40-7" aria-hidden="true" tabindex="-1"></a><span class="cf">end</span></span></code></pre></div>
<p>It would however be necessary to add this argument when invoking the function, e.g., <code>add(1000,sum,mult(...))</code>. While this argument is relevant for addition with saturation, it is not for the other kinds of addition operations, and hence, the code of <code>sumprod</code> has no general purpose.</p>
<p>HDLRuby provides two ways to address such issues. First, it is possible to pass code as an argument. In the case of <code>sumprod</code>, it would then be enough to add two arguments that perform the required addition and multiplication. The example is below:</p>
<div class="sourceCode" id="cb41"><pre class="sourceCode ruby"><code class="sourceCode ruby"><span id="cb41-1"><a href="#cb41-1" aria-hidden="true" tabindex="-1"></a><span class="fu">system</span> <span class="wa">:sumprod_proc</span> <span class="cf">do</span> <span class="kw">|</span>add,mult,typ,coefs<span class="kw">|</span></span>
<span id="cb41-2"><a href="#cb41-2" aria-hidden="true" tabindex="-1"></a>   typ<span class="kw">[</span>coefs<span class="at">.size</span><span class="kw">]</span><span class="at">.input</span> ins</span>
<span id="cb41-3"><a href="#cb41-3" aria-hidden="true" tabindex="-1"></a>   typ<span class="at">.output</span> <span class="wa">:o</span></span>
<span id="cb41-4"><a href="#cb41-4" aria-hidden="true" tabindex="-1"></a>   </span>
<span id="cb41-5"><a href="#cb41-5" aria-hidden="true" tabindex="-1"></a>   o <span class="kw">&lt;=</span> coefs<span class="at">.each_with_index.reduce</span>(_b0) <span class="cf">do</span> </span>
<span id="cb41-6"><a href="#cb41-6" aria-hidden="true" tabindex="-1"></a>   <span class="kw">|</span>sum,(coef,i)<span class="kw">|</span></span>
<span id="cb41-7"><a href="#cb41-7" aria-hidden="true" tabindex="-1"></a>      add<span class="kw">.</span>(sum, mult<span class="kw">.</span>(ins<span class="kw">[</span>i<span class="kw">]*</span>coef))</span>
<span id="cb41-8"><a href="#cb41-8" aria-hidden="true" tabindex="-1"></a>   <span class="cf">end</span></span>
<span id="cb41-9"><a href="#cb41-9" aria-hidden="true" tabindex="-1"></a><span class="cf">end</span></span></code></pre></div>
<p><strong>Note</strong>:</p>
<ul>
<li>With HDLRuby, when some code is passed as an argument, it is invoked using the <code>.()</code> operator, and not simple parenthesis-like functions.</li>
</ul>
<p>Assuming the addition with saturation is now implemented by a function named <code>add_sat</code> and a multiplication with saturation is implemented by a function named <code>mult_sat</code> (with similar arguments), a circuit implementing a signed 16-bit sum of product saturating at 1000 with 16 coefficients could be described as follows:</p>
<div class="sourceCode" id="cb42"><pre class="sourceCode ruby"><code class="sourceCode ruby"><span id="cb42-1"><a href="#cb42-1" aria-hidden="true" tabindex="-1"></a>sumprod_proc( </span>
<span id="cb42-2"><a href="#cb42-2" aria-hidden="true" tabindex="-1"></a>        <span class="fu">proc</span> <span class="kw">{</span> <span class="kw">|</span>x,y<span class="kw">|</span> add_sat(<span class="dv">1000</span>,x,y) <span class="kw">}</span>,</span>
<span id="cb42-3"><a href="#cb42-3" aria-hidden="true" tabindex="-1"></a>        <span class="fu">proc</span> <span class="kw">{</span> <span class="kw">|</span>x,y<span class="kw">|</span> mult_sat(<span class="dv">1000</span>,x,y) <span class="kw">}</span>,</span>
<span id="cb42-4"><a href="#cb42-4" aria-hidden="true" tabindex="-1"></a>        signed<span class="kw">[</span><span class="dv">64</span><span class="kw">]</span>, </span>
<span id="cb42-5"><a href="#cb42-5" aria-hidden="true" tabindex="-1"></a>        <span class="kw">[</span><span class="dv">3</span>,<span class="dv">78</span>,<span class="dv">43</span>,<span class="dv">246</span>, <span class="dv">3</span>,<span class="dv">67</span>,<span class="dv">1</span>,<span class="dv">8</span>,</span>
<span id="cb42-6"><a href="#cb42-6" aria-hidden="true" tabindex="-1"></a>         <span class="dv">47</span>,<span class="dv">82</span>,<span class="dv">99</span>,<span class="dv">13</span>, <span class="dv">5</span>,<span class="dv">77</span>,<span class="dv">2</span>,<span class="dv">4</span><span class="kw">]</span>)<span class="kw">.</span>(<span class="wa">:my_circuit</span>)</span></code></pre></div>
<p>As seen in the example above, a piece of code is passed as an argument using the proc keyword.</p>
<p>A second possible approach provided by HDLRuby is to declare a new data type with redefined addition and multiplication operators. For the case of a 16-bit saturated addition and multiplication the following generic data type can be defined (for signed computations):</p>
<pre><code>signed[16].typedef(:sat16_1000)

sat16_1000.define_operator(:+) do |x,y|
      tmp = x + y
      mux(tmp &gt; 1000,tmp,1000)
   end
end</code></pre>
<p>In the code above, the first line defines the new type <code>sat16_1000</code> to be 16-bit signed, and the remaining overloads (redefines) the <code>+</code> operator for this type (the same should be done for the <code>*</code> operator). Then, the initial version of <code>sumprod</code> can be used with this type to achieve saturated computations as follows:</p>
<div class="sourceCode" id="cb44"><pre class="sourceCode ruby"><code class="sourceCode ruby"><span id="cb44-1"><a href="#cb44-1" aria-hidden="true" tabindex="-1"></a>sumprod(sat16_1000, </span>
<span id="cb44-2"><a href="#cb44-2" aria-hidden="true" tabindex="-1"></a>        <span class="kw">[</span><span class="dv">3</span>,<span class="dv">78</span>,<span class="dv">43</span>,<span class="dv">246</span>, <span class="dv">3</span>,<span class="dv">67</span>,<span class="dv">1</span>,<span class="dv">8</span>,</span>
<span id="cb44-3"><a href="#cb44-3" aria-hidden="true" tabindex="-1"></a>        <span class="dv">47</span>,<span class="dv">82</span>,<span class="dv">99</span>,<span class="dv">13</span>, <span class="dv">5</span>,<span class="dv">77</span>,<span class="dv">2</span>,<span class="dv">4</span><span class="kw">]</span>)<span class="kw">.</span>(<span class="wa">:my_circuit</span>)</span></code></pre></div>
<p>It is also possible to declare a generic type. For instance, a generic signed type with saturation can be declared as follows:</p>
<div class="sourceCode" id="cb45"><pre class="sourceCode ruby"><code class="sourceCode ruby"><span id="cb45-1"><a href="#cb45-1" aria-hidden="true" tabindex="-1"></a>typedef <span class="wa">:sat</span> <span class="cf">do</span> <span class="kw">|</span>width, max<span class="kw">|</span></span>
<span id="cb45-2"><a href="#cb45-2" aria-hidden="true" tabindex="-1"></a>   signed<span class="kw">[</span>width<span class="kw">]</span></span>
<span id="cb45-3"><a href="#cb45-3" aria-hidden="true" tabindex="-1"></a><span class="cf">end</span></span>
<span id="cb45-4"><a href="#cb45-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-5"><a href="#cb45-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-6"><a href="#cb45-6" aria-hidden="true" tabindex="-1"></a>sat<span class="at">.define_operator</span>(:<span class="kw">+</span>) <span class="cf">do</span> <span class="kw">|</span>width,max, x,y<span class="kw">|</span></span>
<span id="cb45-7"><a href="#cb45-7" aria-hidden="true" tabindex="-1"></a>      tmp <span class="kw">=</span> x <span class="kw">+</span> y</span>
<span id="cb45-8"><a href="#cb45-8" aria-hidden="true" tabindex="-1"></a>      mux(tmp <span class="kw">&gt;</span> max, tmp, max)</span>
<span id="cb45-9"><a href="#cb45-9" aria-hidden="true" tabindex="-1"></a>   <span class="cf">end</span></span>
<span id="cb45-10"><a href="#cb45-10" aria-hidden="true" tabindex="-1"></a><span class="cf">end</span></span></code></pre></div>
<p><strong>Note:</strong></p>
<ul>
<li>The generic parameters have also to be declared for the operator redefinitions.</li>
</ul>
<p>With this generic type, the circuit can be declared as follows:</p>
<div class="sourceCode" id="cb46"><pre class="sourceCode ruby"><code class="sourceCode ruby"><span id="cb46-1"><a href="#cb46-1" aria-hidden="true" tabindex="-1"></a>sumprod(sat(<span class="dv">16</span>,<span class="dv">1000</span>), </span>
<span id="cb46-2"><a href="#cb46-2" aria-hidden="true" tabindex="-1"></a>        <span class="kw">[</span><span class="dv">3</span>,<span class="dv">78</span>,<span class="dv">43</span>,<span class="dv">246</span>, <span class="dv">3</span>,<span class="dv">67</span>,<span class="dv">1</span>,<span class="dv">8</span>,</span>
<span id="cb46-3"><a href="#cb46-3" aria-hidden="true" tabindex="-1"></a>         <span class="dv">47</span>,<span class="dv">82</span>,<span class="dv">99</span>,<span class="dv">13</span>, <span class="dv">5</span>,<span class="dv">77</span>,<span class="dv">2</span>,<span class="dv">4</span><span class="kw">]</span>)<span class="kw">.</span>(<span class="wa">:my_circuit</span>)</span></code></pre></div>
<p>Lastly note, HDLRuby is also a language with supports reflection for all its constructs. For example, the system of an instance can be accessed using the <code>systemT</code> method, and this latter can be used to create other instances. For example, previously, <code>dff_single</code> was declared with an anonymous system (i.e., it cannot be accessed by name). This system can however be used as follows to generate another instance:</p>
<div class="sourceCode" id="cb47"><pre class="sourceCode ruby"><code class="sourceCode ruby"><span id="cb47-1"><a href="#cb47-1" aria-hidden="true" tabindex="-1"></a>dff_single<span class="at">.systemT.instantiate</span>(<span class="wa">:dff_not_single</span>)</span></code></pre></div>
<p>In the above example, <code>dff_not_single</code> is declared to be an instance of the same system as <code>dff_single</code>.</p>
<p>This reflection capability can also be used for instance, for accessing the data type of a signal (<code>sig.type</code>), but also the current basic block (<code>cur_block</code>), the current process (<code>cur_behavior</code>), and so on. The standard library of HDLRuby includes several hardware constructs like finite state machine descriptors and is mainly based on using these reflection features.</p>
<h2 id="how-does-hdlruby-work">How does HDLRuby work</h2>
<p>Contrary to descriptions in high-level HDL like SystemVerilog, VHDL, or SystemC, HDLRuby descriptions are not software-like descriptions of hardware but are programs meant to produce hardware descriptions. In other words, while the execution of a common HDL code will result in some simulation of the described hardware, the execution of HDLRuby code will result in some low-level hardware description. This low-level description is synthesizable and can also be simulated like any standard hardware description. This decoupling of the representation of the hardware from the point of view of the user (HDLRuby), and the actual hardware description (HDLRuby::Low) makes it possible to provide the user with any advanced software features without jeopardizing the synthesizability of the actual hardware description.</p>
<p>For that purpose, each construct in HDLRuby is not a direct description of some hardware construct, but a program that generates the corresponding description. For example, let us consider the following line of code of HDLRuby describing the connection between signal <code>a</code> and signal <code>b</code>:</p>
<div class="sourceCode" id="cb48"><pre class="sourceCode ruby"><code class="sourceCode ruby"><span id="cb48-1"><a href="#cb48-1" aria-hidden="true" tabindex="-1"></a>   a <span class="kw">&lt;=</span> b</span></code></pre></div>
<p>Its execution will produce the actual hardware description of this connection as an object of the HDLRuby::Low library — in this case, an instance of the <code>HDLRuby::Low::Connection</code> class. Concretely, an HDLRuby system is described by a Ruby block, and the instantiation of this system is performed by executing this block. The actual synthesizable description of this hardware is the execution result of this instantiation.</p>
<p>From there, we will describe in more detail each construct of HDLRuby.</p>
<h2 id="naming-rules">Naming rules</h2>
<p><a name="names"></a></p>
<p>Several constructs in HDLRuby are referred to by name, e.g., systems and signals. When such constructs are declared, their names are to be specified by Ruby symbols starting with a lowercase. For example, <code>:hello</code> is a valid name declaration, but <code>:Hello</code> is not.</p>
<p>After being declared, the construct can be referred to by using the name directly (i.e., without the <code>:</code> of Ruby symbols). For example, if a construct has been declared with <code>:hello</code> as the name, it will be afterward referred to by <code>hello</code>.</p>
<h2 id="systems-and-signals">Systems and Signals</h2>
<p>A system represents a digital system and corresponds to a Verilog HDL module. A system has an interface comprising input, output, and inout signals, and includes structural and behavioral descriptions.</p>
<p>A signal represents a state in a system. It has a data type and a value, the latter varying with time. HDLRuby signals can be viewed as abstractions of both wires and registers in a digital circuit. As a general rule, a signal whose value is explicitly set all the time models a wire, otherwise it models a register.</p>
<h3 id="declaring-an-empty-system">Declaring an empty system</h3>
<p>A system is declared using the keyword <code>system</code>. It must be given a Ruby symbol for its name and a block that describes its content. For instance, the following code describes an empty system named <code>box</code>:</p>
<div class="sourceCode" id="cb49"><pre class="sourceCode ruby"><code class="sourceCode ruby"><span id="cb49-1"><a href="#cb49-1" aria-hidden="true" tabindex="-1"></a><span class="fu">system</span>(<span class="wa">:box</span>) <span class="kw">{}</span></span></code></pre></div>
<p><strong>Notes</strong>:</p>
<ul>
<li>Since this is Ruby code, the body can also be delimited by the <code>do</code> and <code>end</code> Ruby keywords (in which case the parentheses can be omitted) as follows:</li>
</ul>
<div class="sourceCode" id="cb50"><pre class="sourceCode ruby"><code class="sourceCode ruby"><span id="cb50-1"><a href="#cb50-1" aria-hidden="true" tabindex="-1"></a><span class="fu">system</span> <span class="wa">:box</span> does</span>
<span id="cb50-2"><a href="#cb50-2" aria-hidden="true" tabindex="-1"></a><span class="cf">end</span></span></code></pre></div>
<ul>
<li>Names in HDLRuby are natively stored as Ruby symbols, but strings can also be used, e.g., <code>system("box") {}</code> is also valid.</li>
</ul>
<h3 id="declaring-a-system-with-an-interface">Declaring a system with an interface</h3>
<p>The interface of a system can be described anywhere in its body, but it is recommended to do it at its beginning. This is done by declaring input, output, or inout signals of given data types as follows:</p>
<div class="sourceCode" id="cb51"><pre class="sourceCode ruby"><code class="sourceCode ruby"><span id="cb51-1"><a href="#cb51-1" aria-hidden="true" tabindex="-1"></a><span class="kw">&lt;</span>data type<span class="kw">&gt;.&lt;</span>direction<span class="kw">&gt;</span> <span class="kw">&lt;</span>list of colon<span class="kw">-</span>preceded names<span class="kw">&gt;</span></span></code></pre></div>
<p>For example, declaring a 1-bit input signal named <code>clk</code> can be declared as follows:</p>
<div class="sourceCode" id="cb52"><pre class="sourceCode ruby"><code class="sourceCode ruby"><span id="cb52-1"><a href="#cb52-1" aria-hidden="true" tabindex="-1"></a>bit<span class="at">.input</span> <span class="wa">:clk</span></span></code></pre></div>
<p>Now, since <code>bit</code> is the default data type in HDLRuby, it can be omitted as follows:</p>
<div class="sourceCode" id="cb53"><pre class="sourceCode ruby"><code class="sourceCode ruby"><span id="cb53-1"><a href="#cb53-1" aria-hidden="true" tabindex="-1"></a>input <span class="wa">:clk</span></span></code></pre></div>
<p>The following is a more complete example: it is the code of a system describing an 8-bit data, 16-bit address memory whose interface includes a 1-bit input clock (<code>clk</code>), a 1-bit signal for selecting reading or writing access (<code>rwb</code>), a 16-bit address input (<code>addr</code>), and an 8-bit data inout — the remaining of the code describes the content and the behavior of the memory.</p>
<div class="sourceCode" id="cb54"><pre class="sourceCode ruby"><code class="sourceCode ruby"><span id="cb54-1"><a href="#cb54-1" aria-hidden="true" tabindex="-1"></a><span class="fu">system</span> <span class="wa">:mem8_16</span> <span class="cf">do</span></span>
<span id="cb54-2"><a href="#cb54-2" aria-hidden="true" tabindex="-1"></a>    input <span class="wa">:clk</span>, <span class="wa">:rwb</span></span>
<span id="cb54-3"><a href="#cb54-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">[</span><span class="dv">15</span><span class="kw">..</span><span class="dv">0</span><span class="kw">]</span><span class="at">.input</span> <span class="wa">:addr</span></span>
<span id="cb54-4"><a href="#cb54-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">[</span><span class="dv">7</span><span class="kw">..</span><span class="dv">0</span><span class="kw">]</span><span class="at">.inout</span> <span class="wa">:data</span></span>
<span id="cb54-5"><a href="#cb54-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb54-6"><a href="#cb54-6" aria-hidden="true" tabindex="-1"></a>    bit<span class="kw">[</span><span class="dv">7</span><span class="kw">..</span><span class="dv">0</span><span class="kw">][</span><span class="dv">2</span><span class="kw">**</span><span class="dv">16</span><span class="kw">]</span><span class="at">.inner</span> <span class="wa">:content</span></span>
<span id="cb54-7"><a href="#cb54-7" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb54-8"><a href="#cb54-8" aria-hidden="true" tabindex="-1"></a>    par(clk<span class="at">.posedge</span>) <span class="cf">do</span></span>
<span id="cb54-9"><a href="#cb54-9" aria-hidden="true" tabindex="-1"></a>        hif(rwb) <span class="kw">{</span> data <span class="kw">&lt;=</span> content<span class="kw">[</span>addr<span class="kw">]</span> <span class="kw">}</span></span>
<span id="cb54-10"><a href="#cb54-10" aria-hidden="true" tabindex="-1"></a>        helse    <span class="kw">{</span> content<span class="kw">[</span>addr<span class="kw">]</span> <span class="kw">&lt;=</span> data <span class="kw">}</span></span>
<span id="cb54-11"><a href="#cb54-11" aria-hidden="true" tabindex="-1"></a>    <span class="cf">end</span></span>
<span id="cb54-12"><a href="#cb54-12" aria-hidden="true" tabindex="-1"></a><span class="cf">end</span></span></code></pre></div>
<h3 id="structural-description-in-a-system">Structural description in a system</h3>
<p>In a system, structural descriptions consist of subsystems and interconnections among them.</p>
<p>A subsystem is obtained by instantiating an existing system as follows, where <code>&lt;system name&gt;</code> is the name of the system to instantiate (without any colon):</p>
<div class="sourceCode" id="cb55"><pre class="sourceCode ruby"><code class="sourceCode ruby"><span id="cb55-1"><a href="#cb55-1" aria-hidden="true" tabindex="-1"></a><span class="kw">&lt;</span><span class="fu">system</span> name<span class="kw">&gt;</span> :<span class="kw">&lt;</span>instance name<span class="kw">&gt;</span></span></code></pre></div>
<p>For example, system <code>mem8_16</code> declared in the previous section can be instantiated as follows:</p>
<div class="sourceCode" id="cb56"><pre class="sourceCode ruby"><code class="sourceCode ruby"><span id="cb56-1"><a href="#cb56-1" aria-hidden="true" tabindex="-1"></a>mem8_16 <span class="wa">:mem8_16I</span></span></code></pre></div>
<p>It is also possible to declare multiple instances of the same system at a time as follows:</p>
<div class="sourceCode" id="cb57"><pre class="sourceCode ruby"><code class="sourceCode ruby"><span id="cb57-1"><a href="#cb57-1" aria-hidden="true" tabindex="-1"></a><span class="kw">&lt;</span><span class="fu">system</span> name<span class="kw">&gt;</span> <span class="kw">[</span>list of colon<span class="kw">-</span>separated instance names<span class="kw">]</span></span></code></pre></div>
<p>For example, the following code declares two instances of system <code>mem8_16</code>:</p>
<div class="sourceCode" id="cb58"><pre class="sourceCode ruby"><code class="sourceCode ruby"><span id="cb58-1"><a href="#cb58-1" aria-hidden="true" tabindex="-1"></a>mem8_16 <span class="kw">[</span> <span class="wa">:mem8_16I0</span>, <span class="wa">:mem8_16I1</span> <span class="kw">]</span></span></code></pre></div>
<p>Interconnecting instances may require internal signals in the system. Such signals are declared using the <code>inner</code> direction. For example, the following code declares a 1-bit inner signal named <code>w1</code> and a 2-bit inner signal named <code>w2</code>:</p>
<div class="sourceCode" id="cb59"><pre class="sourceCode ruby"><code class="sourceCode ruby"><span id="cb59-1"><a href="#cb59-1" aria-hidden="true" tabindex="-1"></a>inner <span class="wa">:w1</span></span>
<span id="cb59-2"><a href="#cb59-2" aria-hidden="true" tabindex="-1"></a><span class="kw">[</span><span class="dv">1</span><span class="kw">..</span><span class="dv">0</span><span class="kw">]</span><span class="at">.inner</span> <span class="wa">:w2</span></span></code></pre></div>
<p>If the signal is not meant to be changed, it can be declared using the <code>constant</code> keyword instead of <code>inner</code>.</p>
<p>A connection between signals is done using the arrow operator <code>&lt;=</code> as follows:</p>
<div class="sourceCode" id="cb60"><pre class="sourceCode ruby"><code class="sourceCode ruby"><span id="cb60-1"><a href="#cb60-1" aria-hidden="true" tabindex="-1"></a><span class="kw">&lt;</span>destination<span class="kw">&gt;</span> <span class="kw">&lt;=</span> <span class="kw">&lt;</span>source<span class="kw">&gt;</span></span></code></pre></div>
<p>The <code>&lt;destination&gt;</code> must be a reference to a signal, and the <code>&lt;source&gt;</code> can be any expression.</p>
<p>For example, the following code connects signal <code>w1</code> to signal <code>ready</code> and signal <code>clk</code> to the first bit of signal <code>w2</code>:</p>
<div class="sourceCode" id="cb61"><pre class="sourceCode ruby"><code class="sourceCode ruby"><span id="cb61-1"><a href="#cb61-1" aria-hidden="true" tabindex="-1"></a>ready <span class="kw">&lt;=</span> w1</span>
<span id="cb61-2"><a href="#cb61-2" aria-hidden="true" tabindex="-1"></a>w2<span class="kw">[</span><span class="dv">0</span><span class="kw">]</span> <span class="kw">&lt;=</span> clk</span></code></pre></div>
<p>As another example, the following code connects to the second bit of <code>w2</code> the output of an AND operation between <code>clk</code> and <code>rst</code> as follows:</p>
<div class="sourceCode" id="cb62"><pre class="sourceCode ruby"><code class="sourceCode ruby"><span id="cb62-1"><a href="#cb62-1" aria-hidden="true" tabindex="-1"></a>w2<span class="kw">[</span><span class="dv">1</span><span class="kw">]</span> <span class="kw">&lt;=</span> clk <span class="kw">&amp;</span> rst</span></code></pre></div>
<p>The signals of an instance can be connected through the arrow operator too, provided they are properly referred to. One way to refer to them is to use the dot operator <code>.</code> on the instance as follows:</p>
<div class="sourceCode" id="cb63"><pre class="sourceCode ruby"><code class="sourceCode ruby"><span id="cb63-1"><a href="#cb63-1" aria-hidden="true" tabindex="-1"></a><span class="kw">&lt;</span>instance name<span class="kw">&gt;.&lt;</span>signal name<span class="kw">&gt;</span></span></code></pre></div>
<p>For example, the following code connects signal <code>clk</code> of instance <code>mem8_16I</code> to signal <code>clk</code> of the current system:</p>
<div class="sourceCode" id="cb64"><pre class="sourceCode ruby"><code class="sourceCode ruby"><span id="cb64-1"><a href="#cb64-1" aria-hidden="true" tabindex="-1"></a>mem8_16I<span class="at">.clk</span> <span class="kw">&lt;=</span> clk</span></code></pre></div>
<p>It is also possible to connect multiple signals of an instance using the call operator <code>.()</code> as follows, where each target can be any expression:</p>
<div class="sourceCode" id="cb65"><pre class="sourceCode ruby"><code class="sourceCode ruby"><span id="cb65-1"><a href="#cb65-1" aria-hidden="true" tabindex="-1"></a><span class="kw">&lt;</span>instance name<span class="kw">&gt;.</span>(<span class="kw">&lt;</span>signal name0<span class="kw">&gt;</span>: <span class="kw">&lt;</span>target0<span class="kw">&gt;</span>, <span class="kw">...</span>)</span></code></pre></div>
<p>For example, the following code connects signals <code>clk</code> and <code>rst</code> of instance <code>mem8_16I</code> to signals <code>clk</code> and <code>rst</code> of the current system. As seen in this example, this method allows partial connection since the address and the data buses are not connected yet.</p>
<div class="sourceCode" id="cb66"><pre class="sourceCode ruby"><code class="sourceCode ruby"><span id="cb66-1"><a href="#cb66-1" aria-hidden="true" tabindex="-1"></a>mem8_16I<span class="kw">.</span>(<span class="wa">clk: </span>clk, <span class="wa">rst: </span>rst)</span></code></pre></div>
<p>This last connection method can be used directly while declaring an instance. For example, <code>mem8_16I</code> could have been declared and connected to <code>clk</code> and <code>rst</code> as follows:</p>
<div class="sourceCode" id="cb67"><pre class="sourceCode ruby"><code class="sourceCode ruby"><span id="cb67-1"><a href="#cb67-1" aria-hidden="true" tabindex="-1"></a>mem8_16(<span class="wa">:mem8_16I</span>)<span class="kw">.</span>(<span class="wa">clk: </span>clk, <span class="wa">rst: </span>rest)</span></code></pre></div>
<p>To summarize this section, here is a structural description of a 16-bit memory made of two 8-bit memories (or equivalent) sharing the same address bus, and using respectively the lower and the higher 8-bits of the data bus:</p>
<div class="sourceCode" id="cb68"><pre class="sourceCode ruby"><code class="sourceCode ruby"><span id="cb68-1"><a href="#cb68-1" aria-hidden="true" tabindex="-1"></a><span class="fu">system</span> <span class="wa">:mem16_16</span> <span class="cf">do</span></span>
<span id="cb68-2"><a href="#cb68-2" aria-hidden="true" tabindex="-1"></a>   input <span class="wa">:clk</span>, <span class="wa">:rwb</span></span>
<span id="cb68-3"><a href="#cb68-3" aria-hidden="true" tabindex="-1"></a>   <span class="kw">[</span><span class="dv">15</span><span class="kw">..</span><span class="dv">0</span><span class="kw">]</span><span class="at">.input</span> <span class="wa">:addr</span></span>
<span id="cb68-4"><a href="#cb68-4" aria-hidden="true" tabindex="-1"></a>   <span class="kw">[</span><span class="dv">15</span><span class="kw">..</span><span class="dv">0</span><span class="kw">]</span><span class="at">.inout</span> <span class="wa">:data</span></span>
<span id="cb68-5"><a href="#cb68-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb68-6"><a href="#cb68-6" aria-hidden="true" tabindex="-1"></a>   mem8_16(<span class="wa">:memL</span>)<span class="kw">.</span>(<span class="wa">clk: </span>clk, <span class="wa">rwb: </span>rwb, <span class="wa">addr: </span>addr, <span class="wa">data: </span>data<span class="kw">[</span><span class="dv">7</span><span class="kw">..</span><span class="dv">0</span><span class="kw">]</span>)</span>
<span id="cb68-7"><a href="#cb68-7" aria-hidden="true" tabindex="-1"></a>   mem8_16(<span class="wa">:memH</span>)<span class="kw">.</span>(<span class="wa">clk: </span>clk, <span class="wa">rwb: </span>rwb, <span class="wa">addr: </span>addr, <span class="wa">data: </span>data<span class="kw">[</span><span class="dv">15</span><span class="kw">..</span><span class="dv">8</span><span class="kw">]</span>)</span>
<span id="cb68-8"><a href="#cb68-8" aria-hidden="true" tabindex="-1"></a><span class="cf">end</span></span></code></pre></div>
<p>And here is an equivalent code using the arrow operator:</p>
<div class="sourceCode" id="cb69"><pre class="sourceCode ruby"><code class="sourceCode ruby"><span id="cb69-1"><a href="#cb69-1" aria-hidden="true" tabindex="-1"></a><span class="fu">system</span> <span class="wa">:mem16_16</span> <span class="cf">do</span></span>
<span id="cb69-2"><a href="#cb69-2" aria-hidden="true" tabindex="-1"></a>   input <span class="wa">:clk</span>, <span class="wa">:rwb</span></span>
<span id="cb69-3"><a href="#cb69-3" aria-hidden="true" tabindex="-1"></a>   <span class="kw">[</span><span class="dv">15</span><span class="kw">..</span><span class="dv">0</span><span class="kw">]</span><span class="at">.input</span> <span class="wa">:addr</span></span>
<span id="cb69-4"><a href="#cb69-4" aria-hidden="true" tabindex="-1"></a>   <span class="kw">[</span><span class="dv">15</span><span class="kw">..</span><span class="dv">0</span><span class="kw">]</span><span class="at">.inout</span> <span class="wa">:data</span></span>
<span id="cb69-5"><a href="#cb69-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb69-6"><a href="#cb69-6" aria-hidden="true" tabindex="-1"></a>   mem8_16 <span class="kw">[</span><span class="wa">:memL</span>, <span class="wa">:memH</span><span class="kw">]</span></span>
<span id="cb69-7"><a href="#cb69-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb69-8"><a href="#cb69-8" aria-hidden="true" tabindex="-1"></a>   memL<span class="at">.clk</span>  <span class="kw">&lt;=</span> clk</span>
<span id="cb69-9"><a href="#cb69-9" aria-hidden="true" tabindex="-1"></a>   memL<span class="at">.rwb</span>  <span class="kw">&lt;=</span> rwb</span>
<span id="cb69-10"><a href="#cb69-10" aria-hidden="true" tabindex="-1"></a>   memL<span class="at">.addr</span> <span class="kw">&lt;=</span> addr</span>
<span id="cb69-11"><a href="#cb69-11" aria-hidden="true" tabindex="-1"></a>   memL<span class="at">.data</span> <span class="kw">&lt;=</span> data<span class="kw">[</span><span class="dv">7</span><span class="kw">..</span><span class="dv">0</span><span class="kw">]</span></span>
<span id="cb69-12"><a href="#cb69-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb69-13"><a href="#cb69-13" aria-hidden="true" tabindex="-1"></a>   memH<span class="at">.clk</span>  <span class="kw">&lt;=</span> clk</span>
<span id="cb69-14"><a href="#cb69-14" aria-hidden="true" tabindex="-1"></a>   memH<span class="at">.rwb</span>  <span class="kw">&lt;=</span> rwb</span>
<span id="cb69-15"><a href="#cb69-15" aria-hidden="true" tabindex="-1"></a>   memH<span class="at">.addr</span> <span class="kw">&lt;=</span> addr</span>
<span id="cb69-16"><a href="#cb69-16" aria-hidden="true" tabindex="-1"></a>   memH<span class="at">.data</span> <span class="kw">&lt;=</span> data<span class="kw">[</span><span class="dv">15</span><span class="kw">..</span><span class="dv">8</span><span class="kw">]</span></span>
<span id="cb69-17"><a href="#cb69-17" aria-hidden="true" tabindex="-1"></a><span class="cf">end</span></span></code></pre></div>
<h3 id="initialization-of-signals">Initialization of signals</h3>
<p><a name="initialization"></a></p>
<p>Output, inner, and constant signals of a system can be initialized when declared using the following syntax in place of the usual name of the signal:</p>
<div class="sourceCode" id="cb70"><pre class="sourceCode ruby"><code class="sourceCode ruby"><span id="cb70-1"><a href="#cb70-1" aria-hidden="true" tabindex="-1"></a><span class="kw">&lt;</span>signal name<span class="kw">&gt;</span>: <span class="kw">&lt;</span>intial value<span class="kw">&gt;</span></span></code></pre></div>
<p>For example, a single-bit inner signal named <code>sig</code> can be initialized to 0 as follows:</p>
<div class="sourceCode" id="cb71"><pre class="sourceCode ruby"><code class="sourceCode ruby"><span id="cb71-1"><a href="#cb71-1" aria-hidden="true" tabindex="-1"></a>inner <span class="wa">sig: </span><span class="dv">0</span></span></code></pre></div>
<p>As another example, an 8-bit 8-word ROM could be declared and initialized as follows:</p>
<div class="sourceCode" id="cb72"><pre class="sourceCode ruby"><code class="sourceCode ruby"><span id="cb72-1"><a href="#cb72-1" aria-hidden="true" tabindex="-1"></a>bit<span class="kw">[</span><span class="dv">8</span><span class="kw">][-</span><span class="dv">8</span><span class="kw">]</span> <span class="wa">rom: </span><span class="kw">[</span> <span class="dv">0</span>,<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">5</span>,<span class="dv">6</span>,<span class="dv">7</span> <span class="kw">]</span></span></code></pre></div>
<h3 id="scope-in-a-system">Scope in a system</h3>
<h4 id="general-scopes">General scopes</h4>
<p>The signals of the interface of signals are accessible from anywhere in an HDLRuby description. This is not the case for inner signals and instances: they are accessible only within the scope they are declared in.</p>
<p>A scope is a region of the code where locally declared objects are accessible. Each system has its scope that cannot be accessible from another part of an HDLRuby description. For example, in the following code signals <code>d</code> and <code>qb</code> as well as instance <code>dffI</code> cannot be accessed from outside system <code>div2</code>:</p>
<div class="sourceCode" id="cb73"><pre class="sourceCode ruby"><code class="sourceCode ruby"><span id="cb73-1"><a href="#cb73-1" aria-hidden="true" tabindex="-1"></a><span class="fu">system</span> <span class="wa">:div2</span> <span class="cf">do</span></span>
<span id="cb73-2"><a href="#cb73-2" aria-hidden="true" tabindex="-1"></a>   input <span class="wa">:clk</span></span>
<span id="cb73-3"><a href="#cb73-3" aria-hidden="true" tabindex="-1"></a>   output <span class="wa">:q</span></span>
<span id="cb73-4"><a href="#cb73-4" aria-hidden="true" tabindex="-1"></a>   </span>
<span id="cb73-5"><a href="#cb73-5" aria-hidden="true" tabindex="-1"></a>   inner <span class="wa">:d</span>, <span class="wa">:qb</span></span>
<span id="cb73-6"><a href="#cb73-6" aria-hidden="true" tabindex="-1"></a>   d <span class="kw">&lt;=</span> qb</span>
<span id="cb73-7"><a href="#cb73-7" aria-hidden="true" tabindex="-1"></a>   </span>
<span id="cb73-8"><a href="#cb73-8" aria-hidden="true" tabindex="-1"></a>   dff_full(<span class="wa">:dffI</span>)<span class="kw">.</span>(<span class="wa">clk: </span>clk, <span class="wa">d: </span>d, <span class="wa">q: </span>q, <span class="wa">qb: </span>qb)</span>
<span id="cb73-9"><a href="#cb73-9" aria-hidden="true" tabindex="-1"></a>   </span></code></pre></div>
<p>For robustness or, readability purposes, it is possible to add an inner scope inside the existing scope using the <code>sub</code> keyword as follows:</p>
<div class="sourceCode" id="cb74"><pre class="sourceCode ruby"><code class="sourceCode ruby"><span id="cb74-1"><a href="#cb74-1" aria-hidden="true" tabindex="-1"></a><span class="fu">sub</span> <span class="cf">do</span></span>
<span id="cb74-2"><a href="#cb74-2" aria-hidden="true" tabindex="-1"></a>   <span class="kw">&lt;</span>code<span class="kw">&gt;</span></span>
<span id="cb74-3"><a href="#cb74-3" aria-hidden="true" tabindex="-1"></a><span class="cf">end</span></span></code></pre></div>
<p>For example, in the code below signal <code>sig</code> is not accessible from outside the additional inner scope of system <code>sys</code></p>
<div class="sourceCode" id="cb75"><pre class="sourceCode ruby"><code class="sourceCode ruby"><span id="cb75-1"><a href="#cb75-1" aria-hidden="true" tabindex="-1"></a><span class="fu">system</span> <span class="wa">:sys</span> <span class="cf">do</span></span>
<span id="cb75-2"><a href="#cb75-2" aria-hidden="true" tabindex="-1"></a>   <span class="kw">...</span></span>
<span id="cb75-3"><a href="#cb75-3" aria-hidden="true" tabindex="-1"></a>   <span class="fu">sub</span></span>
<span id="cb75-4"><a href="#cb75-4" aria-hidden="true" tabindex="-1"></a>      inner <span class="wa">:sig</span></span>
<span id="cb75-5"><a href="#cb75-5" aria-hidden="true" tabindex="-1"></a>      <span class="kw">&lt;</span>sig is accessible here<span class="kw">&gt;</span></span>
<span id="cb75-6"><a href="#cb75-6" aria-hidden="true" tabindex="-1"></a>   <span class="cf">end</span></span>
<span id="cb75-7"><a href="#cb75-7" aria-hidden="true" tabindex="-1"></a>   <span class="kw">&lt;</span>sig is <span class="cf">not</span> accessible from here<span class="kw">&gt;</span></span>
<span id="cb75-8"><a href="#cb75-8" aria-hidden="true" tabindex="-1"></a><span class="cf">end</span></span></code></pre></div>
<p>It is also possible to add an inner scope within another inner scope as follows:</p>
<div class="sourceCode" id="cb76"><pre class="sourceCode ruby"><code class="sourceCode ruby"><span id="cb76-1"><a href="#cb76-1" aria-hidden="true" tabindex="-1"></a><span class="fu">system</span> <span class="wa">:sys</span> <span class="cf">do</span></span>
<span id="cb76-2"><a href="#cb76-2" aria-hidden="true" tabindex="-1"></a>   <span class="kw">...</span></span>
<span id="cb76-3"><a href="#cb76-3" aria-hidden="true" tabindex="-1"></a>   <span class="fu">sub</span></span>
<span id="cb76-4"><a href="#cb76-4" aria-hidden="true" tabindex="-1"></a>      inner <span class="wa">:sig0</span></span>
<span id="cb76-5"><a href="#cb76-5" aria-hidden="true" tabindex="-1"></a>      <span class="kw">&lt;</span>sig0 is accessible here<span class="kw">&gt;</span></span>
<span id="cb76-6"><a href="#cb76-6" aria-hidden="true" tabindex="-1"></a>      <span class="fu">sub</span></span>
<span id="cb76-7"><a href="#cb76-7" aria-hidden="true" tabindex="-1"></a>         inner <span class="wa">:sig1</span></span>
<span id="cb76-8"><a href="#cb76-8" aria-hidden="true" tabindex="-1"></a>         <span class="kw">&lt;</span>sig0 <span class="cf">and</span> sig1 are accessible here<span class="kw">&gt;</span></span>
<span id="cb76-9"><a href="#cb76-9" aria-hidden="true" tabindex="-1"></a>      <span class="cf">end</span></span>
<span id="cb76-10"><a href="#cb76-10" aria-hidden="true" tabindex="-1"></a>      <span class="kw">&lt;</span>sig1 is <span class="cf">not</span> accessible here<span class="kw">&gt;</span></span>
<span id="cb76-11"><a href="#cb76-11" aria-hidden="true" tabindex="-1"></a>   <span class="cf">end</span></span>
<span id="cb76-12"><a href="#cb76-12" aria-hidden="true" tabindex="-1"></a>   <span class="kw">&lt;</span>neither sig0 nor sig1 are accessible here<span class="kw">&gt;</span></span>
<span id="cb76-13"><a href="#cb76-13" aria-hidden="true" tabindex="-1"></a><span class="cf">end</span></span></code></pre></div>
<p>Within the same scope, it is not possible to declare multiple signals or instances with the same name. However, it is possible to declare a signal or an instance with a name identical to one previously declared outside the scope: the inner-most declaration will be used.</p>
<h4 id="named-scopes">Named scopes</h4>
<p>It is possible to declare a scope with a name as follows:</p>
<div class="sourceCode" id="cb77"><pre class="sourceCode ruby"><code class="sourceCode ruby"><span id="cb77-1"><a href="#cb77-1" aria-hidden="true" tabindex="-1"></a><span class="fu">sub</span> :<span class="kw">&lt;</span>name<span class="kw">&gt;</span> <span class="cf">do</span></span>
<span id="cb77-2"><a href="#cb77-2" aria-hidden="true" tabindex="-1"></a>   <span class="kw">&lt;</span>code<span class="kw">&gt;</span></span>
<span id="cb77-3"><a href="#cb77-3" aria-hidden="true" tabindex="-1"></a><span class="cf">end</span></span></code></pre></div>
<p>Where:</p>
<ul>
<li><code>&lt;name&gt;</code> is the name of the scope.</li>
<li><code>&lt;code&gt;</code> is the code within the scope.</li>
</ul>
<p>Contrary to the case of scopes without a name, signals, and instances declared within a named scope can be accessed outside using this name as a reference. For example, in the code below signal <code>sig</code> declared within scope named <code>scop</code> is accessed outside it using <code>scop.sig</code>:</p>
<div class="sourceCode" id="cb78"><pre class="sourceCode ruby"><code class="sourceCode ruby"><span id="cb78-1"><a href="#cb78-1" aria-hidden="true" tabindex="-1"></a><span class="fu">sub</span> <span class="wa">:scop</span> <span class="cf">do</span></span>
<span id="cb78-2"><a href="#cb78-2" aria-hidden="true" tabindex="-1"></a>   inner <span class="wa">:sig</span></span>
<span id="cb78-3"><a href="#cb78-3" aria-hidden="true" tabindex="-1"></a>   <span class="kw">...</span></span>
<span id="cb78-4"><a href="#cb78-4" aria-hidden="true" tabindex="-1"></a><span class="cf">end</span></span>
<span id="cb78-5"><a href="#cb78-5" aria-hidden="true" tabindex="-1"></a><span class="kw">...</span></span>
<span id="cb78-6"><a href="#cb78-6" aria-hidden="true" tabindex="-1"></a>scop<span class="at">.sig</span> <span class="kw">&lt;=</span> <span class="kw">...</span></span></code></pre></div>
<h3 id="behavioral-description-in-a-system.">Behavioral description in a system.</h3>
<p>In a system, parallel behavioral descriptions are declared using the <code>par</code> keyword, and sequential behavioral descriptions are declared using the <code>seq</code> keyword. They are the equivalent of the Verilog HDL <code>always</code> blocks.</p>
<p>A behavior is made of a list of events (the sensitivity list) upon which it is activated, and a list of statements. A behavior is declared as follows:</p>
<div class="sourceCode" id="cb79"><pre class="sourceCode ruby"><code class="sourceCode ruby"><span id="cb79-1"><a href="#cb79-1" aria-hidden="true" tabindex="-1"></a>par <span class="kw">&lt;</span>list of events<span class="kw">&gt;</span> <span class="cf">do</span></span>
<span id="cb79-2"><a href="#cb79-2" aria-hidden="true" tabindex="-1"></a>   <span class="kw">&lt;</span>list of statements<span class="kw">&gt;</span></span>
<span id="cb79-3"><a href="#cb79-3" aria-hidden="true" tabindex="-1"></a><span class="cf">end</span></span></code></pre></div>
<p>In addition, it is possible to declare inner signals within an execution block. While such signals will be physically linked to the system, they are only accessible within the block they are declared into. This permits a tighter scope for signals, which improves the readability of the code and makes it possible to declare several signals with identical names provided their respective scopes are different.</p>
<p>An event represents a specific change in the state of a signal. For example, a rising edge of a clock signal named <code>clk</code> will be represented by the event <code>clk.posedge</code>. In HDLRuby, events are obtained directly from expressions using the following methods: <code>posedge</code> for a rising edge, <code>negedge</code> for a falling edge, and <code>edge</code> for any edge. Events are described in more detail in section <a href="#events">Events</a>.</p>
<p>When one of the events of the sensitivity list of a behavior occurs, the behavior is executed, i.e., each of its statements is executed in sequence. A statement can represent a data transmission to a signal, a control flow, a nested execution block, or the declaration of an inner signal (as stated earlier). Statements are described in more detail in section <a href="#statements">statements</a>. In this section, we focus on the transmission statements and the block statements.</p>
<p>A transmission statement is declared using the arrow operator <code>&lt;=</code> as follows:</p>
<div class="sourceCode" id="cb80"><pre class="sourceCode ruby"><code class="sourceCode ruby"><span id="cb80-1"><a href="#cb80-1" aria-hidden="true" tabindex="-1"></a><span class="kw">&lt;</span>destination<span class="kw">&gt;</span> <span class="kw">&lt;=</span> <span class="kw">&lt;</span>source<span class="kw">&gt;</span></span></code></pre></div>
<p>The <code>&lt;destination&gt;</code> must be a reference to a signal, and the <code>&lt;source&gt;</code> can be any expression. A transmission has therefore the same structure as a connection. However, its execution model is different: whereas a connection is continuously executed, a transmission is only executed during the execution of its block.</p>
<p>A block comprises a list of statements. It is used for adding hierarchy to a behavior. Blocks can be either parallel or sequential, i.e., their transmission statements are respectively non-blocking or blocking. By default, a top block is created when declaring a behavior, and it inherits from its execution mode. For example, with the following code, the top block of the behavior is sequential.</p>
<div class="sourceCode" id="cb81"><pre class="sourceCode ruby"><code class="sourceCode ruby"><span id="cb81-1"><a href="#cb81-1" aria-hidden="true" tabindex="-1"></a><span class="fu">system</span> <span class="wa">:with_sequential_behavior</span> <span class="cf">do</span></span>
<span id="cb81-2"><a href="#cb81-2" aria-hidden="true" tabindex="-1"></a>   seq <span class="cf">do</span></span>
<span id="cb81-3"><a href="#cb81-3" aria-hidden="true" tabindex="-1"></a>      <span class="kw">&lt;</span>list of statements<span class="kw">&gt;</span></span>
<span id="cb81-4"><a href="#cb81-4" aria-hidden="true" tabindex="-1"></a>   <span class="cf">end</span></span>
<span id="cb81-5"><a href="#cb81-5" aria-hidden="true" tabindex="-1"></a><span class="cf">end</span></span></code></pre></div>
<p>It is possible to declare new blocks within an existing block. For declaring a sub-block with the same execution mode as the upper one, the keyword <code>sub</code> is used. For example, the following code declares a sub-block within a sequential block, with the same execution mode:</p>
<div class="sourceCode" id="cb82"><pre class="sourceCode ruby"><code class="sourceCode ruby"><span id="cb82-1"><a href="#cb82-1" aria-hidden="true" tabindex="-1"></a><span class="fu">system</span> <span class="wa">:with_sequential_behavior</span> <span class="cf">do</span></span>
<span id="cb82-2"><a href="#cb82-2" aria-hidden="true" tabindex="-1"></a>   seq <span class="cf">do</span></span>
<span id="cb82-3"><a href="#cb82-3" aria-hidden="true" tabindex="-1"></a>      <span class="kw">&lt;</span>list of statements<span class="kw">&gt;</span></span>
<span id="cb82-4"><a href="#cb82-4" aria-hidden="true" tabindex="-1"></a>      <span class="fu">sub</span> <span class="cf">do</span></span>
<span id="cb82-5"><a href="#cb82-5" aria-hidden="true" tabindex="-1"></a>         <span class="kw">&lt;</span>list of statements<span class="kw">&gt;</span></span>
<span id="cb82-6"><a href="#cb82-6" aria-hidden="true" tabindex="-1"></a>      <span class="cf">end</span></span>
<span id="cb82-7"><a href="#cb82-7" aria-hidden="true" tabindex="-1"></a>   <span class="cf">end</span></span>
<span id="cb82-8"><a href="#cb82-8" aria-hidden="true" tabindex="-1"></a><span class="cf">end</span></span></code></pre></div>
<p>A sub-block can also have a different execution mode if it is declared using <code>seq</code>, which will force sequential execution mode, and <code>par</code> which will force parallel execution mode. For example, in the following code a parallel sub-block is declared within a sequential one:</p>
<div class="sourceCode" id="cb83"><pre class="sourceCode ruby"><code class="sourceCode ruby"><span id="cb83-1"><a href="#cb83-1" aria-hidden="true" tabindex="-1"></a><span class="fu">system</span> <span class="wa">:with_sequential_behavior</span> <span class="cf">do</span></span>
<span id="cb83-2"><a href="#cb83-2" aria-hidden="true" tabindex="-1"></a>   seq <span class="cf">do</span></span>
<span id="cb83-3"><a href="#cb83-3" aria-hidden="true" tabindex="-1"></a>      <span class="kw">&lt;</span>list of statements<span class="kw">&gt;</span></span>
<span id="cb83-4"><a href="#cb83-4" aria-hidden="true" tabindex="-1"></a>      par <span class="cf">do</span></span>
<span id="cb83-5"><a href="#cb83-5" aria-hidden="true" tabindex="-1"></a>         <span class="kw">&lt;</span>list of statements<span class="kw">&gt;</span></span>
<span id="cb83-6"><a href="#cb83-6" aria-hidden="true" tabindex="-1"></a>      <span class="cf">end</span></span>
<span id="cb83-7"><a href="#cb83-7" aria-hidden="true" tabindex="-1"></a>   <span class="cf">end</span></span>
<span id="cb83-8"><a href="#cb83-8" aria-hidden="true" tabindex="-1"></a><span class="cf">end</span></span></code></pre></div>
<p>Sunblocks have their scope so that it is possible to declare signals without colliding with existing ones. For example, it is possible to declare three different inner signals all called <code>sig</code> as follows:</p>
<div class="sourceCode" id="cb84"><pre class="sourceCode ruby"><code class="sourceCode ruby"><span id="cb84-1"><a href="#cb84-1" aria-hidden="true" tabindex="-1"></a><span class="kw">...</span></span>
<span id="cb84-2"><a href="#cb84-2" aria-hidden="true" tabindex="-1"></a>par(<span class="kw">&lt;</span>sensibility list<span class="kw">&gt;</span>) <span class="cf">do</span></span>
<span id="cb84-3"><a href="#cb84-3" aria-hidden="true" tabindex="-1"></a>   inner <span class="wa">:sig</span></span>
<span id="cb84-4"><a href="#cb84-4" aria-hidden="true" tabindex="-1"></a>   <span class="kw">...</span></span>
<span id="cb84-5"><a href="#cb84-5" aria-hidden="true" tabindex="-1"></a>   <span class="fu">sub</span> <span class="cf">do</span></span>
<span id="cb84-6"><a href="#cb84-6" aria-hidden="true" tabindex="-1"></a>      inner <span class="wa">:sig</span></span>
<span id="cb84-7"><a href="#cb84-7" aria-hidden="true" tabindex="-1"></a>      <span class="kw">...</span></span>
<span id="cb84-8"><a href="#cb84-8" aria-hidden="true" tabindex="-1"></a>      <span class="fu">sub</span> <span class="cf">do</span></span>
<span id="cb84-9"><a href="#cb84-9" aria-hidden="true" tabindex="-1"></a>         inner <span class="wa">:sig</span></span>
<span id="cb84-10"><a href="#cb84-10" aria-hidden="true" tabindex="-1"></a>         <span class="kw">...</span></span>
<span id="cb84-11"><a href="#cb84-11" aria-hidden="true" tabindex="-1"></a>      <span class="cf">end</span></span>
<span id="cb84-12"><a href="#cb84-12" aria-hidden="true" tabindex="-1"></a>   <span class="cf">end</span></span>
<span id="cb84-13"><a href="#cb84-13" aria-hidden="true" tabindex="-1"></a>   <span class="kw">...</span></span>
<span id="cb84-14"><a href="#cb84-14" aria-hidden="true" tabindex="-1"></a><span class="cf">end</span></span></code></pre></div>
<p>To summarize this section, here is a behavioral description of a 16-bit shift register with asynchronous reset (<code>hif</code> and <code>helse</code> are keywords used for specifying hardware <em>if</em> and <em>else</em> control statements).</p>
<div class="sourceCode" id="cb85"><pre class="sourceCode ruby"><code class="sourceCode ruby"><span id="cb85-1"><a href="#cb85-1" aria-hidden="true" tabindex="-1"></a><span class="fu">system</span> <span class="wa">:shift16</span> <span class="cf">do</span></span>
<span id="cb85-2"><a href="#cb85-2" aria-hidden="true" tabindex="-1"></a>   input <span class="wa">:clk</span>, <span class="wa">:rst</span>, <span class="wa">:din</span></span>
<span id="cb85-3"><a href="#cb85-3" aria-hidden="true" tabindex="-1"></a>   output <span class="wa">:dout</span></span>
<span id="cb85-4"><a href="#cb85-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb85-5"><a href="#cb85-5" aria-hidden="true" tabindex="-1"></a>   <span class="kw">[</span><span class="dv">15</span><span class="kw">..</span><span class="dv">0</span><span class="kw">]</span><span class="at">.inner</span> <span class="wa">:reg</span></span>
<span id="cb85-6"><a href="#cb85-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb85-7"><a href="#cb85-7" aria-hidden="true" tabindex="-1"></a>   dout <span class="kw">&lt;=</span> reg<span class="kw">[</span><span class="dv">15</span><span class="kw">]</span> <span class="co"># The output is the last bit of the register.</span></span>
<span id="cb85-8"><a href="#cb85-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb85-9"><a href="#cb85-9" aria-hidden="true" tabindex="-1"></a>   par(clk<span class="at">.posedge</span>) <span class="cf">do</span></span>
<span id="cb85-10"><a href="#cb85-10" aria-hidden="true" tabindex="-1"></a>      hif(rst) <span class="kw">{</span> reg <span class="kw">&lt;=</span> <span class="dv">0</span> <span class="kw">}</span></span>
<span id="cb85-11"><a href="#cb85-11" aria-hidden="true" tabindex="-1"></a>      helse <span class="cf">do</span></span>
<span id="cb85-12"><a href="#cb85-12" aria-hidden="true" tabindex="-1"></a>         reg<span class="kw">[</span><span class="dv">0</span><span class="kw">]</span> <span class="kw">&lt;=</span> din</span>
<span id="cb85-13"><a href="#cb85-13" aria-hidden="true" tabindex="-1"></a>         reg<span class="kw">[</span><span class="dv">15</span><span class="kw">..</span><span class="dv">1</span><span class="kw">]</span> <span class="kw">&lt;=</span> reg<span class="kw">[</span><span class="dv">14</span><span class="kw">..</span><span class="dv">0</span><span class="kw">]</span></span>
<span id="cb85-14"><a href="#cb85-14" aria-hidden="true" tabindex="-1"></a>      <span class="cf">end</span></span>
<span id="cb85-15"><a href="#cb85-15" aria-hidden="true" tabindex="-1"></a>   <span class="cf">end</span></span>
<span id="cb85-16"><a href="#cb85-16" aria-hidden="true" tabindex="-1"></a><span class="cf">end</span></span></code></pre></div>
<p>In the example above, the order of the transmission statements is of no consequence. This is not the case for the following example, which implements the same register using a sequential block. In this second example, putting the statement <code>reg[0] &lt;= din</code> in the last place would have led to an invalid functionality for a shift register.</p>
<div class="sourceCode" id="cb86"><pre class="sourceCode ruby"><code class="sourceCode ruby"><span id="cb86-1"><a href="#cb86-1" aria-hidden="true" tabindex="-1"></a><span class="fu">system</span> <span class="wa">:shift16</span> <span class="cf">do</span></span>
<span id="cb86-2"><a href="#cb86-2" aria-hidden="true" tabindex="-1"></a>   input <span class="wa">:clk</span>, <span class="wa">:rst</span>, <span class="wa">:din</span></span>
<span id="cb86-3"><a href="#cb86-3" aria-hidden="true" tabindex="-1"></a>   output <span class="wa">:dout</span></span>
<span id="cb86-4"><a href="#cb86-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb86-5"><a href="#cb86-5" aria-hidden="true" tabindex="-1"></a>   <span class="kw">[</span><span class="dv">15</span><span class="kw">..</span><span class="dv">0</span><span class="kw">]</span><span class="at">.inner</span> <span class="wa">:reg</span></span>
<span id="cb86-6"><a href="#cb86-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb86-7"><a href="#cb86-7" aria-hidden="true" tabindex="-1"></a>   dout <span class="kw">&lt;=</span> reg<span class="kw">[</span><span class="dv">15</span><span class="kw">]</span> <span class="co"># The output is the last bit of the register.</span></span>
<span id="cb86-8"><a href="#cb86-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb86-9"><a href="#cb86-9" aria-hidden="true" tabindex="-1"></a>   par(clk<span class="at">.posedge</span>) <span class="cf">do</span></span>
<span id="cb86-10"><a href="#cb86-10" aria-hidden="true" tabindex="-1"></a>      hif(rst) <span class="kw">{</span> reg <span class="kw">&lt;=</span> <span class="dv">0</span> <span class="kw">}</span></span>
<span id="cb86-11"><a href="#cb86-11" aria-hidden="true" tabindex="-1"></a>      helse seq <span class="cf">do</span></span>
<span id="cb86-12"><a href="#cb86-12" aria-hidden="true" tabindex="-1"></a>         reg<span class="kw">[</span><span class="dv">0</span><span class="kw">]</span> <span class="kw">&lt;=</span> din</span>
<span id="cb86-13"><a href="#cb86-13" aria-hidden="true" tabindex="-1"></a>         reg <span class="kw">&lt;=</span> reg<span class="kw">[</span><span class="dv">14</span><span class="kw">..</span><span class="dv">0</span><span class="kw">]</span></span>
<span id="cb86-14"><a href="#cb86-14" aria-hidden="true" tabindex="-1"></a>      <span class="cf">end</span></span>
<span id="cb86-15"><a href="#cb86-15" aria-hidden="true" tabindex="-1"></a>   <span class="cf">end</span></span>
<span id="cb86-16"><a href="#cb86-16" aria-hidden="true" tabindex="-1"></a><span class="cf">end</span></span></code></pre></div>
<p><strong>Note</strong>:</p>
<ul>
<li><p><code>helse seq</code> ensures that the block of the hardware else is in sequential mode.</p></li>
<li><p><code>hif(rst)</code> could also have been set to sequential mode as follows:</p>
<div class="sourceCode" id="cb87"><pre class="sourceCode ruby"><code class="sourceCode ruby"><span id="cb87-1"><a href="#cb87-1" aria-hidden="true" tabindex="-1"></a>   hif rst, seq <span class="cf">do</span></span>
<span id="cb87-2"><a href="#cb87-2" aria-hidden="true" tabindex="-1"></a>      reg <span class="kw">&lt;=</span> <span class="dv">0</span></span>
<span id="cb87-3"><a href="#cb87-3" aria-hidden="true" tabindex="-1"></a>   <span class="cf">end</span></span></code></pre></div></li>
<li><p>Parallel mode can be set the same way using <code>par</code>.</p></li>
</ul>
<h3 id="extra-features-for-the-description-of-behaviors">Extra features for the description of behaviors</h3>
<h4 id="single-statement-behaviors">Single-statement behaviors</h4>
<p>It often happens that a behavior contains only one statement. In such a case, the description can be shortened using the <code>at</code> operator as follows:</p>
<div class="sourceCode" id="cb88"><pre class="sourceCode ruby"><code class="sourceCode ruby"><span id="cb88-1"><a href="#cb88-1" aria-hidden="true" tabindex="-1"></a>( statement )<span class="at">.at</span>(<span class="kw">&lt;</span>list of events<span class="kw">&gt;</span>)</span></code></pre></div>
<p>For example, the following two code samples are equivalent:</p>
<div class="sourceCode" id="cb89"><pre class="sourceCode ruby"><code class="sourceCode ruby"><span id="cb89-1"><a href="#cb89-1" aria-hidden="true" tabindex="-1"></a>par(clk<span class="at">.posedge</span>) <span class="cf">do</span></span>
<span id="cb89-2"><a href="#cb89-2" aria-hidden="true" tabindex="-1"></a>   a <span class="kw">&lt;=</span> b<span class="kw">+</span><span class="dv">1</span></span>
<span id="cb89-3"><a href="#cb89-3" aria-hidden="true" tabindex="-1"></a><span class="cf">end</span></span></code></pre></div>
<div class="sourceCode" id="cb90"><pre class="sourceCode ruby"><code class="sourceCode ruby"><span id="cb90-1"><a href="#cb90-1" aria-hidden="true" tabindex="-1"></a>( a <span class="kw">&lt;=</span> b<span class="kw">+</span><span class="dv">1</span> )<span class="at">.at</span>(clk<span class="at">.posedge</span>)</span></code></pre></div>
<p>For the sake of consistency, this operator can also be applied to block statements as follows, but it is probably less readable than the standard declaration of behaviors:</p>
<div class="sourceCode" id="cb91"><pre class="sourceCode ruby"><code class="sourceCode ruby"><span id="cb91-1"><a href="#cb91-1" aria-hidden="true" tabindex="-1"></a>( seq <span class="cf">do</span></span>
<span id="cb91-2"><a href="#cb91-2" aria-hidden="true" tabindex="-1"></a>     a <span class="kw">&lt;=</span> b<span class="kw">+</span><span class="dv">1</span></span>
<span id="cb91-3"><a href="#cb91-3" aria-hidden="true" tabindex="-1"></a>     c <span class="kw">&lt;=</span> d<span class="kw">+</span><span class="dv">2</span></span>
<span id="cb91-4"><a href="#cb91-4" aria-hidden="true" tabindex="-1"></a>  <span class="cf">end</span> )<span class="at">.at</span>(clk<span class="at">.posedge</span>)</span></code></pre></div>
<h4 id="insertion-of-statements-at-the-beginning-of-a-block">Insertion of statements at the beginning of a block</h4>
<p>By default, the statements of a block are added in order of appearance in the code. However, it is also possible to insert statements at the top of the current block using the unshift command within a block as follows:</p>
<div class="sourceCode" id="cb92"><pre class="sourceCode ruby"><code class="sourceCode ruby"><span id="cb92-1"><a href="#cb92-1" aria-hidden="true" tabindex="-1"></a>unshift <span class="cf">do</span></span>
<span id="cb92-2"><a href="#cb92-2" aria-hidden="true" tabindex="-1"></a>   <span class="kw">&lt;</span>list of statements<span class="kw">&gt;</span></span>
<span id="cb92-3"><a href="#cb92-3" aria-hidden="true" tabindex="-1"></a><span class="cf">end</span></span></code></pre></div>
<p>For example, the following code inserts two statements at the beginning of the current block:</p>
<div class="sourceCode" id="cb93"><pre class="sourceCode ruby"><code class="sourceCode ruby"><span id="cb93-1"><a href="#cb93-1" aria-hidden="true" tabindex="-1"></a>par <span class="cf">do</span></span>
<span id="cb93-2"><a href="#cb93-2" aria-hidden="true" tabindex="-1"></a>   x <span class="kw">&lt;=</span> y <span class="kw">+</span> z</span>
<span id="cb93-3"><a href="#cb93-3" aria-hidden="true" tabindex="-1"></a>   unshift <span class="cf">do</span></span>
<span id="cb93-4"><a href="#cb93-4" aria-hidden="true" tabindex="-1"></a>      a <span class="kw">&lt;=</span> b <span class="kw">-</span> c</span>
<span id="cb93-5"><a href="#cb93-5" aria-hidden="true" tabindex="-1"></a>      u <span class="kw">&lt;=</span> v <span class="kw">&amp;</span> w</span>
<span id="cb93-6"><a href="#cb93-6" aria-hidden="true" tabindex="-1"></a>    <span class="cf">end</span></span>
<span id="cb93-7"><a href="#cb93-7" aria-hidden="true" tabindex="-1"></a><span class="cf">end</span></span></code></pre></div>
<p>The code above will result in the following block:</p>
<div class="sourceCode" id="cb94"><pre class="sourceCode ruby"><code class="sourceCode ruby"><span id="cb94-1"><a href="#cb94-1" aria-hidden="true" tabindex="-1"></a>par <span class="cf">do</span></span>
<span id="cb94-2"><a href="#cb94-2" aria-hidden="true" tabindex="-1"></a>   a <span class="kw">&lt;=</span> b <span class="kw">-</span> c</span>
<span id="cb94-3"><a href="#cb94-3" aria-hidden="true" tabindex="-1"></a>   u <span class="kw">&lt;=</span> v <span class="kw">&amp;</span> w</span>
<span id="cb94-4"><a href="#cb94-4" aria-hidden="true" tabindex="-1"></a>   x <span class="kw">&lt;=</span> y <span class="kw">+</span> z</span>
<span id="cb94-5"><a href="#cb94-5" aria-hidden="true" tabindex="-1"></a><span class="cf">end</span></span></code></pre></div>
<p><strong>Note</strong>: - While of no practical use for simple circuit descriptions, this feature can be used in advanced generic component descriptions.</p>
<h3 id="reconfiguration">Reconfiguration</h3>
<p>In HDLRuby, dynamically reconfigurable devices are modeled by instances having more than one system. Adding systems to an instance is done as follows:</p>
<div class="sourceCode" id="cb95"><pre class="sourceCode ruby"><code class="sourceCode ruby"><span id="cb95-1"><a href="#cb95-1" aria-hidden="true" tabindex="-1"></a><span class="kw">&lt;</span>instance<span class="kw">&gt;</span><span class="at">.choice</span>(<span class="kw">&lt;</span>list of named systems<span class="kw">&gt;</span>)</span></code></pre></div>
<p>For example, assuming systems <code>sys0</code>, <code>sys1</code>, and <code>sys2</code> have been previously declared a device named <code>dev012</code> able to be reconfigured to one of these three systems would be declared as follows (the connections of the instance, omitted in the example, can be done as usual):</p>
<div class="sourceCode" id="cb96"><pre class="sourceCode ruby"><code class="sourceCode ruby"><span id="cb96-1"><a href="#cb96-1" aria-hidden="true" tabindex="-1"></a>sys0 <span class="wa">:dev012</span> <span class="co"># dev012 is at first a standard instance of sys0</span></span>
<span id="cb96-2"><a href="#cb96-2" aria-hidden="true" tabindex="-1"></a>dev012<span class="at">.choice</span>(<span class="wa">conf1: </span>sys1, <span class="wa">conf2: </span>sys2) <span class="co"># Now dev012 is reconfigurable</span></span></code></pre></div>
<p>After the code above, instance <code>dev012</code> can be dynamically reconfigured to <code>sys0</code>, <code>sys1</code>, and <code>sys2</code> with respective names <code>dev012</code>, <code>conf1</code>, and <code>conf2</code>.</p>
<p><strong>Note:</strong> The name of the initial system in the reconfigurations is set to be the name of the instance.</p>
<p>A reconfigurable instance can then be reconfigured using the command <code>configure</code> as follows:</p>
<div class="sourceCode" id="cb97"><pre class="sourceCode ruby"><code class="sourceCode ruby"><span id="cb97-1"><a href="#cb97-1" aria-hidden="true" tabindex="-1"></a><span class="kw">&lt;</span>instance<span class="kw">&gt;</span><span class="at">.configure</span>(<span class="kw">&lt;</span>name <span class="cf">or</span> index<span class="kw">&gt;</span>)</span></code></pre></div>
<p>In the code above, the argument of <code>configure</code> can either be the name of the configuration as previously declared with <code>choice</code>, or its index in order of declaration. For example in the following code, instance <code>dev012</code> is reconfigured to system <code>sys1</code>, then system <code>sys0</code> the system <code>sys2</code>:</p>
<div class="sourceCode" id="cb98"><pre class="sourceCode ruby"><code class="sourceCode ruby"><span id="cb98-1"><a href="#cb98-1" aria-hidden="true" tabindex="-1"></a>dev012<span class="at">.configure</span>(<span class="wa">:conf1</span>)</span>
<span id="cb98-2"><a href="#cb98-2" aria-hidden="true" tabindex="-1"></a>!<span class="dv">1000</span><span class="at">.ns</span></span>
<span id="cb98-3"><a href="#cb98-3" aria-hidden="true" tabindex="-1"></a>dev012<span class="at">.configure</span>(<span class="wa">:dev012</span>)</span>
<span id="cb98-4"><a href="#cb98-4" aria-hidden="true" tabindex="-1"></a>!<span class="dv">1000</span><span class="at">.ns</span></span>
<span id="cb98-5"><a href="#cb98-5" aria-hidden="true" tabindex="-1"></a>dev012<span class="at">.configure</span>(<span class="dv">2</span>)</span></code></pre></div>
<p>These reconfiguration commands are treated as regular RTL statements in HDLRuby and are supported by the simulator. However, in the current version of the HDLRuby, these statements are ignored when generating Verilog HDL or VHDL code.</p>
<h2 id="events">Events</h2>
<p>Each behavior of a system is associated with a list of events, called a sensitivity list, that specifies when the behavior is to be executed. An event is associated with a signal and represents the instant when the signal reaches a given state.</p>
<p>There are three kinds of events: positive edge events represent the instants when their corresponding signals vary from 0 to 1, and negative edge events represent the instants when their corresponding signals vary from 1 to 0 and the change events represent the instants when their corresponding signals vary. Events are declared directly from the signals, using the <code>posedge</code> operator for a positive edge, the <code>negedge</code> operator for a negative edge, and the <code>change</code> operator for change. For example, the following code declares 3 behaviors activated respectively on the positive edge, the negative edge, and any change of the <code>clk</code> signal.</p>
<div class="sourceCode" id="cb99"><pre class="sourceCode ruby"><code class="sourceCode ruby"><span id="cb99-1"><a href="#cb99-1" aria-hidden="true" tabindex="-1"></a>inner <span class="wa">:clk</span></span>
<span id="cb99-2"><a href="#cb99-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb99-3"><a href="#cb99-3" aria-hidden="true" tabindex="-1"></a>par(clk<span class="at">.posedge</span>) <span class="cf">do</span></span>
<span id="cb99-4"><a href="#cb99-4" aria-hidden="true" tabindex="-1"></a><span class="kw">...</span></span>
<span id="cb99-5"><a href="#cb99-5" aria-hidden="true" tabindex="-1"></a><span class="cf">end</span></span>
<span id="cb99-6"><a href="#cb99-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb99-7"><a href="#cb99-7" aria-hidden="true" tabindex="-1"></a>par(clk<span class="at">.negedge</span>) <span class="cf">do</span></span>
<span id="cb99-8"><a href="#cb99-8" aria-hidden="true" tabindex="-1"></a><span class="kw">...</span></span>
<span id="cb99-9"><a href="#cb99-9" aria-hidden="true" tabindex="-1"></a><span class="cf">end</span></span>
<span id="cb99-10"><a href="#cb99-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb99-11"><a href="#cb99-11" aria-hidden="true" tabindex="-1"></a>par(clk<span class="at">.change</span>) <span class="cf">do</span></span>
<span id="cb99-12"><a href="#cb99-12" aria-hidden="true" tabindex="-1"></a><span class="kw">...</span></span>
<span id="cb99-13"><a href="#cb99-13" aria-hidden="true" tabindex="-1"></a><span class="cf">end</span></span></code></pre></div>
<p><strong>Note:</strong> - The <code>change</code> keyword can be omitted.</p>
<h2 id="statements">Statements</h2>
<p>Statements are the basic elements of a behavioral description. They are regrouped in blocks that specify their execution mode (parallel or sequential). There are four kinds of statements: the transmit statement which computes expressions and sends the result to the target signals, the control statement which changes the execution flow of the behavior, the block statement (described earlier), and the inner signal declaration.</p>
<p><strong>Note</strong>:</p>
<ul>
<li>There is a fifth type of statement, named the time statement, that will be discussed in section <a href="#time">Time</a>.</li>
</ul>
<h3 id="transmit-statement">Transmit statement</h3>
<p>A transmit statement is declared using the arrow operator <code>&lt;=</code> within a behavior. Its right value is the expression to compute and its left value is a reference to the target signals (or parts of signals), i.e., the signals (or parts of signals) that receive the computation result.</p>
<p>For example, the following code transmits the value <code>3</code> to signal <code>s0</code> and the sum of the values of signals <code>i0</code> and <code>i1</code> to the first four bits of signal <code>s1</code>:</p>
<div class="sourceCode" id="cb100"><pre class="sourceCode ruby"><code class="sourceCode ruby"><span id="cb100-1"><a href="#cb100-1" aria-hidden="true" tabindex="-1"></a>s0 <span class="kw">&lt;=</span> <span class="dv">3</span></span>
<span id="cb100-2"><a href="#cb100-2" aria-hidden="true" tabindex="-1"></a>s1<span class="kw">[</span><span class="dv">3</span><span class="kw">..</span><span class="dv">0</span><span class="kw">]</span> <span class="kw">&lt;=</span> i0 <span class="kw">+</span> i1</span></code></pre></div>
<p>The behavior of a transmit statement depends on the execution mode of the enclosing block:</p>
<ul>
<li>If the mode is parallel, the target signals are updated when all the statements of the current block are processed.</li>
<li>If the mode is sequential, the target signals are updated immediately after the right value of the statement is computed.</li>
</ul>
<h3 id="control-statements">Control statements</h3>
<p>There are only two possible control statements: the hardware if <code>hif</code> and the hardware case <code>hcase</code>.</p>
<h4 id="hif">hif</h4>
<p>The <code>hif</code> construct is made of a condition and a block that is executed if and only if the condition is met. It is declared as follows, where the condition can be any expression:</p>
<div class="sourceCode" id="cb101"><pre class="sourceCode ruby"><code class="sourceCode ruby"><span id="cb101-1"><a href="#cb101-1" aria-hidden="true" tabindex="-1"></a>hif <span class="kw">&lt;</span>condition<span class="kw">&gt;</span> <span class="cf">do</span></span>
<span id="cb101-2"><a href="#cb101-2" aria-hidden="true" tabindex="-1"></a>   <span class="kw">&lt;</span>block contents<span class="kw">&gt;</span></span>
<span id="cb101-3"><a href="#cb101-3" aria-hidden="true" tabindex="-1"></a><span class="cf">end</span></span></code></pre></div>
<h4 id="hcase">hcase</h4>
<p>The <code>hcase</code> construct is made of an expression and a list of value-block pairs. A block is executed when the corresponding value is equal to the value of the expression of the <code>hcase</code>. This construct is declared as follows:</p>
<div class="sourceCode" id="cb102"><pre class="sourceCode ruby"><code class="sourceCode ruby"><span id="cb102-1"><a href="#cb102-1" aria-hidden="true" tabindex="-1"></a>hcase <span class="kw">&lt;</span>expression<span class="kw">&gt;</span></span>
<span id="cb102-2"><a href="#cb102-2" aria-hidden="true" tabindex="-1"></a>hwhen <span class="kw">&lt;</span>value <span class="dv">0</span><span class="kw">&gt;</span> <span class="cf">do</span></span>
<span id="cb102-3"><a href="#cb102-3" aria-hidden="true" tabindex="-1"></a>   <span class="kw">&lt;</span>block contents <span class="dv">0</span><span class="kw">&gt;</span></span>
<span id="cb102-4"><a href="#cb102-4" aria-hidden="true" tabindex="-1"></a><span class="cf">end</span></span>
<span id="cb102-5"><a href="#cb102-5" aria-hidden="true" tabindex="-1"></a>hwhen <span class="kw">&lt;</span>value <span class="dv">1</span><span class="kw">&gt;</span> <span class="cf">do</span></span>
<span id="cb102-6"><a href="#cb102-6" aria-hidden="true" tabindex="-1"></a>   <span class="kw">&lt;</span>block contents <span class="dv">1</span><span class="kw">&gt;</span></span>
<span id="cb102-7"><a href="#cb102-7" aria-hidden="true" tabindex="-1"></a><span class="cf">end</span></span>
<span id="cb102-8"><a href="#cb102-8" aria-hidden="true" tabindex="-1"></a><span class="kw">...</span></span></code></pre></div>
<h4 id="helse">helse</h4>
<p>It is possible to add a block that is executed when the condition of an <code>hif</code> is not met, or when no case matches the expression of a <code>hcase</code>, using the <code>helse</code> keyword as follows:</p>
<div class="sourceCode" id="cb103"><pre class="sourceCode ruby"><code class="sourceCode ruby"><span id="cb103-1"><a href="#cb103-1" aria-hidden="true" tabindex="-1"></a><span class="kw">&lt;</span>hif <span class="cf">or</span> hcase construct<span class="kw">&gt;</span></span>
<span id="cb103-2"><a href="#cb103-2" aria-hidden="true" tabindex="-1"></a>helse <span class="cf">do</span></span>
<span id="cb103-3"><a href="#cb103-3" aria-hidden="true" tabindex="-1"></a>   <span class="kw">&lt;</span>block contents<span class="kw">&gt;</span></span>
<span id="cb103-4"><a href="#cb103-4" aria-hidden="true" tabindex="-1"></a><span class="cf">end</span></span></code></pre></div>
<h3 id="helsif">helsif</h3>
<p>In addition to <code>helse</code>, it is possible to set additional conditions to an <code>hif</code> using the <code>helsif</code> keyword as follows:</p>
<div class="sourceCode" id="cb104"><pre class="sourceCode ruby"><code class="sourceCode ruby"><span id="cb104-1"><a href="#cb104-1" aria-hidden="true" tabindex="-1"></a>hif <span class="kw">&lt;</span>condition <span class="dv">0</span><span class="kw">&gt;</span> <span class="cf">do</span></span>
<span id="cb104-2"><a href="#cb104-2" aria-hidden="true" tabindex="-1"></a>   <span class="kw">&lt;</span>block contents <span class="dv">0</span><span class="kw">&gt;</span></span>
<span id="cb104-3"><a href="#cb104-3" aria-hidden="true" tabindex="-1"></a><span class="cf">end</span></span>
<span id="cb104-4"><a href="#cb104-4" aria-hidden="true" tabindex="-1"></a>helsif <span class="kw">&lt;</span>condition <span class="dv">1</span><span class="kw">&gt;</span> <span class="cf">do</span></span>
<span id="cb104-5"><a href="#cb104-5" aria-hidden="true" tabindex="-1"></a>   <span class="kw">&lt;</span>block contents <span class="dv">1</span><span class="kw">&gt;</span></span>
<span id="cb104-6"><a href="#cb104-6" aria-hidden="true" tabindex="-1"></a><span class="cf">end</span></span>
<span id="cb104-7"><a href="#cb104-7" aria-hidden="true" tabindex="-1"></a><span class="kw">...</span></span></code></pre></div>
<h4 id="about-loops">About loops</h4>
<p>HDLRuby does not include any hardware construct for describing loops. This might look poor compared to the other HDL, but it is important to understand that the current synthesis tools do not synthesize hardware from such loops but instead preprocess them (e.g., unroll them) to synthesizable loopless hardware. In HDLRuby, such features are natively supported by the Ruby loop constructs (<code>for</code>, <code>while</code>, and so on), but also by advanced Ruby constructs like the enumerators (<code>each</code>, <code>times</code>, and so on).</p>
<p><strong>Notes</strong>:</p>
<ul>
<li><p>HDLRuby being based on Ruby, it is highly recommended to avoid <code>for</code> or <code>while</code> constructs and to use enumerators instead.</p></li>
<li><p>The Ruby <code>if</code> and <code>case</code> statements can also be used, but they do not represent any hardware. They are executed when the corresponding system is instantiated. For example, the following code will display <code>Hello world!</code> when the described system is instantiated, provided the generic parameter <code>param</code> is not nil.</p>
<div class="sourceCode" id="cb105"><pre class="sourceCode ruby"><code class="sourceCode ruby"><span id="cb105-1"><a href="#cb105-1" aria-hidden="true" tabindex="-1"></a><span class="fu">system</span> <span class="wa">:say_hello</span> <span class="cf">do</span> <span class="kw">|</span>param <span class="kw">=</span> <span class="dv">nil</span><span class="kw">|</span></span>
<span id="cb105-2"><a href="#cb105-2" aria-hidden="true" tabindex="-1"></a>   <span class="cf">if</span> param !<span class="kw">=</span> <span class="dv">nil</span> <span class="cf">then</span></span>
<span id="cb105-3"><a href="#cb105-3" aria-hidden="true" tabindex="-1"></a>      <span class="fu">puts</span> <span class="st">&quot;Hello world!&quot;</span></span>
<span id="cb105-4"><a href="#cb105-4" aria-hidden="true" tabindex="-1"></a>   <span class="cf">end</span></span>
<span id="cb105-5"><a href="#cb105-5" aria-hidden="true" tabindex="-1"></a><span class="cf">end</span></span></code></pre></div></li>
</ul>
<h2 id="types">Types</h2>
<p><a name="types"></a></p>
<p>Each signal and each expression is associated with a data type that describes the kind of value it can represent. In HDLRuby, the data types represent bit-vectors associated with the way they should be interpreted, i.e., as bit strings, unsigned values, signed values, or hierarchical contents.</p>
<h3 id="type-construction">Type Construction</h3>
<p>There are five basic types, <code>bit</code>, <code>signed</code>, <code>unsigned</code>, <code>integer</code>, and <code>float</code> that represent respectively single bit logical values, single-bit unsigned values, single-bit signed values, Ruby integer values, and Ruby floating-point values (double precision). The first three types are HW and support four-valued logic, whereas the two last ones are SW (but are compatible with HW) and only support Boolean logic. Ruby integers can represent any element of <strong>Z</strong> (the mathematical integers) and have for that purpose a variable bit-width.</p>
<p>The other types are built from them using a combination of the two following type operators.</p>
<p><strong>The vector operator</strong> <code>[]</code> is used for building types representing vectors of single or multiple other types. A vector whose elements have all the same type is declared as follows:</p>
<div class="sourceCode" id="cb106"><pre class="sourceCode ruby"><code class="sourceCode ruby"><span id="cb106-1"><a href="#cb106-1" aria-hidden="true" tabindex="-1"></a><span class="kw">&lt;</span>type<span class="kw">&gt;[&lt;</span>range<span class="kw">&gt;]</span></span></code></pre></div>
<p>The <code>&lt;range&gt;</code> of a vector type indicates the position of the starting and ending bits. An <code>n..0</code> range can also be abbreviated to <code>n+1</code>. For instance, the two following types are identical:</p>
<div class="sourceCode" id="cb107"><pre class="sourceCode ruby"><code class="sourceCode ruby"><span id="cb107-1"><a href="#cb107-1" aria-hidden="true" tabindex="-1"></a>bit<span class="kw">[</span><span class="dv">7</span><span class="kw">..</span><span class="dv">0</span><span class="kw">]</span></span>
<span id="cb107-2"><a href="#cb107-2" aria-hidden="true" tabindex="-1"></a>bit<span class="kw">[</span><span class="dv">8</span><span class="kw">]</span></span></code></pre></div>
<p>A vector of multiple types, also called a tuple, is declared as follows:</p>
<div class="sourceCode" id="cb108"><pre class="sourceCode ruby"><code class="sourceCode ruby"><span id="cb108-1"><a href="#cb108-1" aria-hidden="true" tabindex="-1"></a><span class="kw">[&lt;</span>type <span class="dv">0</span><span class="kw">&gt;</span>, <span class="kw">&lt;</span>type <span class="dv">1</span><span class="kw">&gt;</span>, <span class="kw">...</span> <span class="kw">]</span></span></code></pre></div>
<p>For example, the following code declares the type of the vectors made of an 8-bit logical, a 16-bit signed, and a 16-bit unsigned values:</p>
<div class="sourceCode" id="cb109"><pre class="sourceCode ruby"><code class="sourceCode ruby"><span id="cb109-1"><a href="#cb109-1" aria-hidden="true" tabindex="-1"></a><span class="kw">[</span> bit<span class="kw">[</span><span class="dv">8</span><span class="kw">]</span>, signed<span class="kw">[</span><span class="dv">16</span><span class="kw">]</span>, unsigned<span class="kw">[</span><span class="dv">16</span><span class="kw">]</span> <span class="kw">]</span></span></code></pre></div>
<p><strong>The structure operator</strong> <code>{}</code> is used for building hierarchical types made of named subtypes. This operator is used as follows:</p>
<div class="sourceCode" id="cb110"><pre class="sourceCode ruby"><code class="sourceCode ruby"><span id="cb110-1"><a href="#cb110-1" aria-hidden="true" tabindex="-1"></a><span class="kw">{</span> <span class="kw">&lt;</span>name <span class="dv">0</span><span class="kw">&gt;</span>: <span class="kw">&lt;</span>type <span class="dv">0</span><span class="kw">&gt;</span>, <span class="kw">&lt;</span>name <span class="dv">1</span><span class="kw">&gt;</span>: <span class="kw">&lt;</span>type <span class="dv">1</span><span class="kw">&gt;</span>, <span class="kw">...</span> <span class="kw">}</span></span></code></pre></div>
<p>For instance, the following code declares a hierarchical type with an 8-bit subtype named <code>header</code> and a 24-bit subtype named <code>data</code>:</p>
<div class="sourceCode" id="cb111"><pre class="sourceCode ruby"><code class="sourceCode ruby"><span id="cb111-1"><a href="#cb111-1" aria-hidden="true" tabindex="-1"></a><span class="kw">{</span> <span class="wa">header: </span>bit<span class="kw">[</span><span class="dv">7</span><span class="kw">..</span><span class="dv">0</span><span class="kw">]</span>, <span class="wa">data: </span>bit<span class="kw">[</span><span class="dv">23</span><span class="kw">..</span><span class="dv">0</span><span class="kw">]</span> <span class="kw">}</span></span></code></pre></div>
<h3 id="type-definition">Type definition</h3>
<p>It is possible to give names to type constructs using the <code>typedef</code> keywords as follows:</p>
<div class="sourceCode" id="cb112"><pre class="sourceCode ruby"><code class="sourceCode ruby"><span id="cb112-1"><a href="#cb112-1" aria-hidden="true" tabindex="-1"></a><span class="kw">&lt;</span>type construct<span class="kw">&gt;</span><span class="at">.typedef</span> :<span class="kw">&lt;</span>name<span class="kw">&gt;</span></span></code></pre></div>
<p>For example, the following gives the name <code>char</code> to a signed 8-bit vector:</p>
<div class="sourceCode" id="cb113"><pre class="sourceCode ruby"><code class="sourceCode ruby"><span id="cb113-1"><a href="#cb113-1" aria-hidden="true" tabindex="-1"></a>signed<span class="kw">[</span><span class="dv">7</span><span class="kw">..</span><span class="dv">0</span><span class="kw">]</span><span class="at">.typedef</span> <span class="wa">:char</span></span></code></pre></div>
<p>After this statement, <code>char</code> can be used like any other type. For example, the following code sample declares a new input signal <code>sig</code> whose type is <code>char</code>:</p>
<div class="sourceCode" id="cb114"><pre class="sourceCode ruby"><code class="sourceCode ruby"><span id="cb114-1"><a href="#cb114-1" aria-hidden="true" tabindex="-1"></a>char<span class="at">.input</span> <span class="wa">:sig</span></span></code></pre></div>
<p>Alternatively, a new type can also be defined using the following syntax:</p>
<div class="sourceCode" id="cb115"><pre class="sourceCode ruby"><code class="sourceCode ruby"><span id="cb115-1"><a href="#cb115-1" aria-hidden="true" tabindex="-1"></a>typedef :<span class="kw">&lt;</span>type name<span class="kw">&gt;</span> <span class="cf">do</span></span>
<span id="cb115-2"><a href="#cb115-2" aria-hidden="true" tabindex="-1"></a>   <span class="kw">&lt;</span>code<span class="kw">&gt;</span></span>
<span id="cb115-3"><a href="#cb115-3" aria-hidden="true" tabindex="-1"></a><span class="cf">end</span></span></code></pre></div>
<p>Where:</p>
<ul>
<li><code>type name</code> is the name of the type</li>
<li><code>code</code> is a description of the content of the type</li>
</ul>
<p>For example, the previous <code>char</code> could have been declared as follows:</p>
<div class="sourceCode" id="cb116"><pre class="sourceCode ruby"><code class="sourceCode ruby"><span id="cb116-1"><a href="#cb116-1" aria-hidden="true" tabindex="-1"></a>typedef <span class="wa">:char</span> <span class="cf">do</span></span>
<span id="cb116-2"><a href="#cb116-2" aria-hidden="true" tabindex="-1"></a>   signed<span class="kw">[</span><span class="dv">7</span><span class="kw">..</span><span class="dv">0</span><span class="kw">]</span></span>
<span id="cb116-3"><a href="#cb116-3" aria-hidden="true" tabindex="-1"></a><span class="cf">end</span> </span></code></pre></div>
<h3 id="type-compatibility-and-conversion">Type compatibility and conversion</h3>
<p>The basis of all the types in HDLRuby is the vector of bits (bit vector) where each bit can have four values: 0, 1, Z, and X (for undefined). Bit vectors are by default unsigned but can be set to be signed. When performing computations between signals of different bit-vector types, the shorter signal is extended to the size of the larger one preserving its sign if it is signed.</p>
<p>While the underlying structure of any HDLRuby type is the bit vector, complex types can be defined. When using such types in computational expressions and assignments they are first implicitly converted to an unsigned bit vector of the same size.</p>
<h2 id="expressions">Expressions</h2>
<p><a name="expressions"></a></p>
<p>Expressions are any construct that represents a value associated with a type. They include <a href="#immediate-values">immediate values</a>, <a href="#references">reference to signals</a> and operations among other expressions using <a href="#expression-operators">expression operators</a>.</p>
<h3 id="immediate-values">Immediate values</h3>
<p>The immediate values of HDLRuby can represent vectors of <code>bit</code>, <code>unsigned</code>, and <code>signed</code>, and integer or floating-point numbers. They are prefixed by a <code>_</code> character and include a header that indicates the vector type and the base used for representing the value, followed by a numeral representing the value. The bit width of a value is obtained by default from the width of the numeral, but it is also possible to specify it in the header. In addition, the character <code>_</code> can be put anywhere in the number to increase the readability, but it will be ignored.</p>
<p>The vector type specifiers are the following:</p>
<ul>
<li><p><code>b</code>: <code>bit</code> type, can be omitted,</p></li>
<li><p><code>u</code>: <code>unsigned</code> type, (equivalent to <code>b</code> and can be used for avoiding confusion with the binary specifier),</p></li>
<li><p><code>s</code>: <code>signed</code> type, the last figure is sign-extended if required by the binary, octal, and hexadecimal bases, but not for the decimal base.</p></li>
</ul>
<p>The base specifiers are the following:</p>
<ul>
<li><p><code>b</code>: binary,</p></li>
<li><p><code>o</code>: octal,</p></li>
<li><p><code>d</code>: decimal,</p></li>
<li><p><code>h</code>: hexadecimal.</p></li>
</ul>
<p>For example, all the following immediate values represent an 8-bit <code>hundred</code> (either in unsigned or signed representation):</p>
<div class="sourceCode" id="cb117"><pre class="sourceCode ruby"><code class="sourceCode ruby"><span id="cb117-1"><a href="#cb117-1" aria-hidden="true" tabindex="-1"></a>_bb01100100</span>
<span id="cb117-2"><a href="#cb117-2" aria-hidden="true" tabindex="-1"></a>_b8b110_0100</span>
<span id="cb117-3"><a href="#cb117-3" aria-hidden="true" tabindex="-1"></a>_b01100100</span>
<span id="cb117-4"><a href="#cb117-4" aria-hidden="true" tabindex="-1"></a>_u8d100</span>
<span id="cb117-5"><a href="#cb117-5" aria-hidden="true" tabindex="-1"></a>_s8d100</span>
<span id="cb117-6"><a href="#cb117-6" aria-hidden="true" tabindex="-1"></a>_uh64</span>
<span id="cb117-7"><a href="#cb117-7" aria-hidden="true" tabindex="-1"></a>_s8o144</span></code></pre></div>
<p>Finally, it is possible to omit either the type specifier, the default being unsigned bit, or the base specifier, the default being binary. For example, all the following immediate values represent an 8-bit unsigned <code>hundred</code>:</p>
<div class="sourceCode" id="cb118"><pre class="sourceCode ruby"><code class="sourceCode ruby"><span id="cb118-1"><a href="#cb118-1" aria-hidden="true" tabindex="-1"></a>_b01100100</span>
<span id="cb118-2"><a href="#cb118-2" aria-hidden="true" tabindex="-1"></a>_h64</span>
<span id="cb118-3"><a href="#cb118-3" aria-hidden="true" tabindex="-1"></a>_o144</span></code></pre></div>
<p><strong>Notes</strong>:</p>
<ul>
<li><p><code>_01100100</code> used to be considered equivalent to <code>_b01100100</code>, however, due to compatibility troubles with a recent version of Ruby it is considered deprecated.</p></li>
<li><p>Ruby immediate values can also be used, their bit width is automatically adjusted to match the data type of the expression they are used in. Please notice this adjustment may change the value of the immediate, for example, the following code will set <code>sig</code> to 4 instead of 100:</p>
<div class="sourceCode" id="cb119"><pre class="sourceCode ruby"><code class="sourceCode ruby"><span id="cb119-1"><a href="#cb119-1" aria-hidden="true" tabindex="-1"></a><span class="kw">[</span><span class="dv">3</span><span class="kw">..</span><span class="dv">0</span><span class="kw">]</span><span class="at">.inner</span> <span class="wa">:sig</span></span>
<span id="cb119-2"><a href="#cb119-2" aria-hidden="true" tabindex="-1"></a>sig <span class="kw">&lt;=</span> <span class="dv">100</span></span></code></pre></div></li>
</ul>
<h3 id="references">References</h3>
<p>References are expressions used to designate signals or a part of signals.</p>
<p>The simplest reference is simply the name of a signal. It designates the signal corresponding to this name in the current scope. For instance, in the following code, inner signal <code>sig0</code> is declared, and therefore the name <em>sig0</em> becomes a reference to designate this signal.</p>
<div class="sourceCode" id="cb120"><pre class="sourceCode ruby"><code class="sourceCode ruby"><span id="cb120-1"><a href="#cb120-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Declaration of signal sig0.</span></span>
<span id="cb120-2"><a href="#cb120-2" aria-hidden="true" tabindex="-1"></a>inner <span class="wa">:sig0</span></span>
<span id="cb120-3"><a href="#cb120-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb120-4"><a href="#cb120-4" aria-hidden="true" tabindex="-1"></a><span class="co"># Access to signal sig0 using a name reference.</span></span>
<span id="cb120-5"><a href="#cb120-5" aria-hidden="true" tabindex="-1"></a>sig0 <span class="kw">&lt;=</span> <span class="dv">0</span></span></code></pre></div>
<p>For designating a signal of another system, or a sub-signal in a hierarchical signal, you can use the <code>.</code> operator as follows:</p>
<div class="sourceCode" id="cb121"><pre class="sourceCode ruby"><code class="sourceCode ruby"><span id="cb121-1"><a href="#cb121-1" aria-hidden="true" tabindex="-1"></a><span class="kw">&lt;</span>parent name<span class="kw">&gt;.&lt;</span>signal name<span class="kw">&gt;</span></span></code></pre></div>
<p>For example, in the following code, input signal <code>d</code> of system instance <code>dff0</code> is connected to sub-signal <code>sub0</code> of hierarchical signal <code>sig</code>.</p>
<div class="sourceCode" id="cb122"><pre class="sourceCode ruby"><code class="sourceCode ruby"><span id="cb122-1"><a href="#cb122-1" aria-hidden="true" tabindex="-1"></a><span class="fu">system</span> <span class="wa">:dff</span> <span class="cf">do</span></span>
<span id="cb122-2"><a href="#cb122-2" aria-hidden="true" tabindex="-1"></a>   input <span class="wa">:clk</span>, <span class="wa">:rst</span>, <span class="wa">:d</span></span>
<span id="cb122-3"><a href="#cb122-3" aria-hidden="true" tabindex="-1"></a>   output <span class="wa">:q</span></span>
<span id="cb122-4"><a href="#cb122-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb122-5"><a href="#cb122-5" aria-hidden="true" tabindex="-1"></a>   par(clk<span class="at">.posedge</span>) <span class="kw">{</span> q <span class="kw">&lt;=</span> d <span class="kw">&amp;</span> <span class="kw">~</span>rst <span class="kw">}</span></span>
<span id="cb122-6"><a href="#cb122-6" aria-hidden="true" tabindex="-1"></a><span class="cf">end</span></span>
<span id="cb122-7"><a href="#cb122-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb122-8"><a href="#cb122-8" aria-hidden="true" tabindex="-1"></a><span class="fu">system</span> <span class="wa">:my_system</span> <span class="cf">do</span></span>
<span id="cb122-9"><a href="#cb122-9" aria-hidden="true" tabindex="-1"></a>   input <span class="wa">:clk</span>, <span class="wa">:rst</span></span>
<span id="cb122-10"><a href="#cb122-10" aria-hidden="true" tabindex="-1"></a>   <span class="kw">{</span> <span class="wa">sub0: </span>bit, <span class="wa">sub1: </span>bit<span class="kw">}</span><span class="at">.inner</span> <span class="wa">:sig</span></span>
<span id="cb122-11"><a href="#cb122-11" aria-hidden="true" tabindex="-1"></a>   </span>
<span id="cb122-12"><a href="#cb122-12" aria-hidden="true" tabindex="-1"></a>   dff(<span class="wa">:dff0</span>)<span class="kw">.</span>(<span class="wa">clk: </span>clk, <span class="wa">rst: </span>rst)</span>
<span id="cb122-13"><a href="#cb122-13" aria-hidden="true" tabindex="-1"></a>   dff0<span class="at">.d</span> <span class="kw">&lt;=</span> sig<span class="at">.sub0</span></span>
<span id="cb122-14"><a href="#cb122-14" aria-hidden="true" tabindex="-1"></a>   <span class="kw">...</span></span>
<span id="cb122-15"><a href="#cb122-15" aria-hidden="true" tabindex="-1"></a><span class="cf">end</span></span></code></pre></div>
<h3 id="expression-operators">Expression operators</h3>
<p>The following table gives a summary of the operators available in HDLRuby. More details are given for each group of operators in the subsequent sections.</p>
<p><strong>Assignment operators (left-most operator of a statement):</strong></p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">      symbol      </th>
<th style="text-align: left;">description              </th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">:&lt;=</td>
<td style="text-align: left;">connection, if outside behavior</td>
</tr>
<tr class="even">
<td style="text-align: left;">:&lt;=</td>
<td style="text-align: left;">transmission, if inside behavior</td>
</tr>
</tbody>
</table>
<p><strong>Arithmetic operators:</strong></p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">      symbol      </th>
<th style="text-align: left;">description              </th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">:+</td>
<td style="text-align: left;">addition</td>
</tr>
<tr class="even">
<td style="text-align: left;">:-</td>
<td style="text-align: left;">subtraction</td>
</tr>
<tr class="odd">
<td style="text-align: left;">:*</td>
<td style="text-align: left;">multiplication</td>
</tr>
<tr class="even">
<td style="text-align: left;">:/</td>
<td style="text-align: left;">division</td>
</tr>
<tr class="odd">
<td style="text-align: left;">:%</td>
<td style="text-align: left;">modulo</td>
</tr>
<tr class="even">
<td style="text-align: left;">:**</td>
<td style="text-align: left;">power</td>
</tr>
<tr class="odd">
<td style="text-align: left;">:+@</td>
<td style="text-align: left;">positive sign</td>
</tr>
<tr class="even">
<td style="text-align: left;">:-@</td>
<td style="text-align: left;">negation</td>
</tr>
</tbody>
</table>
<p><strong>Comparison operators:</strong></p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">      symbol      </th>
<th style="text-align: left;">description              </th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">:==</td>
<td style="text-align: left;">equality</td>
</tr>
<tr class="even">
<td style="text-align: left;">:!=</td>
<td style="text-align: left;">difference</td>
</tr>
<tr class="odd">
<td style="text-align: left;">:&gt;</td>
<td style="text-align: left;">greater than</td>
</tr>
<tr class="even">
<td style="text-align: left;">:&lt;</td>
<td style="text-align: left;">smaller than</td>
</tr>
<tr class="odd">
<td style="text-align: left;">:&gt;=</td>
<td style="text-align: left;">greater or equal</td>
</tr>
<tr class="even">
<td style="text-align: left;">:&lt;=</td>
<td style="text-align: left;">smaller or equal</td>
</tr>
</tbody>
</table>
<p><strong>Logic and shift operators:</strong></p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">      symbol      </th>
<th style="text-align: left;">description              </th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">:&amp;</td>
<td style="text-align: left;">bitwise / logical and</td>
</tr>
<tr class="even">
<td style="text-align: left;">:</td>
<td style="text-align: left;"></td>
</tr>
<tr class="odd">
<td style="text-align: left;">:~</td>
<td style="text-align: left;">bitwise / logical not</td>
</tr>
<tr class="even">
<td style="text-align: left;">:mux</td>
<td style="text-align: left;">multiplex</td>
</tr>
<tr class="odd">
<td style="text-align: left;">:&lt;&lt; / :ls</td>
<td style="text-align: left;">left shift</td>
</tr>
<tr class="even">
<td style="text-align: left;">:&gt;&gt; / :rs</td>
<td style="text-align: left;">right shift</td>
</tr>
<tr class="odd">
<td style="text-align: left;">:lr</td>
<td style="text-align: left;">left rotate</td>
</tr>
<tr class="even">
<td style="text-align: left;">:rr</td>
<td style="text-align: left;">right rotate</td>
</tr>
</tbody>
</table>
<p><strong>Conversion operators:</strong></p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">      symbol      </th>
<th style="text-align: left;">description              </th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">:to_bit</td>
<td style="text-align: left;">cast to bit vector</td>
</tr>
<tr class="even">
<td style="text-align: left;">:to_unsigned</td>
<td style="text-align: left;">cast to unsigned vector</td>
</tr>
<tr class="odd">
<td style="text-align: left;">:to_signed</td>
<td style="text-align: left;">cast to signed vector</td>
</tr>
<tr class="even">
<td style="text-align: left;">:to_big</td>
<td style="text-align: left;">cast to big-endian</td>
</tr>
<tr class="odd">
<td style="text-align: left;">:to_little</td>
<td style="text-align: left;">cast to little endian</td>
</tr>
<tr class="even">
<td style="text-align: left;">:reverse</td>
<td style="text-align: left;">reverse the bit order</td>
</tr>
<tr class="odd">
<td style="text-align: left;">:ljust</td>
<td style="text-align: left;">increase width from the left, preserves the sign</td>
</tr>
<tr class="even">
<td style="text-align: left;">:rjust</td>
<td style="text-align: left;">increase width from the right, preserves the sign</td>
</tr>
<tr class="odd">
<td style="text-align: left;">:zext</td>
<td style="text-align: left;">zero extension, converts to unsigned if signed</td>
</tr>
<tr class="even">
<td style="text-align: left;">:sext</td>
<td style="text-align: left;">sign extension, converts to sign</td>
</tr>
</tbody>
</table>
<p><strong>Selection /concatenation operators:</strong></p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">      symbol      </th>
<th style="text-align: left;">description              </th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">:[]</td>
<td style="text-align: left;">sub-vector selection</td>
</tr>
<tr class="even">
<td style="text-align: left;">:@[]</td>
<td style="text-align: left;">concatenation operator</td>
</tr>
<tr class="odd">
<td style="text-align: left;">:.</td>
<td style="text-align: left;">field selection</td>
</tr>
</tbody>
</table>
<p><strong>Notes</strong>:</p>
<ul>
<li><p>The operator precedence is the one of Ruby.</p></li>
<li><p>Ruby does not allow to override the <code>&amp;&amp;</code>, the <code>||</code>, and the <code>?:</code> operators so they are not present in HDLRuby. Instead of the <code>?:</code> operator, HDLRuby provides the more general multiplex operator <code>mux</code>. However, HDLRuby does not provide any replacement for the <code>&amp;&amp;</code> and the <code>||</code> operators, please refer to section <a href="#logic-and-shift-operators">Logic operators</a> for a justification for this issue.</p></li>
</ul>
<h4 id="assignment-operators">Assignment operators</h4>
<p>The assignment operators can be used with any type. They are the connection and the transmission operators both being represented by <code>&lt;=</code>.</p>
<p><strong>Note</strong>:</p>
<ul>
<li>The first operator of a statement is necessarily an assignment operator, while the other occurrences of <code>&lt;=</code> represent the usual <code>less than or equal to</code> operators.</li>
</ul>
<h4 id="arithmetic-operators">Arithmetic operators</h4>
<p><a name="arithmetic"></a></p>
<p>The arithmetic operators can only be used on vectors of <code>bit</code>, <code>unsigned</code> or <code>signed</code> values, <code>integer</code>, or <code>float</code> values. These operators are <code>+</code>, <code>-</code>, <code>*</code>, <code>%</code> and the unary arithmetic operators are <code>-</code> and <code>+</code>. They have the same meaning as their Ruby equivalents.</p>
<h4 id="comparison-operators">Comparison operators</h4>
<p><a name="comparison"></a></p>
<p>Comparison operators are the operators whose result is either true or false. In HDLRuby, true and false are represented by respectively <code>bit</code> value 1 and <code>bit</code> value 0. These operators are <code>==</code>, <code>!=</code>, <code>&lt;</code>, <code>&gt;</code>, <code>&lt;=</code>, <code>&gt;=</code> . They have the same meaning as their Ruby equivalents.</p>
<p><strong>Notes</strong>:</p>
<ul>
<li><p>The <code>&lt;</code>, <code>&gt;</code>, <code>&lt;=</code> and <code>&gt;=</code> operators can only be used on vectors of <code>bit</code>, <code>unsigned</code> or <code>signed</code> values, <code>integer</code> or <code>float</code> values.</p></li>
<li><p>When compared, values of a type different from the vector of <code>signed</code> and from <code>float</code> are considered as vectors of <code>unsigned</code>.</p></li>
</ul>
<h4 id="logic-and-shift-operators">Logic and shift operators</h4>
<p>In HDLRuby, the logic operators are all bitwise. For performing Boolean computations, it is necessary to use single-bit values. The bitwise logic binary operators are <code>&amp;</code>, <code>|</code>, and <code>^</code>, and the unary one is <code>~</code>. They have the same meaning as their Ruby equivalents.</p>
<p><strong>Note</strong>: there are two reasons why there are no Boolean operators</p>
<ol type="1">
<li><p>Ruby language does not support the redefinition of the Boolean operators</p></li>
<li><p>In Ruby, each value that is not <code>false</code> nor <code>nil</code> is assumed to be true. This is perfectly relevant for software, but not for hardware where the basic data types are bit vectors. Hence, it seemed preferable to support Boolean computation for one-bit values only, which can be done through bitwise operations.</p></li>
</ol>
<p>The shift operators are <code>&lt;&lt;</code> and <code>&gt;&gt;</code> and have the same meaning as their Ruby equivalent. They do not change the bit width and preserve the sign for <code>signed</code> values.</p>
<p>The rotation operators are <code>rl</code> and <code>rr</code> for respectively left and right bit rotations. Like the shifts, they do not change the bit width and preserve the sign for the <code>signed</code> values. However, since such operators do not exist in Ruby, they are used like methods as follows:</p>
<div class="sourceCode" id="cb123"><pre class="sourceCode ruby"><code class="sourceCode ruby"><span id="cb123-1"><a href="#cb123-1" aria-hidden="true" tabindex="-1"></a><span class="kw">&lt;</span>expression<span class="kw">&gt;</span><span class="at">.rl</span>(<span class="kw">&lt;</span>other expression<span class="kw">&gt;</span>)</span>
<span id="cb123-2"><a href="#cb123-2" aria-hidden="true" tabindex="-1"></a><span class="kw">&lt;</span>expression<span class="kw">&gt;</span><span class="at">.rr</span>(<span class="kw">&lt;</span>other expression<span class="kw">&gt;</span>)</span></code></pre></div>
<p>For example, for rotating the left signal <code>sig</code> 3 times, the following code can be used:</p>
<div class="sourceCode" id="cb124"><pre class="sourceCode ruby"><code class="sourceCode ruby"><span id="cb124-1"><a href="#cb124-1" aria-hidden="true" tabindex="-1"></a>sig<span class="at">.rl</span>(<span class="dv">3</span>)</span></code></pre></div>
<p>It is possible to perform other kinds of shifts or rotations using the selection and concatenation operators. Please refer to section <a href="#concatenation-and-selection-operators">Concatenation and selection operators</a> for more details about these operators.</p>
<h4 id="conversion-operators">Conversion operators</h4>
<p>The conversion operators are used to change the type of an expression. There are two kinds of such operators: the type pun that does not change the raw value of the expression and the type cast that changes the raw value.</p>
<p>The type puns include <code>to_bit</code>, <code>to_unsigned</code>, and <code>to_signed</code> that convert expressions of any type to vectors of respectively <code>bit</code>, <code>unsigned</code>, and <code>signed</code> elements. For example, the following code converts an expression of hierarchical type to an 8-bit signed vector:</p>
<div class="sourceCode" id="cb125"><pre class="sourceCode ruby"><code class="sourceCode ruby"><span id="cb125-1"><a href="#cb125-1" aria-hidden="true" tabindex="-1"></a><span class="kw">[</span> <span class="wa">up: </span>signed<span class="kw">[</span><span class="dv">3</span><span class="kw">..</span><span class="dv">0</span><span class="kw">]</span>, <span class="wa">down: </span>unsigned<span class="kw">[</span><span class="dv">3</span><span class="kw">..</span><span class="dv">0</span><span class="kw">]</span> <span class="kw">]</span><span class="at">.inner</span> <span class="wa">:sig</span></span>
<span id="cb125-2"><a href="#cb125-2" aria-hidden="true" tabindex="-1"></a>sig<span class="at">.to_bit</span> <span class="kw">&lt;=</span> _b01010011</span></code></pre></div>
<p>The type casts change both the type and the value and are used to adjust the width of the types. They can only be applied to vectors of <code>bit</code>, <code>signed</code>, or <code>unsigned</code> and can only increase the bit width (bit width can be truncated using the selection operator, please refer to the next section). These operators comprise the bit width conversions: <code>ljust</code>, <code>rjust</code>, <code>zext</code>, and <code>sext</code>.</p>
<p>More precisely, the bit width conversions operate as follows:</p>
<ul>
<li><p><code>ljust</code> and <code>rjust</code> increase the size from respectively the left or the right side of the bit vector. They take as an argument the width of the new type and the value (0 or 1) of the bits to add. For example, the following code increases the size of <code>sig0</code> to 12 bits by adding 1 on the right:</p>
<div class="sourceCode" id="cb126"><pre class="sourceCode ruby"><code class="sourceCode ruby"><span id="cb126-1"><a href="#cb126-1" aria-hidden="true" tabindex="-1"></a><span class="kw">[</span><span class="dv">7</span><span class="kw">..</span><span class="dv">0</span><span class="kw">]</span><span class="at">.inner</span> <span class="wa">:sig0</span></span>
<span id="cb126-2"><a href="#cb126-2" aria-hidden="true" tabindex="-1"></a><span class="kw">[</span><span class="dv">11</span><span class="kw">..</span><span class="dv">0</span><span class="kw">]</span><span class="at">.inner</span> <span class="wa">:sig1</span></span>
<span id="cb126-3"><a href="#cb126-3" aria-hidden="true" tabindex="-1"></a>sig0 <span class="kw">&lt;=</span> <span class="dv">25</span></span>
<span id="cb126-4"><a href="#cb126-4" aria-hidden="true" tabindex="-1"></a>sig1 <span class="kw">&lt;=</span> sig0<span class="at">.ljust</span>(<span class="dv">12</span>,<span class="dv">1</span>)</span></code></pre></div></li>
<li><p><code>zext</code> increases the size by adding several 0 bits on the most significant bit side, this side depending on the endianness of the expression. This conversion takes as an argument the width of the resulting type. For example, the following code increases the size of <code>sig0</code> to 12 bits by adding 0 on the left:</p>
<div class="sourceCode" id="cb127"><pre class="sourceCode ruby"><code class="sourceCode ruby"><span id="cb127-1"><a href="#cb127-1" aria-hidden="true" tabindex="-1"></a>signed<span class="kw">[</span><span class="dv">7</span><span class="kw">..</span><span class="dv">0</span><span class="kw">]</span><span class="at">.inner</span> <span class="wa">:sig0</span></span>
<span id="cb127-2"><a href="#cb127-2" aria-hidden="true" tabindex="-1"></a><span class="kw">[</span><span class="dv">11</span><span class="kw">..</span><span class="dv">0</span><span class="kw">]</span><span class="at">.inner</span> <span class="wa">:sig1</span></span>
<span id="cb127-3"><a href="#cb127-3" aria-hidden="true" tabindex="-1"></a>sig0 <span class="kw">&lt;=</span> <span class="kw">-</span><span class="dv">120</span></span>
<span id="cb127-4"><a href="#cb127-4" aria-hidden="true" tabindex="-1"></a>sig1 <span class="kw">&lt;=</span> sig0<span class="at">.zext</span>(<span class="dv">12</span>)</span></code></pre></div></li>
<li><p><code>sext</code> increases the size by duplicating the most significant bit, the side of the extension depending on the endianness of the expression. This conversion takes as an argument the width of the resulting type. For example, the following code increases the size of <code>sig0</code> to 12 bits by adding 1 on the right:</p>
<div class="sourceCode" id="cb128"><pre class="sourceCode ruby"><code class="sourceCode ruby"><span id="cb128-1"><a href="#cb128-1" aria-hidden="true" tabindex="-1"></a>signed<span class="kw">[</span><span class="dv">0</span><span class="kw">..</span><span class="dv">7</span><span class="kw">]</span><span class="at">.inner</span> <span class="wa">:sig0</span></span>
<span id="cb128-2"><a href="#cb128-2" aria-hidden="true" tabindex="-1"></a><span class="kw">[</span><span class="dv">0</span><span class="kw">..</span><span class="dv">11</span><span class="kw">]</span><span class="at">.inner</span> <span class="wa">:sig1</span></span>
<span id="cb128-3"><a href="#cb128-3" aria-hidden="true" tabindex="-1"></a>sig0 <span class="kw">&lt;=</span> <span class="kw">-</span><span class="dv">120</span></span>
<span id="cb128-4"><a href="#cb128-4" aria-hidden="true" tabindex="-1"></a>sig1 <span class="kw">&lt;=</span> sig0<span class="at">.sext</span>(<span class="dv">12</span>)</span></code></pre></div></li>
</ul>
<h4 id="concatenation-and-selection-operators">Concatenation and selection operators</h4>
<p>Concatenation and selection are done using the <code>[]</code> operator as follows:</p>
<ul>
<li><p>when this operator takes as arguments several expressions, it concatenates them. For example, the following code concatenates <code>sig0</code> to <code>sig1</code>:</p>
<div class="sourceCode" id="cb129"><pre class="sourceCode ruby"><code class="sourceCode ruby"><span id="cb129-1"><a href="#cb129-1" aria-hidden="true" tabindex="-1"></a><span class="kw">[</span><span class="dv">3</span><span class="kw">..</span><span class="dv">0</span><span class="kw">]</span><span class="at">.inner</span> <span class="wa">:sig0</span></span>
<span id="cb129-2"><a href="#cb129-2" aria-hidden="true" tabindex="-1"></a><span class="kw">[</span><span class="dv">7</span><span class="kw">..</span><span class="dv">0</span><span class="kw">]</span><span class="at">.inner</span> <span class="wa">:sig1</span></span>
<span id="cb129-3"><a href="#cb129-3" aria-hidden="true" tabindex="-1"></a><span class="kw">[</span><span class="dv">11</span><span class="kw">..</span><span class="dv">0</span><span class="kw">]</span><span class="at">.inner</span> <span class="wa">:sig2</span></span>
<span id="cb129-4"><a href="#cb129-4" aria-hidden="true" tabindex="-1"></a>sig0 <span class="kw">&lt;=</span> <span class="dv">5</span></span>
<span id="cb129-5"><a href="#cb129-5" aria-hidden="true" tabindex="-1"></a>sig1 <span class="kw">&lt;=</span> <span class="dv">6</span></span>
<span id="cb129-6"><a href="#cb129-6" aria-hidden="true" tabindex="-1"></a>sig2 <span class="kw">&lt;=</span> <span class="kw">[</span>sig0, sig1<span class="kw">]</span></span></code></pre></div></li>
<li><p>when this operator is applied to an expression of <code>bit</code>, <code>unsigned</code>, or <code>signed</code> vector type while taking as argument a range, it selects the bits corresponding to this range. If only one bit is to be selected, the offset of this bit can be used instead. For example, the following code selects bits from 3 to 1 of <code>sig0</code> and bit 4 of <code>sig1</code>:</p>
<div class="sourceCode" id="cb130"><pre class="sourceCode ruby"><code class="sourceCode ruby"><span id="cb130-1"><a href="#cb130-1" aria-hidden="true" tabindex="-1"></a><span class="kw">[</span><span class="dv">7</span><span class="kw">..</span><span class="dv">0</span><span class="kw">]</span><span class="at">.inner</span> <span class="wa">:sig0</span></span>
<span id="cb130-2"><a href="#cb130-2" aria-hidden="true" tabindex="-1"></a><span class="kw">[</span><span class="dv">7</span><span class="kw">..</span><span class="dv">0</span><span class="kw">]</span><span class="at">.inner</span> <span class="wa">:sig1</span></span>
<span id="cb130-3"><a href="#cb130-3" aria-hidden="true" tabindex="-1"></a><span class="kw">[</span><span class="dv">3</span><span class="kw">..</span><span class="dv">0</span><span class="kw">]</span><span class="at">.inner</span> <span class="wa">:sig2</span></span>
<span id="cb130-4"><a href="#cb130-4" aria-hidden="true" tabindex="-1"></a>bit<span class="at">.inner</span>    <span class="wa">:sig3</span></span>
<span id="cb130-5"><a href="#cb130-5" aria-hidden="true" tabindex="-1"></a>sig0 <span class="kw">&lt;=</span> <span class="dv">5</span></span>
<span id="cb130-6"><a href="#cb130-6" aria-hidden="true" tabindex="-1"></a>sig1 <span class="kw">&lt;=</span> <span class="dv">6</span></span>
<span id="cb130-7"><a href="#cb130-7" aria-hidden="true" tabindex="-1"></a>sig2 <span class="kw">&lt;=</span> sig0<span class="kw">[</span><span class="dv">3</span><span class="kw">..</span><span class="dv">1</span><span class="kw">]</span></span>
<span id="cb130-8"><a href="#cb130-8" aria-hidden="true" tabindex="-1"></a>sig3 <span class="kw">&lt;=</span> sig1<span class="kw">[</span><span class="dv">4</span><span class="kw">]</span></span></code></pre></div></li>
</ul>
<h4 id="implicit-conversions">Implicit conversions</h4>
<p><a name="implicit"></a></p>
<p>When there is no ambiguity, HDLRuby will automatically insert conversion operators when two types are not compatible with one another. The cases where such implicit conversions are applied are summarized in the following tables, where:</p>
<ul>
<li><code>operator</code> is the operator in use</li>
<li><code>result width</code> is the width of the result’s type</li>
<li><code>result base</code> is the base type of the result’s type</li>
<li><code>S</code> is the shortest operand</li>
<li><code>L</code> is the longest operand</li>
<li><code>S operand type</code> is the base type of the shortest operand</li>
<li><code>L operand type</code> is the base type of the longest operand</li>
<li><code>operand conversion</code> is the conversions added to make the operands compatible.</li>
<li><code>w</code> is the width of the operands after conversion</li>
<li><code>lw</code> is the width of the left operand’s type before conversion</li>
<li><code>rw</code> is the width of the right operand’s type before conversion</li>
</ul>
<p><strong>Additive and logical operators:</strong></p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">operator</th>
<th style="text-align: left;">result’s width</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">&lt;= (assign)</td>
<td style="text-align: left;">w (error is raised if L.width &lt; R.width)</td>
</tr>
<tr class="even">
<td style="text-align: left;">+, -</td>
<td style="text-align: left;">w+1</td>
</tr>
<tr class="odd">
<td style="text-align: left;">&amp;, |, ^</td>
<td style="text-align: left;">w</td>
</tr>
<tr class="even">
<td style="text-align: left;">==</td>
<td style="text-align: left;">1</td>
</tr>
<tr class="odd">
<td style="text-align: left;">&lt;</td>
<td style="text-align: left;">1</td>
</tr>
<tr class="even">
<td style="text-align: left;">&gt;</td>
<td style="text-align: left;">1</td>
</tr>
<tr class="odd">
<td style="text-align: left;">&lt;= (comp.)</td>
<td style="text-align: left;">1</td>
</tr>
<tr class="even">
<td style="text-align: left;">&gt;=</td>
<td style="text-align: left;">1</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">S operand base</th>
<th style="text-align: left;">L operand base</th>
<th style="text-align: left;">result base</th>
<th style="text-align: left;">operand conversion</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">bit</td>
<td style="text-align: left;">bit</td>
<td style="text-align: left;">bit</td>
<td style="text-align: left;">S.zext(L.width)</td>
</tr>
<tr class="even">
<td style="text-align: left;">bit</td>
<td style="text-align: left;">unsigned</td>
<td style="text-align: left;">unsigned</td>
<td style="text-align: left;">S.zext(L.width).to_unsigned</td>
</tr>
<tr class="odd">
<td style="text-align: left;">bit</td>
<td style="text-align: left;">signed</td>
<td style="text-align: left;">signed</td>
<td style="text-align: left;">S.zext(max(S.width+1,L.width).to_signed</td>
</tr>
<tr class="even">
<td style="text-align: left;">unsigned</td>
<td style="text-align: left;">bit</td>
<td style="text-align: left;">unsigned</td>
<td style="text-align: left;">S.zext(L.width), L.to_unsigned</td>
</tr>
<tr class="odd">
<td style="text-align: left;">unsigned</td>
<td style="text-align: left;">unsigned</td>
<td style="text-align: left;">unsigned</td>
<td style="text-align: left;">S.zext(L.width)</td>
</tr>
<tr class="even">
<td style="text-align: left;">unsigned</td>
<td style="text-align: left;">signed</td>
<td style="text-align: left;">signed</td>
<td style="text-align: left;">S.zext(max(S.width+1,L.width).to_signed</td>
</tr>
<tr class="odd">
<td style="text-align: left;">signed</td>
<td style="text-align: left;">bit</td>
<td style="text-align: left;">signed</td>
<td style="text-align: left;">S.sext(L.width+1), L.zext(L.width+1).to_signed</td>
</tr>
<tr class="even">
<td style="text-align: left;">signed</td>
<td style="text-align: left;">unsigned</td>
<td style="text-align: left;">signed</td>
<td style="text-align: left;">S.sext(L.width+1), L.zext(L.width+1).to_signed</td>
</tr>
<tr class="odd">
<td style="text-align: left;">signed</td>
<td style="text-align: left;">signed</td>
<td style="text-align: left;">signed</td>
<td style="text-align: left;">S.sext(L.width)</td>
</tr>
</tbody>
</table>
<p><strong>Multiplicative operators:</strong></p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">operator</th>
<th style="text-align: left;">result width</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">*</td>
<td style="text-align: left;">lw * rw</td>
</tr>
<tr class="even">
<td style="text-align: left;">/</td>
<td style="text-align: left;">lw</td>
</tr>
<tr class="odd">
<td style="text-align: left;">%</td>
<td style="text-align: left;">rw</td>
</tr>
<tr class="even">
<td style="text-align: left;">**</td>
<td style="text-align: left;">rw</td>
</tr>
<tr class="odd">
<td style="text-align: left;">&lt;&lt; / ls</td>
<td style="text-align: left;">lw</td>
</tr>
<tr class="even">
<td style="text-align: left;">&gt;&gt; / rs</td>
<td style="text-align: left;">lw</td>
</tr>
<tr class="odd">
<td style="text-align: left;">lr</td>
<td style="text-align: left;">lw</td>
</tr>
<tr class="even">
<td style="text-align: left;">rr</td>
<td style="text-align: left;">lw</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">S operand base</th>
<th style="text-align: left;">L operand base</th>
<th style="text-align: left;">result base</th>
<th style="text-align: left;">operand conversion</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">bit</td>
<td style="text-align: left;">bit</td>
<td style="text-align: left;">bit</td>
<td style="text-align: left;"></td>
</tr>
<tr class="even">
<td style="text-align: left;">bit</td>
<td style="text-align: left;">unsigned</td>
<td style="text-align: left;">unsigned</td>
<td style="text-align: left;">S.to_unsigned</td>
</tr>
<tr class="odd">
<td style="text-align: left;">bit</td>
<td style="text-align: left;">signed</td>
<td style="text-align: left;">signed</td>
<td style="text-align: left;">S.zext(S.width+1).to_signed</td>
</tr>
<tr class="even">
<td style="text-align: left;">unsigned</td>
<td style="text-align: left;">bit</td>
<td style="text-align: left;">unsigned</td>
<td style="text-align: left;">L.to_unsigned</td>
</tr>
<tr class="odd">
<td style="text-align: left;">unsigned</td>
<td style="text-align: left;">unsigned</td>
<td style="text-align: left;">unsigned</td>
<td style="text-align: left;"></td>
</tr>
<tr class="even">
<td style="text-align: left;">unsigned</td>
<td style="text-align: left;">signed</td>
<td style="text-align: left;">signed</td>
<td style="text-align: left;">S.zext(S.width).to_signed</td>
</tr>
<tr class="odd">
<td style="text-align: left;">signed</td>
<td style="text-align: left;">bit</td>
<td style="text-align: left;">signed</td>
<td style="text-align: left;">L.zext(L.width+1).to_signed</td>
</tr>
<tr class="even">
<td style="text-align: left;">signed</td>
<td style="text-align: left;">unsigned</td>
<td style="text-align: left;">signed</td>
<td style="text-align: left;">L.zext(L.width+1).to_signed</td>
</tr>
<tr class="odd">
<td style="text-align: left;">signed</td>
<td style="text-align: left;">signed</td>
<td style="text-align: left;">signed</td>
<td style="text-align: left;"></td>
</tr>
</tbody>
</table>
<h2 id="functions">Functions</h2>
<h3 id="hdlruby-functions">HDLRuby functions</h3>
<p>Like Verilog HDL, HDLRuby provides function constructs for reusing code. HDLRuby functions are declared as follows:</p>
<div class="sourceCode" id="cb131"><pre class="sourceCode ruby"><code class="sourceCode ruby"><span id="cb131-1"><a href="#cb131-1" aria-hidden="true" tabindex="-1"></a>   hdef :<span class="kw">&lt;</span>function name<span class="kw">&gt;</span> <span class="cf">do</span> <span class="kw">|&lt;</span>arguments<span class="kw">&gt;|</span></span>
<span id="cb131-2"><a href="#cb131-2" aria-hidden="true" tabindex="-1"></a>   <span class="kw">&lt;</span>code<span class="kw">&gt;</span></span>
<span id="cb131-3"><a href="#cb131-3" aria-hidden="true" tabindex="-1"></a>   <span class="cf">end</span></span></code></pre></div>
<p>Where:</p>
<ul>
<li><code>function name</code> is the name of the function.</li>
<li><code>arguments</code> is the list of arguments of the function.</li>
<li><code>code</code> is the code of the function.</li>
</ul>
<p><strong>Notes</strong>:</p>
<ul>
<li><p>Functions have their scope, so any declaration within a function is local. It is also forbidden to declare interface signals (input, output, or inout) within a function.</p></li>
<li><p>Like the Ruby proc objects, the last statement of a function’s code serves as the return value. For instance, the following function returns <code>1</code> (in this example the function does not have any argument):</p>
<div class="sourceCode" id="cb132"><pre class="sourceCode ruby"><code class="sourceCode ruby"><span id="cb132-1"><a href="#cb132-1" aria-hidden="true" tabindex="-1"></a>function <span class="wa">:one</span> <span class="kw">{</span> <span class="dv">1</span> <span class="kw">}</span></span></code></pre></div></li>
<li><p>Functions can accept any object as an argument, including variadic arguments or blocks of code as shown below with a function that applies the code passed as an argument to all the variadic arguments of <code>args</code>:</p>
<div class="sourceCode" id="cb133"><pre class="sourceCode ruby"><code class="sourceCode ruby"><span id="cb133-1"><a href="#cb133-1" aria-hidden="true" tabindex="-1"></a>function <span class="wa">:apply</span> <span class="cf">do</span> <span class="kw">|*</span>args, <span class="kw">&amp;</span>code<span class="kw">|</span></span>
<span id="cb133-2"><a href="#cb133-2" aria-hidden="true" tabindex="-1"></a>   args<span class="at">.each</span> <span class="kw">{</span> <span class="kw">|</span>arg<span class="kw">|</span> code<span class="at">.call</span>(args) <span class="kw">}</span></span>
<span id="cb133-3"><a href="#cb133-3" aria-hidden="true" tabindex="-1"></a><span class="cf">end</span></span></code></pre></div>
<p>Such a function can be used for example for connecting a signal to a set of other signals as follows (where <code>sig</code> is connected to <code>x</code>, <code>y</code>, and <code>z</code>): <code>ruby   apply(x,y,z) { |v| v &lt;= sig }</code></p></li>
</ul>
<p>A function can be invoked anywhere in the code using its name and passing its argument between parentheses as follows:</p>
<div class="sourceCode" id="cb134"><pre class="sourceCode ruby"><code class="sourceCode ruby"><span id="cb134-1"><a href="#cb134-1" aria-hidden="true" tabindex="-1"></a><span class="kw">&lt;</span>function name<span class="kw">&gt;</span>(<span class="kw">&lt;</span>list of values<span class="kw">&gt;</span>)</span></code></pre></div>
<h3 id="ruby-functions">Ruby functions</h3>
<p>HDLRuby functions are useful for reusing code, but they cannot interact with the code they are called in. For example, it is not possible to add interface signals through a function nor to modify a control statement (e.g., <code>hif</code>) with them. These high-level generic operations can however be performed using the functions of the Ruby language declared as follows:</p>
<div class="sourceCode" id="cb135"><pre class="sourceCode ruby"><code class="sourceCode ruby"><span id="cb135-1"><a href="#cb135-1" aria-hidden="true" tabindex="-1"></a><span class="cf">def</span> <span class="kw">&lt;</span>function name<span class="kw">&gt;</span>(<span class="kw">&lt;</span>arguments<span class="kw">&gt;</span>)</span>
<span id="cb135-2"><a href="#cb135-2" aria-hidden="true" tabindex="-1"></a>   <span class="kw">&lt;</span>code<span class="kw">&gt;</span></span>
<span id="cb135-3"><a href="#cb135-3" aria-hidden="true" tabindex="-1"></a><span class="cf">end</span></span></code></pre></div>
<p>Where:</p>
<ul>
<li><code>function name</code> is the name of the function.</li>
<li><code>arguments</code> is the list of arguments of the function.</li>
<li><code>code</code> is the code of the function.</li>
</ul>
<p>These functions are called the same way HDLRuby functions are called, but this operation pastes the code of the function as is within the code. Moreover, these functions do not have any scope so any inner signal or instance declared within them will be added to the object they are invoked in.</p>
<p>For example, the following function will add input <code>in0</code> to any system where it is invoked:</p>
<div class="sourceCode" id="cb136"><pre class="sourceCode ruby"><code class="sourceCode ruby"><span id="cb136-1"><a href="#cb136-1" aria-hidden="true" tabindex="-1"></a><span class="cf">def</span> add_in0</span>
<span id="cb136-2"><a href="#cb136-2" aria-hidden="true" tabindex="-1"></a>   input <span class="wa">:in0</span></span>
<span id="cb136-3"><a href="#cb136-3" aria-hidden="true" tabindex="-1"></a><span class="cf">end</span></span></code></pre></div>
<p>This function can be used as follows:</p>
<div class="sourceCode" id="cb137"><pre class="sourceCode ruby"><code class="sourceCode ruby"><span id="cb137-1"><a href="#cb137-1" aria-hidden="true" tabindex="-1"></a><span class="fu">system</span> <span class="wa">:sys</span> <span class="cf">do</span></span>
<span id="cb137-2"><a href="#cb137-2" aria-hidden="true" tabindex="-1"></a>   <span class="kw">...</span></span>
<span id="cb137-3"><a href="#cb137-3" aria-hidden="true" tabindex="-1"></a>   add_in0</span>
<span id="cb137-4"><a href="#cb137-4" aria-hidden="true" tabindex="-1"></a>   <span class="kw">...</span></span>
<span id="cb137-5"><a href="#cb137-5" aria-hidden="true" tabindex="-1"></a><span class="cf">end</span></span></code></pre></div>
<p>As another example, the following function will add an alternative code that generates a reset to a condition statement (<code>hif</code> or <code>hcase</code>):</p>
<div class="sourceCode" id="cb138"><pre class="sourceCode ruby"><code class="sourceCode ruby"><span id="cb138-1"><a href="#cb138-1" aria-hidden="true" tabindex="-1"></a><span class="cf">def</span> too_bad</span>
<span id="cb138-2"><a href="#cb138-2" aria-hidden="true" tabindex="-1"></a>   helse <span class="kw">{</span> rst <span class="kw">&lt;=</span> <span class="dv">1</span> <span class="kw">}</span></span>
<span id="cb138-3"><a href="#cb138-3" aria-hidden="true" tabindex="-1"></a><span class="cf">end</span></span></code></pre></div>
<p>This function can be used as follows:</p>
<div class="sourceCode" id="cb139"><pre class="sourceCode ruby"><code class="sourceCode ruby"><span id="cb139-1"><a href="#cb139-1" aria-hidden="true" tabindex="-1"></a><span class="fu">system</span> <span class="wa">:sys</span> <span class="cf">do</span></span>
<span id="cb139-2"><a href="#cb139-2" aria-hidden="true" tabindex="-1"></a>   <span class="kw">...</span></span>
<span id="cb139-3"><a href="#cb139-3" aria-hidden="true" tabindex="-1"></a>   par <span class="cf">do</span></span>
<span id="cb139-4"><a href="#cb139-4" aria-hidden="true" tabindex="-1"></a>      hif(sig <span class="kw">==</span> <span class="dv">1</span>) <span class="cf">do</span></span>
<span id="cb139-5"><a href="#cb139-5" aria-hidden="true" tabindex="-1"></a>         <span class="kw">...</span></span>
<span id="cb139-6"><a href="#cb139-6" aria-hidden="true" tabindex="-1"></a>      <span class="cf">end</span></span>
<span id="cb139-7"><a href="#cb139-7" aria-hidden="true" tabindex="-1"></a>      too_bad</span>
<span id="cb139-8"><a href="#cb139-8" aria-hidden="true" tabindex="-1"></a>   <span class="cf">end</span></span>
<span id="cb139-9"><a href="#cb139-9" aria-hidden="true" tabindex="-1"></a><span class="cf">end</span></span></code></pre></div>
<p>Ruby functions can be compared to the macros of the C languages: they are more flexible since they edit the code they are invoked in, but they are also dangerous to use. In general, it is not recommended to use them, unless when designing a library of generic code for HDLRuby.</p>
<h2 id="software-code">Software code</h2>
<p>It is possible to describe hardware-software components in HDLRuby using the <code>program</code> construct that encapsulates some software code a provides an interface for communicating with the hardware. This interface is composed of three kinds of components:</p>
<ul>
<li><p>The activation events: 1-bit signal that triggers the execution of a given software function when the switch from 0 to 1 (or for negative ones, from 1 to 0).</p></li>
<li><p>The reading ports: bit-vector signals that can be read from a software function.</p></li>
<li><p>The writing ports: bit-vector signals that can be written from a software function.</p></li>
</ul>
<p><strong>Note:</strong></p>
<p>The same signal can be used at the same time by multiple ports for both reading and writing, however, from the software point of view, it will correspond to two different ports.</p>
<h3 id="declaring-a-software-component">Declaring a software component</h3>
<p>A software component is declared like a hardware process within a system. The syntax is the following:</p>
<div class="sourceCode" id="cb140"><pre class="sourceCode ruby"><code class="sourceCode ruby"><span id="cb140-1"><a href="#cb140-1" aria-hidden="true" tabindex="-1"></a>program(<span class="kw">&lt;</span>programming language<span class="kw">&gt;</span>, <span class="kw">&lt;</span>function name<span class="kw">&gt;</span>) <span class="cf">do</span></span>
<span id="cb140-2"><a href="#cb140-2" aria-hidden="true" tabindex="-1"></a>   <span class="kw">&lt;</span>location of the software files <span class="cf">and</span> description of its interface<span class="kw">&gt;</span></span>
<span id="cb140-3"><a href="#cb140-3" aria-hidden="true" tabindex="-1"></a><span class="cf">end</span></span></code></pre></div>
<p>In the code above, <code>programming language</code> is a symbol representing the programming language used for the software. For now, only two languages are supported:</p>
<ul>
<li><p><code>:ruby</code>: for programs in Ruby.</p></li>
<li><p><code>:c</code>: for programs in C. However, for this case, any language that can be compiled to a shared library linkable with C is supported.</p></li>
</ul>
<p>The <code>function name</code> parameter indicates which function is to be executed when an activation event occurs. There can be only one such function per program, but any number of programs can be declared inside the same module.</p>
<p>The <code>location of the software files and description of its interface</code> part can include the following declaration statements:</p>
<ul>
<li><p><code>actport &lt;list of events&gt;</code>: for declaring the list of events that activates the program, i.e., that will trigger the execution of the program’s start function.</p></li>
<li><p><code>inport &lt;list of port names associated with a signal&gt;</code>: for declaring the list of ports that the software code of the program can read.</p></li>
<li><p><code>outport &lt;list of port names associated with a signal&gt;</code>: for declaring the list of ports that the software code of the program can write to.</p></li>
<li><p><code>code &lt;list of filenames&gt;</code>: for declaring the source code files.</p></li>
</ul>
<p>For example the following declares a program in the Ruby language whose start function is <code>echo</code> that is activated on the positive edge of signal <code>req</code>, has a read port called <code>inP</code> that is connected to signal <code>count</code> and a write port called <code>outP</code> that is connected to signal <code>val</code>, finally the code of this program is given in a file named <code>echo.rb</code>:</p>
<div class="sourceCode" id="cb141"><pre class="sourceCode ruby"><code class="sourceCode ruby"><span id="cb141-1"><a href="#cb141-1" aria-hidden="true" tabindex="-1"></a><span class="fu">system</span> <span class="wa">:my_system</span> <span class="cf">do</span></span>
<span id="cb141-2"><a href="#cb141-2" aria-hidden="true" tabindex="-1"></a>   inner <span class="wa">:req</span></span>
<span id="cb141-3"><a href="#cb141-3" aria-hidden="true" tabindex="-1"></a>   <span class="kw">[</span><span class="dv">8</span><span class="kw">]</span><span class="at">.inner</span> <span class="wa">:count</span>, <span class="wa">:val</span></span>
<span id="cb141-4"><a href="#cb141-4" aria-hidden="true" tabindex="-1"></a> </span>
<span id="cb141-5"><a href="#cb141-5" aria-hidden="true" tabindex="-1"></a>   <span class="kw">...</span></span>
<span id="cb141-6"><a href="#cb141-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb141-7"><a href="#cb141-7" aria-hidden="true" tabindex="-1"></a>   program(<span class="wa">:ruby</span>,<span class="vs">&#39;echo&#39;</span>) <span class="cf">do</span></span>
<span id="cb141-8"><a href="#cb141-8" aria-hidden="true" tabindex="-1"></a>      actport req<span class="at">.posedge</span></span>
<span id="cb141-9"><a href="#cb141-9" aria-hidden="true" tabindex="-1"></a>      inport  <span class="wa">inP: </span> count</span>
<span id="cb141-10"><a href="#cb141-10" aria-hidden="true" tabindex="-1"></a>      outport <span class="wa">outP: </span>val</span>
<span id="cb141-11"><a href="#cb141-11" aria-hidden="true" tabindex="-1"></a>      code <span class="st">&quot;echo.rb&quot;</span></span>
<span id="cb141-12"><a href="#cb141-12" aria-hidden="true" tabindex="-1"></a>   <span class="cf">end</span></span>
<span id="cb141-13"><a href="#cb141-13" aria-hidden="true" tabindex="-1"></a><span class="cf">end</span></span></code></pre></div>
<p><strong>Note:</strong></p>
<p>The size of the input and output ports is one of the signals they give access to. However, from the software side, their values are converted to <code>long long</code> types.</p>
<h3 id="about-the-software-code-used-in-hdlruby-programs">About the software code used in HDLRuby programs</h3>
<h4 id="location-and-format-of-the-files">Location and format of the files</h4>
<p>The file names indicating the software code to use must indicate the path to these files relative to where the HDLRuby tools are used. In the example above, that would mean that the <code>echo.rb</code> program must be in the same directory as the HDLRuby description. If this code were to be into a <code>ruby</code> directory under the current directory, the declaration would become: <code>code "ruby/echo.rb"</code>. For the Ruby language, any number of source files can be declared, and plain Ruby code can be used as is. However, for the C language, the software code must first be compiled, and it is the resulting file that must be declared in the code declaration. For example, if for the example above, C had to be used, then the program description would be the following:</p>
<div class="sourceCode" id="cb142"><pre class="sourceCode ruby"><code class="sourceCode ruby"><span id="cb142-1"><a href="#cb142-1" aria-hidden="true" tabindex="-1"></a>   program(<span class="wa">:c</span>, <span class="wa">:echo</span>) <span class="cf">do</span></span>
<span id="cb142-2"><a href="#cb142-2" aria-hidden="true" tabindex="-1"></a>      actport req<span class="at">.posedge</span></span>
<span id="cb142-3"><a href="#cb142-3" aria-hidden="true" tabindex="-1"></a>      inport  <span class="wa">inP: </span> count</span>
<span id="cb142-4"><a href="#cb142-4" aria-hidden="true" tabindex="-1"></a>      outport <span class="wa">outP: </span>val</span>
<span id="cb142-5"><a href="#cb142-5" aria-hidden="true" tabindex="-1"></a>      code <span class="st">&quot;echo&quot;</span></span>
<span id="cb142-6"><a href="#cb142-6" aria-hidden="true" tabindex="-1"></a>   <span class="cf">end</span></span></code></pre></div>
<p>Then, for this program to work, the C code must be compiled to a file named <code>echo</code>. Please notice that, in the example, the extension is omitted, to allow the system to look for the valid file type (e.g., <code>.so</code> for a Linux shared library).</p>
<p><strong>Note:</strong></p>
<p>The same software file can be used for several different program constructs, however the functions it contains will be unique for the whole device.</p>
<h4 id="the-hardware-interface">The hardware interface</h4>
<p>From the software point of view, the hardware interface consists only of a list of ports that can either be read or written. However, the implementation of this interface depends on the language.</p>
<h5 id="for-ruby">For Ruby</h5>
<p>For ruby, the interface is accessed by requiring the <code>rubyHDL</code> library. It gives provides the <code>RubyHDL</code> module that provides accessors to ports of the program. For example, the following program reads on port ‘inP’ and writes the results on port `outP’:</p>
<div class="sourceCode" id="cb143"><pre class="sourceCode ruby"><code class="sourceCode ruby"><span id="cb143-1"><a href="#cb143-1" aria-hidden="true" tabindex="-1"></a><span class="fu">require</span> <span class="vs">&#39;rubyHDL&#39;</span></span>
<span id="cb143-2"><a href="#cb143-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb143-3"><a href="#cb143-3" aria-hidden="true" tabindex="-1"></a><span class="cf">def</span> echo</span>
<span id="cb143-4"><a href="#cb143-4" aria-hidden="true" tabindex="-1"></a>   val <span class="kw">=</span> <span class="dt">RubyHDL</span><span class="at">.inP</span></span>
<span id="cb143-5"><a href="#cb143-5" aria-hidden="true" tabindex="-1"></a>   <span class="dt">RubyHDL</span><span class="at">.outP</span> <span class="kw">=</span> val</span>
<span id="cb143-6"><a href="#cb143-6" aria-hidden="true" tabindex="-1"></a><span class="cf">end</span></span></code></pre></div>
<p><strong>Note:</strong></p>
<p>As long as a port has been declared in the HDLRuby description of the program, it will be available to the software as a module accessor without the need for any additional declaration or configuration.</p>
<h5 id="for-c">For C</h5>
<p>For C (and C-compatible compiled languages), the interface is accessed by including the ‘cHDL.h’ file. This file must be generated using the following command:</p>
<div class="sourceCode" id="cb144"><pre class="sourceCode bash"><code class="sourceCode bash"><span id="cb144-1"><a href="#cb144-1" aria-hidden="true" tabindex="-1"></a><span class="ex">hdrcc</span> <span class="at">--ch</span> <span class="op">&lt;</span>destination project<span class="op">&gt;</span></span></code></pre></div>
<p>In the command above, <code>&lt;destination project&gt;</code> is the directory where the C code is meant to be.</p>
<p>Once generated, this file provides the three following C functions:</p>
<ul>
<li><p><code>void* c_get_port(const char* name)</code>: returns a pointer to the port whose name is passed as argument.</p></li>
<li><p><code>int c_read_port(void* port)</code>: reads the port whose pointer is passed as argument and returns its value.</p></li>
<li><p><code>int c_write_port(void* port, int val)</code>: write the value <code>val</code> to the port passed as argument.</p></li>
</ul>
<p>For example, the following program reads on port ‘inP’ and writes the results on port `outP’:</p>
<div class="sourceCode" id="cb145"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb145-1"><a href="#cb145-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&quot;cHDL.h&quot;</span></span>
<span id="cb145-2"><a href="#cb145-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb145-3"><a href="#cb145-3" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> echo<span class="op">()</span> <span class="op">{</span></span>
<span id="cb145-4"><a href="#cb145-4" aria-hidden="true" tabindex="-1"></a>   <span class="dt">void</span><span class="op">*</span> inP <span class="op">=</span> c_get_port<span class="op">(</span><span class="st">&quot;inP&quot;</span><span class="op">);</span></span>
<span id="cb145-5"><a href="#cb145-5" aria-hidden="true" tabindex="-1"></a>   <span class="dt">void</span><span class="op">*</span> outP <span class="op">=</span> c_get_port<span class="op">(</span><span class="st">&quot;outP&quot;</span><span class="op">);</span></span>
<span id="cb145-6"><a href="#cb145-6" aria-hidden="true" tabindex="-1"></a>   <span class="dt">int</span> val<span class="op">;</span></span>
<span id="cb145-7"><a href="#cb145-7" aria-hidden="true" tabindex="-1"></a>   </span>
<span id="cb145-8"><a href="#cb145-8" aria-hidden="true" tabindex="-1"></a>   val <span class="op">=</span> c_read_port<span class="op">(</span>inP<span class="op">);</span></span>
<span id="cb145-9"><a href="#cb145-9" aria-hidden="true" tabindex="-1"></a>   c_write_port<span class="op">(</span>outP<span class="op">,</span>val<span class="op">);</span></span>
<span id="cb145-10"><a href="#cb145-10" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p><strong>Note:</strong></p>
<ul>
<li><p>The command for generating the C header file for using the HDLRuby hardware interface also generates files for helping to compile the source code. Please see <a href="#compiling-the-c-code">compile for simulation</a>.</p></li>
<li><p><strong>Important:</strong> for windows, dynamically loaded functions must be declared with the following prefix: <code>__declspec(dllexport)</code>. If this prefix is not present before each function that is used as an HDLRuby program, the simulation will not work. For example, for Windows, the function echo <em>must</em> be written as follows:</p></li>
</ul>
<div class="sourceCode" id="cb146"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb146-1"><a href="#cb146-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&quot;cHDL.h&quot;</span></span>
<span id="cb146-2"><a href="#cb146-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb146-3"><a href="#cb146-3" aria-hidden="true" tabindex="-1"></a>__declspec<span class="op">(</span>dllexport<span class="op">)</span> <span class="dt">void</span> echo<span class="op">()</span> <span class="op">{</span></span>
<span id="cb146-4"><a href="#cb146-4" aria-hidden="true" tabindex="-1"></a>   <span class="dt">void</span><span class="op">*</span> inP <span class="op">=</span> c_get_port<span class="op">(</span><span class="st">&quot;inP&quot;</span><span class="op">);</span></span>
<span id="cb146-5"><a href="#cb146-5" aria-hidden="true" tabindex="-1"></a>   <span class="dt">void</span><span class="op">*</span> outP <span class="op">=</span> c_get_port<span class="op">(</span><span class="st">&quot;outP&quot;</span><span class="op">);</span></span>
<span id="cb146-6"><a href="#cb146-6" aria-hidden="true" tabindex="-1"></a>   <span class="dt">int</span> val<span class="op">;</span></span>
<span id="cb146-7"><a href="#cb146-7" aria-hidden="true" tabindex="-1"></a>   </span>
<span id="cb146-8"><a href="#cb146-8" aria-hidden="true" tabindex="-1"></a>   val <span class="op">=</span> c_read_port<span class="op">(</span>inP<span class="op">);</span></span>
<span id="cb146-9"><a href="#cb146-9" aria-hidden="true" tabindex="-1"></a>   c_write_port<span class="op">(</span>outP<span class="op">,</span>val<span class="op">);</span></span>
<span id="cb146-10"><a href="#cb146-10" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h4 id="hardware-software-co-simulation">Hardware-software co-simulation</h4>
<p>As long as your programs a correctly described and the software files provided (and compiled in the case of C), the hardware-software co-simulation will be automatically performed when executing the HDLRuby simulator.</p>
<h5 id="compiling-the-c-code">Compiling the C code</h5>
<p>While programs in Ruby can be used directly, programs in C must be compiled first. For that purpose, the required files, including the hardware interface <code>cHDL.h</code>, must be generated. This is done by using the following HDLRruby command:</p>
<div class="sourceCode" id="cb147"><pre class="sourceCode bash"><code class="sourceCode bash"><span id="cb147-1"><a href="#cb147-1" aria-hidden="true" tabindex="-1"></a><span class="ex">hdrcc</span> <span class="at">--ch</span> <span class="op">&lt;</span>destination project<span class="op">&gt;</span></span></code></pre></div>
<p>In the command above, <code>&lt;destination project&gt;</code> is both the directory where the C code is and the name of the resulting shared library.</p>
<p>For example, if you want to compile the code located in the directory <code>echo</code> you need first to execute:</p>
<div class="sourceCode" id="cb148"><pre class="sourceCode bash"><code class="sourceCode bash"><span id="cb148-1"><a href="#cb148-1" aria-hidden="true" tabindex="-1"></a><span class="ex">hdrcc</span> <span class="at">--ch</span> echo</span></code></pre></div>
<p>Then, you will have to put your C files into the resulting directory and go inside it for compiling. If you have some specific needs for this compiling, or if you do not want to rely on the Ruby environment, you can compile your program there as a shared library like any other project. For example, if you are using GCC, you could type (after entering the <code>echo</code> directory):</p>
<div class="sourceCode" id="cb149"><pre class="sourceCode bash"><code class="sourceCode bash"><span id="cb149-1"><a href="#cb149-1" aria-hidden="true" tabindex="-1"></a><span class="fu">gcc</span> <span class="at">-shared</span> <span class="at">-fPIC</span> <span class="at">-undefined</span> dynamic_lookup  <span class="at">-o</span> c_program.so echo.c</span></code></pre></div>
<p>The command above is for compiling a single file project on a Linux system.</p>
<p>Otherwise, it may be easier to use the Ruby environment by first installing <code>rake-compiler</code> as follows:</p>
<div class="sourceCode" id="cb150"><pre class="sourceCode bash"><code class="sourceCode bash"><span id="cb150-1"><a href="#cb150-1" aria-hidden="true" tabindex="-1"></a><span class="ex">gem</span> install rake-compiler</span></code></pre></div>
<p>And simply type the following command (after entering the <code>echo</code> directory):</p>
<div class="sourceCode" id="cb151"><pre class="sourceCode bash"><code class="sourceCode bash"><span id="cb151-1"><a href="#cb151-1" aria-hidden="true" tabindex="-1"></a><span class="ex">rake</span> compile</span></code></pre></div>
<p>The rake tool will take care of everything for performing the compiling whatever your system may be.</p>
<h4 id="hardware-generation">Hardware generation</h4>
<p>In the current stage, HDLRuby only generates the hardware part of a description. E.g., when generating Verilog, the programs are simply being ignored. It is therefore up to the user to provide additional code for implementing the hardware-software interface. The reason is that such interfaces are target-dependent, and often comprise licensed software and IP components that cannot be integrated into HDLruby.</p>
<p>This is less a limitation than it seems since it is possible to write program constructs that wrap such accesses so that the software and HDLRuby code can be used as is in the target system. As an illustration, you can consult the example given in the tutorial: <a href="tuto/tutorial_sw.md#7-6-hardware-software-co-synthesis">7.6. Hardware-software co-synthesis</a>.</p>
<h3 id="extended-co-simulation">Extended co-simulation</h3>
<p>Since HDLRuby programs can support any compiled software, these components can also be used for executing any kind of application that is not specifically meant to be executed on the target CPU. For instance, some peripheral circuits like a keyboard or a monitor can be modeled using an HDLRuby program, as illustrated in the HDLRuby sample <code>with_program_ruby_cpu.rb</code>.</p>
<h3 id="development-board-simulation-graphical-interface">Development board simulation graphical interface</h3>
<p>HDLRuby provides a web browser-based GUI for the simulator as an extension of the co-design platform presented in this section. This GUI is to be declared as follows within a module:</p>
<div class="sourceCode" id="cb152"><pre class="sourceCode ruby"><code class="sourceCode ruby"><span id="cb152-1"><a href="#cb152-1" aria-hidden="true" tabindex="-1"></a>board(:<span class="kw">&lt;</span>board name<span class="kw">&gt;</span>,<span class="kw">&lt;</span>server port<span class="kw">&gt;</span>) <span class="cf">do</span></span>
<span id="cb152-2"><a href="#cb152-2" aria-hidden="true" tabindex="-1"></a>  actport <span class="kw">&lt;</span>event<span class="kw">&gt;</span></span>
<span id="cb152-3"><a href="#cb152-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">&lt;</span>description of the <span class="cn">GUI</span><span class="kw">&gt;</span></span>
<span id="cb152-4"><a href="#cb152-4" aria-hidden="true" tabindex="-1"></a><span class="cf">end</span></span></code></pre></div>
<p>In the code above, <code>board name</code> is the name of the board, <code>server port</code> is the local port the browser has to connect to for accessing the GUI (by default it is set to 8000), and <code>event</code> is the event (e.g., the rising edge of a clock) that activates the synchronization of the GUI with the simulator.</p>
<p>Then the description of the GUI consists of a list of the following possible development board-oriented elements. Active elements are to be given a name and attached to a HDLRuby signal as follows:</p>
<div class="sourceCode" id="cb153"><pre class="sourceCode ruby"><code class="sourceCode ruby"><span id="cb153-1"><a href="#cb153-1" aria-hidden="true" tabindex="-1"></a><span class="kw">&lt;</span>element<span class="kw">&gt;</span> <span class="kw">&lt;</span>element name<span class="kw">&gt;</span>: <span class="kw">&lt;</span><span class="dt">HDLRuby</span> signal<span class="kw">&gt;</span></span></code></pre></div>
<p>The list of possible elements is as follows:</p>
<ul>
<li><p><code>sw</code>: represents a set of slide switches, their number is set to match the bit-width of the attached signal.</p></li>
<li><p><code>bt</code>: represents a set of push buttons, their number is set to match the bit-width of the attached signal.</p></li>
<li><p><code>led</code>: represents a set of LEDs, their number is set to match the bit-width of the attached signal.</p></li>
<li><p><code>hexa</code>: represents a hexadecimal number display, its character width is set to match the width of the largest possible value of the attached signal.</p></li>
<li><p><code>digit</code>: represents a decimal number display, its character width is set to match the width of the largest possible positive or the smallest possible negative value of the attached signal.</p></li>
<li><p><code>scope</code>: represents an oscilloscope display, the vertical axis represents the value of the attached signal, its range is determined by its data type, and the horizontal axis represents the time is number of synchronization of the GUI.</p></li>
<li><p><code>row</code>: inserts a new line in the GUI.</p></li>
</ul>
<p>For example, for a GUI presenting an interface to an adder with input signals <code>x</code> and <code>y</code> and output signal <code>z</code> displayed as LEDs, a digit display, and an oscilloscope, the following description can be used:</p>
<div class="sourceCode" id="cb154"><pre class="sourceCode ruby"><code class="sourceCode ruby"><span id="cb154-1"><a href="#cb154-1" aria-hidden="true" tabindex="-1"></a><span class="fu">system</span> <span class="wa">:adder_with_gui</span> <span class="cf">do</span></span>
<span id="cb154-2"><a href="#cb154-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">[</span><span class="dv">8</span><span class="kw">]</span><span class="at">.inner</span> <span class="wa">:x</span>, <span class="wa">:y</span>, <span class="wa">:z</span></span>
<span id="cb154-3"><a href="#cb154-3" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb154-4"><a href="#cb154-4" aria-hidden="true" tabindex="-1"></a>  z <span class="kw">&lt;=</span> x <span class="kw">+</span> y</span>
<span id="cb154-5"><a href="#cb154-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb154-6"><a href="#cb154-6" aria-hidden="true" tabindex="-1"></a>  inner <span class="wa">:gui_sync</span></span>
<span id="cb154-7"><a href="#cb154-7" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb154-8"><a href="#cb154-8" aria-hidden="true" tabindex="-1"></a>  board(<span class="wa">:adder_gui</span>) <span class="cf">do</span></span>
<span id="cb154-9"><a href="#cb154-9" aria-hidden="true" tabindex="-1"></a>    actport gui_sync<span class="at">.posedge</span></span>
<span id="cb154-10"><a href="#cb154-10" aria-hidden="true" tabindex="-1"></a>    sw <span class="wa">x: </span>x</span>
<span id="cb154-11"><a href="#cb154-11" aria-hidden="true" tabindex="-1"></a>    sw <span class="wa">y: </span>y</span>
<span id="cb154-12"><a href="#cb154-12" aria-hidden="true" tabindex="-1"></a>    row</span>
<span id="cb154-13"><a href="#cb154-13" aria-hidden="true" tabindex="-1"></a>    led <span class="wa">z_led: </span>z</span>
<span id="cb154-14"><a href="#cb154-14" aria-hidden="true" tabindex="-1"></a>    digit <span class="wa">z_digit: </span>z</span>
<span id="cb154-15"><a href="#cb154-15" aria-hidden="true" tabindex="-1"></a>    row</span>
<span id="cb154-16"><a href="#cb154-16" aria-hidden="true" tabindex="-1"></a>    scope <span class="wa">z_scope: </span>z</span>
<span id="cb154-17"><a href="#cb154-17" aria-hidden="true" tabindex="-1"></a>  <span class="cf">end</span></span>
<span id="cb154-18"><a href="#cb154-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb154-19"><a href="#cb154-19" aria-hidden="true" tabindex="-1"></a>  timed <span class="cf">do</span></span>
<span id="cb154-20"><a href="#cb154-20" aria-hidden="true" tabindex="-1"></a>    clk <span class="kw">&lt;=</span> <span class="dv">0</span></span>
<span id="cb154-21"><a href="#cb154-21" aria-hidden="true" tabindex="-1"></a>    repeat(<span class="dv">10000</span>) <span class="cf">do</span></span>
<span id="cb154-22"><a href="#cb154-22" aria-hidden="true" tabindex="-1"></a>      !<span class="dv">10</span><span class="at">.ns</span></span>
<span id="cb154-23"><a href="#cb154-23" aria-hidden="true" tabindex="-1"></a>      clk <span class="kw">&lt;=</span> <span class="kw">~</span>clk</span>
<span id="cb154-24"><a href="#cb154-24" aria-hidden="true" tabindex="-1"></a>    <span class="cf">end</span></span>
<span id="cb154-25"><a href="#cb154-25" aria-hidden="true" tabindex="-1"></a>  <span class="cf">end</span></span>
<span id="cb154-26"><a href="#cb154-26" aria-hidden="true" tabindex="-1"></a><span class="cf">end</span></span></code></pre></div>
<p>With the code above, the GUI will show a row containing two sets of slide switches for input <code>x</code> and <code>y</code>, a row containing a set of LEDs and a digital display for showing <code>z</code>, and a row containing an oscilloscope for showing the evolution <code>z</code>.</p>
<p>This code is simulated exactly like any other HDLRuby description, e.g., the following command will start the simulation and generate a VCD wave file:</p>
<div class="sourceCode" id="cb155"><pre class="sourceCode bash"><code class="sourceCode bash"><span id="cb155-1"><a href="#cb155-1" aria-hidden="true" tabindex="-1"></a><span class="ex">hdrcc</span> <span class="at">--sim</span> <span class="at">--vcd</span> my_adder.rb my_adder</span></code></pre></div>
<p>However, the simulator will wait until a browser connects to it. For that, you can open a web browser, and go to the local url: <code>http://localhost:8000</code>. The simulation will then start and you can interact with the GUI.</p>
<h2 id="time">Time</h2>
<h3 id="time-values">Time values</h3>
<p><a name="time_val"></a></p>
<p>In HDLRuby, time values can be created using the time operators: <code>s</code> for seconds, <code>ms</code> for a millisecond, <code>us</code> for microseconds, <code>ns</code> for nanoseconds, <code>ps</code> for picoseconds. For example, the following are all indicating one second:</p>
<div class="sourceCode" id="cb156"><pre class="sourceCode ruby"><code class="sourceCode ruby"><span id="cb156-1"><a href="#cb156-1" aria-hidden="true" tabindex="-1"></a><span class="dv">1</span><span class="at">.s</span></span>
<span id="cb156-2"><a href="#cb156-2" aria-hidden="true" tabindex="-1"></a><span class="dv">1000</span><span class="at">.ms</span></span>
<span id="cb156-3"><a href="#cb156-3" aria-hidden="true" tabindex="-1"></a><span class="dv">1000000</span><span class="at">.us</span></span>
<span id="cb156-4"><a href="#cb156-4" aria-hidden="true" tabindex="-1"></a><span class="dv">1000000000</span><span class="at">.ns</span></span>
<span id="cb156-5"><a href="#cb156-5" aria-hidden="true" tabindex="-1"></a><span class="dv">1000000000000</span><span class="at">.ps</span></span></code></pre></div>
<h3 id="time-behaviors-and-time-statements">Time behaviors and time statements</h3>
<p><a name="time_beh"></a></p>
<p>Like the other HDL, HDLRuby provides specific statements that model the advance of time. These statements are not synthesizable and are used for simulating the environment of a hardware component. For the sake of clarity, such statements are only allowed in explicitly non-synthesizable behavior declared using the <code>timed</code> keyword as follows.</p>
<div class="sourceCode" id="cb157"><pre class="sourceCode ruby"><code class="sourceCode ruby"><span id="cb157-1"><a href="#cb157-1" aria-hidden="true" tabindex="-1"></a>timed <span class="cf">do</span></span>
<span id="cb157-2"><a href="#cb157-2" aria-hidden="true" tabindex="-1"></a>   <span class="kw">&lt;</span>statements<span class="kw">&gt;</span></span>
<span id="cb157-3"><a href="#cb157-3" aria-hidden="true" tabindex="-1"></a><span class="cf">end</span></span></code></pre></div>
<p>A time behavior does not have any sensitivity list, but it can include any statement supported by a standard behavior in addition to the time statements. There are two kinds of such statements:</p>
<ul>
<li><p>The <code>wait</code> statements: such a statement blocks the execution of the behavior for the time given in the argument. For example, the following code waits for 10ns before proceeding:</p>
<div class="sourceCode" id="cb158"><pre class="sourceCode ruby"><code class="sourceCode ruby"><span id="cb158-1"><a href="#cb158-1" aria-hidden="true" tabindex="-1"></a>   wait(<span class="dv">10</span><span class="at">.ns</span>)</span></code></pre></div>
<p>This statement can also be abbreviated using the <code>!</code> operator as follows:</p>
<div class="sourceCode" id="cb159"><pre class="sourceCode ruby"><code class="sourceCode ruby"><span id="cb159-1"><a href="#cb159-1" aria-hidden="true" tabindex="-1"></a>   !<span class="dv">10</span><span class="at">.ns</span></span></code></pre></div></li>
<li><p>The <code>repeat</code> statements: such a statement takes as argument the number of iterations and a block. The execution of the block is repeated the given number of times. For example, the following code executes 10 times the inversion of the <code>clk</code> signal every 10 nanoseconds:</p>
<div class="sourceCode" id="cb160"><pre class="sourceCode ruby"><code class="sourceCode ruby"><span id="cb160-1"><a href="#cb160-1" aria-hidden="true" tabindex="-1"></a>   repeat(<span class="dv">10</span>) <span class="cf">do</span> </span>
<span id="cb160-2"><a href="#cb160-2" aria-hidden="true" tabindex="-1"></a>      !<span class="dv">10</span><span class="at">.ns</span></span>
<span id="cb160-3"><a href="#cb160-3" aria-hidden="true" tabindex="-1"></a>      clk <span class="kw">&lt;=</span> <span class="kw">~</span>clk</span>
<span id="cb160-4"><a href="#cb160-4" aria-hidden="true" tabindex="-1"></a>   <span class="cf">end</span></span></code></pre></div></li>
</ul>
<p><strong>Note:</strong></p>
<p>This statement is not synthesizable and therefore can only be used in timed behaviors.</p>
<h3 id="parallel-and-sequential-execution">Parallel and sequential execution</h3>
<p>Time behaviors are by default sequential, but they can include both parallel and sequential blocks. The execution semantic is the following:</p>
<ul>
<li><p>A sequential block in a time behavior is executed sequentially.</p></li>
<li><p>A parallel block in a time behavior is executed in a semi-parallel fashion as follows:</p>
<ol type="1">
<li><p>Statements are grouped in sequence until a time statement is met.</p></li>
<li><p>The grouped sequences are executed in parallel.</p></li>
<li><p>The time statement is executed.</p></li>
<li><p>The subsequent statements are processed the same way.</p></li>
</ol></li>
</ul>
<h2 id="high-level-programming-features">High-level programming features</h2>
<h3 id="using-ruby-in-hdlruby">Using Ruby in HDLRuby</h3>
<p>Since HDLRuby is pure Ruby code, the constructs of Ruby can be freely used without any compatibility issues. Moreover, this Ruby code will not interfere with the synthesizability of the design. It is then possible to define Ruby classes, methods, or modules whose execution generates constructs of HDLRuby.</p>
<h3 id="generic-programming">Generic programming</h3>
<h4 id="declaring">Declaring</h4>
<h5 id="declaring-generic-systems">Declaring generic systems</h5>
<p>Systems can be declared with generic parameters as follows:</p>
<div class="sourceCode" id="cb161"><pre class="sourceCode ruby"><code class="sourceCode ruby"><span id="cb161-1"><a href="#cb161-1" aria-hidden="true" tabindex="-1"></a><span class="fu">system</span> :<span class="kw">&lt;</span><span class="fu">system</span> name<span class="kw">&gt;</span> <span class="cf">do</span> <span class="kw">|&lt;</span>list of generic parameters<span class="kw">&gt;|</span></span>
<span id="cb161-2"><a href="#cb161-2" aria-hidden="true" tabindex="-1"></a>   <span class="kw">...</span></span>
<span id="cb161-3"><a href="#cb161-3" aria-hidden="true" tabindex="-1"></a><span class="cf">end</span></span></code></pre></div>
<p>For example, the following code describes an empty system with two generic parameters named respectively <code>a</code> and <code>b</code>:</p>
<div class="sourceCode" id="cb162"><pre class="sourceCode ruby"><code class="sourceCode ruby"><span id="cb162-1"><a href="#cb162-1" aria-hidden="true" tabindex="-1"></a><span class="fu">system</span>(<span class="wa">:nothing</span>) <span class="kw">{</span> <span class="kw">|</span>a,b<span class="kw">|</span> <span class="kw">}</span></span></code></pre></div>
<p>The generic parameters can be anything: values, data types, signals, systems, Ruby variables, and so on. For example, the following system uses generic argument <code>t</code> as a type for an input signal, generic argument <code>w</code> as a bit range for an output signal, and generic argument <code>s</code> as a system used for creating instance <code>sI</code> whose input and output signals <code>i</code> and <code>o</code> are connected respectively to signals <code>isig</code> and <code>osig</code>.</p>
<div class="sourceCode" id="cb163"><pre class="sourceCode ruby"><code class="sourceCode ruby"><span id="cb163-1"><a href="#cb163-1" aria-hidden="true" tabindex="-1"></a><span class="fu">system</span> <span class="wa">:something</span> <span class="cf">do</span> <span class="kw">|</span>t,w,s<span class="kw">|</span></span>
<span id="cb163-2"><a href="#cb163-2" aria-hidden="true" tabindex="-1"></a>   t<span class="at">.input</span> isig</span>
<span id="cb163-3"><a href="#cb163-3" aria-hidden="true" tabindex="-1"></a>   <span class="kw">[</span>w<span class="kw">]</span><span class="at">.output</span> osig</span>
<span id="cb163-4"><a href="#cb163-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb163-5"><a href="#cb163-5" aria-hidden="true" tabindex="-1"></a>   s <span class="wa">:sI</span><span class="kw">.</span>(<span class="wa">i: </span>isig, <span class="wa">o: </span>osig)</span>
<span id="cb163-6"><a href="#cb163-6" aria-hidden="true" tabindex="-1"></a><span class="cf">end</span></span></code></pre></div>
<p>It is also possible to use a variable number of generic parameters using the variadic operator <code>*</code> like in the following example. In this example, <code>args</code> is an array containing an indefinite number of parameters.</p>
<div class="sourceCode" id="cb164"><pre class="sourceCode ruby"><code class="sourceCode ruby"><span id="cb164-1"><a href="#cb164-1" aria-hidden="true" tabindex="-1"></a><span class="fu">system</span>(<span class="wa">:variadic</span>) <span class="kw">{</span> <span class="kw">|*</span>args<span class="kw">|</span> <span class="kw">}</span></span></code></pre></div>
<h5 id="declaring-generic-types">Declaring generic types</h5>
<p>Data types can be declared with generic parameters as follows:</p>
<div class="sourceCode" id="cb165"><pre class="sourceCode ruby"><code class="sourceCode ruby"><span id="cb165-1"><a href="#cb165-1" aria-hidden="true" tabindex="-1"></a>typedef :<span class="kw">&lt;</span>type name<span class="kw">&gt;</span> <span class="cf">do</span> <span class="kw">|&lt;</span>list of generic parameters<span class="kw">&gt;|</span></span>
<span id="cb165-2"><a href="#cb165-2" aria-hidden="true" tabindex="-1"></a>   <span class="kw">...</span></span>
<span id="cb165-3"><a href="#cb165-3" aria-hidden="true" tabindex="-1"></a><span class="cf">end</span></span></code></pre></div>
<p>For example, the following code describes a bit-vector type with a generic number of bits <code>width</code>:</p>
<div class="sourceCode" id="cb166"><pre class="sourceCode ruby"><code class="sourceCode ruby"><span id="cb166-1"><a href="#cb166-1" aria-hidden="true" tabindex="-1"></a>type(<span class="wa">:bitvec</span>) <span class="kw">{</span> <span class="kw">|</span>width<span class="kw">|</span> bit<span class="kw">[</span>width<span class="kw">]</span> <span class="kw">}</span></span></code></pre></div>
<p>Like with the systems, the generic parameters of types can be any kind of object, and it is also possible to use variadic arguments.</p>
<h4 id="specializing">Specializing</h4>
<h5 id="specializing-generic-systems">Specializing generic systems</h5>
<p>A generic system is specialized by invoking its name and passing as an argument the values corresponding to the generic arguments as follows:</p>
<div class="sourceCode" id="cb167"><pre class="sourceCode ruby"><code class="sourceCode ruby"><span id="cb167-1"><a href="#cb167-1" aria-hidden="true" tabindex="-1"></a><span class="kw">&lt;</span><span class="fu">system</span> name<span class="kw">&gt;</span>(<span class="kw">&lt;</span>generic argument value<span class="vs">&#39;s list&gt;)</span></span></code></pre></div>
<p>If fewer values are provided than the number of generic arguments, the system is partially specialized. However, only a fully specialized system can be instantiated.</p>
<p>A specialized system can also be used for inheritance. For example, assuming system <code>sys</code> has 2 generic arguments, it can be specialized and used for building system <code>subsys</code> as follows:</p>
<div class="sourceCode" id="cb168"><pre class="sourceCode ruby"><code class="sourceCode ruby"><span id="cb168-1"><a href="#cb168-1" aria-hidden="true" tabindex="-1"></a><span class="fu">system</span> <span class="wa">:subsys</span>, sys(<span class="dv">1</span>,<span class="dv">2</span>) <span class="cf">do</span></span>
<span id="cb168-2"><a href="#cb168-2" aria-hidden="true" tabindex="-1"></a>   <span class="kw">...</span></span>
<span id="cb168-3"><a href="#cb168-3" aria-hidden="true" tabindex="-1"></a><span class="cf">end</span></span></code></pre></div>
<p>This way of inheriting can only be done with fully specialized systems though. For partially specialized systems, <code>include</code> must be used instead. For example, if <code>sys</code> is specialized with only one value, can be used in generic <code>subsys_gen</code> as follows:</p>
<div class="sourceCode" id="cb169"><pre class="sourceCode ruby"><code class="sourceCode ruby"><span id="cb169-1"><a href="#cb169-1" aria-hidden="true" tabindex="-1"></a><span class="fu">system</span> <span class="wa">:subsys_gen</span> <span class="cf">do</span> <span class="kw">|</span>param<span class="kw">|</span></span>
<span id="cb169-2"><a href="#cb169-2" aria-hidden="true" tabindex="-1"></a>   <span class="fu">include</span> sys(<span class="dv">1</span>,param)</span>
<span id="cb169-3"><a href="#cb169-3" aria-hidden="true" tabindex="-1"></a>   <span class="kw">...</span></span>
<span id="cb169-4"><a href="#cb169-4" aria-hidden="true" tabindex="-1"></a><span class="cf">end</span></span></code></pre></div>
<p><strong>Note:</strong></p>
<ul>
<li>In the example above, the generic parameter <code>param</code> of <code>subsys_gen</code> is used for specializing system <code>sys</code>.</li>
</ul>
<h5 id="specializing-generic-types">Specializing generic types</h5>
<p>A generic type is specialized by invoking its name and passing as an argument the values corresponding to the generic arguments as follows:</p>
<div class="sourceCode" id="cb170"><pre class="sourceCode ruby"><code class="sourceCode ruby"><span id="cb170-1"><a href="#cb170-1" aria-hidden="true" tabindex="-1"></a><span class="kw">&lt;</span>type name<span class="kw">&gt;</span>(<span class="kw">&lt;</span>generic argument value<span class="vs">&#39;s list&gt;)</span></span></code></pre></div>
<p>If fewer values are provided than the number of generic arguments, the type is partially specialized. However, only a fully specialized type can be used for declaring signals.</p>
<h5 id="use-of-signals-as-generic-parameters">Use of signals as generic parameters</h5>
<p>Signals passed as generic arguments to systems can be used for making generic connections to the instance of the system. For that purpose, the generic argument has to be declared as input, output, or inout port in the body of the system as follows:</p>
<div class="sourceCode" id="cb171"><pre class="sourceCode ruby"><code class="sourceCode ruby"><span id="cb171-1"><a href="#cb171-1" aria-hidden="true" tabindex="-1"></a><span class="fu">system</span> :<span class="kw">&lt;</span>system_name<span class="kw">&gt;</span> <span class="cf">do</span> <span class="kw">|</span>sig<span class="kw">|</span></span>
<span id="cb171-2"><a href="#cb171-2" aria-hidden="true" tabindex="-1"></a>   sig<span class="at">.input</span> <span class="wa">:my_sig</span></span>
<span id="cb171-3"><a href="#cb171-3" aria-hidden="true" tabindex="-1"></a>   <span class="kw">...</span></span>
<span id="cb171-4"><a href="#cb171-4" aria-hidden="true" tabindex="-1"></a><span class="cf">end</span></span></code></pre></div>
<p>In the code above, <code>sig</code> is a generic argument assumed to be a signal. The second line declares the port to which sig will be connected to when instantiating. From there, port <code>my_sig</code> can be used like any other port of the system. Such a system is then instantiated as follows:</p>
<div class="sourceCode" id="cb172"><pre class="sourceCode ruby"><code class="sourceCode ruby"><span id="cb172-1"><a href="#cb172-1" aria-hidden="true" tabindex="-1"></a>system_name(some_sig) :<span class="kw">&lt;</span>instance_name<span class="kw">&gt;</span></span></code></pre></div>
<p>In the code above, <code>some_sig</code> is a signal available in the current context. This instantiation automatically connects <code>some_sig</code> to the instance.</p>
<h3 id="inheritance">Inheritance</h3>
<p><a name="inherit"></a></p>
<h4 id="basics">Basics</h4>
<p>In HDLRuby, a system can inherit from the content of one or several other parent systems using the <code>include</code> command as follows: <code>include &lt;list of systems&gt;</code>. Such an include can be put anywhere in the body of a system, but the resulting content will be accessible only after this command.</p>
<p>For example, the following code describes first a simple D-FF, and then uses it to describe a FF with an additional reversed output (<code>qb</code>):</p>
<div class="sourceCode" id="cb173"><pre class="sourceCode ruby"><code class="sourceCode ruby"><span id="cb173-1"><a href="#cb173-1" aria-hidden="true" tabindex="-1"></a><span class="fu">system</span> <span class="wa">:dff</span> <span class="cf">do</span></span>
<span id="cb173-2"><a href="#cb173-2" aria-hidden="true" tabindex="-1"></a>   input <span class="wa">:clk</span>, <span class="wa">:rst</span>, <span class="wa">:d</span></span>
<span id="cb173-3"><a href="#cb173-3" aria-hidden="true" tabindex="-1"></a>   output <span class="wa">:q</span></span>
<span id="cb173-4"><a href="#cb173-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb173-5"><a href="#cb173-5" aria-hidden="true" tabindex="-1"></a>   par(clk<span class="at">.posedge</span>) <span class="kw">{</span> q <span class="kw">&lt;=</span> d <span class="kw">&amp;</span> <span class="kw">~</span>rst <span class="kw">}</span></span>
<span id="cb173-6"><a href="#cb173-6" aria-hidden="true" tabindex="-1"></a><span class="cf">end</span></span>
<span id="cb173-7"><a href="#cb173-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb173-8"><a href="#cb173-8" aria-hidden="true" tabindex="-1"></a><span class="fu">system</span> <span class="wa">:dff_full</span> <span class="cf">do</span></span>
<span id="cb173-9"><a href="#cb173-9" aria-hidden="true" tabindex="-1"></a>    output <span class="wa">:qb</span></span>
<span id="cb173-10"><a href="#cb173-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb173-11"><a href="#cb173-11" aria-hidden="true" tabindex="-1"></a>    <span class="fu">include</span> dff</span>
<span id="cb173-12"><a href="#cb173-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb173-13"><a href="#cb173-13" aria-hidden="true" tabindex="-1"></a>    qb <span class="kw">&lt;=</span> <span class="kw">~</span>q</span>
<span id="cb173-14"><a href="#cb173-14" aria-hidden="true" tabindex="-1"></a><span class="cf">end</span></span></code></pre></div>
<p>It is also possible to declare inheritance in a more object-oriented fashion by listing the parents of a system just after declaring its name as follows:</p>
<div class="sourceCode" id="cb174"><pre class="sourceCode ruby"><code class="sourceCode ruby"><span id="cb174-1"><a href="#cb174-1" aria-hidden="true" tabindex="-1"></a><span class="fu">system</span> :<span class="kw">&lt;</span>new <span class="fu">system</span> name<span class="kw">&gt;</span>, <span class="kw">&lt;</span>list of parent systems<span class="kw">&gt;</span> <span class="cf">do</span></span>
<span id="cb174-2"><a href="#cb174-2" aria-hidden="true" tabindex="-1"></a>   <span class="kw">&lt;</span>additional <span class="fu">system</span> code<span class="kw">&gt;</span></span>
<span id="cb174-3"><a href="#cb174-3" aria-hidden="true" tabindex="-1"></a><span class="cf">end</span></span></code></pre></div>
<p>For example, the following code is another to describe <code>dff_full</code>:</p>
<div class="sourceCode" id="cb175"><pre class="sourceCode ruby"><code class="sourceCode ruby"><span id="cb175-1"><a href="#cb175-1" aria-hidden="true" tabindex="-1"></a><span class="fu">system</span> <span class="wa">:dff_full</span>, dff <span class="cf">do</span></span>
<span id="cb175-2"><a href="#cb175-2" aria-hidden="true" tabindex="-1"></a>   output <span class="wa">:qb</span></span>
<span id="cb175-3"><a href="#cb175-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb175-4"><a href="#cb175-4" aria-hidden="true" tabindex="-1"></a>   qb <span class="kw">&lt;=</span> <span class="kw">~</span>q</span>
<span id="cb175-5"><a href="#cb175-5" aria-hidden="true" tabindex="-1"></a><span class="cf">end</span></span></code></pre></div>
<p><strong>Note</strong>:</p>
<ul>
<li>As a matter of implementation, HDLRuby systems can be viewed as sets of methods used for accessing various constructs (signals, instances). Hence inheritance in HDLRuby is closer to the Ruby mixin mechanism than to a true software inheritance.</li>
</ul>
<h4 id="about-inner-signals-and-system-instances">About inner signals and system instances</h4>
<p>By default, inner signals and instances of a parent system are not accessible by its child systems. They can be made accessible using the <code>export</code> keyword as follows: <code>export &lt;symbol 0&gt;, &lt;symbol 1&gt;, ...</code>. For example, the following code exports signals <code>clk</code> and <code>rst</code> and instance <code>dff0</code> of system <code>exporter</code> so that they can be accessed in child system <code>importer</code>.</p>
<div class="sourceCode" id="cb176"><pre class="sourceCode ruby"><code class="sourceCode ruby"><span id="cb176-1"><a href="#cb176-1" aria-hidden="true" tabindex="-1"></a><span class="fu">system</span> <span class="wa">:exporter</span> <span class="cf">do</span></span>
<span id="cb176-2"><a href="#cb176-2" aria-hidden="true" tabindex="-1"></a>   input <span class="wa">:d</span></span>
<span id="cb176-3"><a href="#cb176-3" aria-hidden="true" tabindex="-1"></a>   inner <span class="wa">:clk</span>, <span class="wa">:rst</span></span>
<span id="cb176-4"><a href="#cb176-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb176-5"><a href="#cb176-5" aria-hidden="true" tabindex="-1"></a>   dff(<span class="wa">:dff0</span>)<span class="kw">.</span>(<span class="wa">clk: </span>clk, <span class="wa">rst: </span>rst, <span class="wa">d: </span>d)</span>
<span id="cb176-6"><a href="#cb176-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb176-7"><a href="#cb176-7" aria-hidden="true" tabindex="-1"></a>   export <span class="wa">:clk</span>, <span class="wa">:rst</span>, <span class="wa">:dff0</span> </span>
<span id="cb176-8"><a href="#cb176-8" aria-hidden="true" tabindex="-1"></a><span class="cf">end</span></span>
<span id="cb176-9"><a href="#cb176-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb176-10"><a href="#cb176-10" aria-hidden="true" tabindex="-1"></a><span class="fu">system</span> <span class="wa">:importer</span>, exporter <span class="cf">do</span></span>
<span id="cb176-11"><a href="#cb176-11" aria-hidden="true" tabindex="-1"></a>   input <span class="wa">:clk0</span>, <span class="wa">:rst0</span></span>
<span id="cb176-12"><a href="#cb176-12" aria-hidden="true" tabindex="-1"></a>   output <span class="wa">:q</span></span>
<span id="cb176-13"><a href="#cb176-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb176-14"><a href="#cb176-14" aria-hidden="true" tabindex="-1"></a>   clk <span class="kw">&lt;=</span> clk0</span>
<span id="cb176-15"><a href="#cb176-15" aria-hidden="true" tabindex="-1"></a>   rst <span class="kw">&lt;=</span> rst0</span>
<span id="cb176-16"><a href="#cb176-16" aria-hidden="true" tabindex="-1"></a>   dff0<span class="at">.q</span> <span class="kw">&lt;=</span> q</span>
<span id="cb176-17"><a href="#cb176-17" aria-hidden="true" tabindex="-1"></a><span class="cf">end</span></span></code></pre></div>
<p><strong>Note</strong>: - export takes as arguments the symbols (or the strings) representing the name of the components to export <em>and not</em> a reference to them. For instance, the following code is invalid:</p>
<div class="sourceCode" id="cb177"><pre class="sourceCode ruby"><code class="sourceCode ruby"><span id="cb177-1"><a href="#cb177-1" aria-hidden="true" tabindex="-1"></a><span class="fu">system</span> <span class="wa">:exporter</span> <span class="cf">do</span></span>
<span id="cb177-2"><a href="#cb177-2" aria-hidden="true" tabindex="-1"></a>   input <span class="wa">:d</span></span>
<span id="cb177-3"><a href="#cb177-3" aria-hidden="true" tabindex="-1"></a>   inner <span class="wa">:clk</span>, <span class="wa">:rst</span></span>
<span id="cb177-4"><a href="#cb177-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb177-5"><a href="#cb177-5" aria-hidden="true" tabindex="-1"></a>   dff(<span class="wa">:dff0</span>)<span class="kw">.</span>(<span class="wa">clk: </span>clk, <span class="wa">rst: </span>rst, <span class="wa">d: </span>d)</span>
<span id="cb177-6"><a href="#cb177-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb177-7"><a href="#cb177-7" aria-hidden="true" tabindex="-1"></a>   export clk, rst, dff0 </span>
<span id="cb177-8"><a href="#cb177-8" aria-hidden="true" tabindex="-1"></a><span class="cf">end</span></span></code></pre></div>
<h4 id="conflicts-when-inheriting">Conflicts when inheriting</h4>
<p>Signals and instances cannot be overridden, this is also the case for signals and instances accessible through inheritance. For example, the following code is invalid since <code>rst</code> has already been defined in <code>dff</code>:</p>
<div class="sourceCode" id="cb178"><pre class="sourceCode ruby"><code class="sourceCode ruby"><span id="cb178-1"><a href="#cb178-1" aria-hidden="true" tabindex="-1"></a>   <span class="fu">system</span> <span class="wa">:dff_bad</span>, dff <span class="cf">do</span></span>
<span id="cb178-2"><a href="#cb178-2" aria-hidden="true" tabindex="-1"></a>      input <span class="wa">:rst</span></span>
<span id="cb178-3"><a href="#cb178-3" aria-hidden="true" tabindex="-1"></a>   <span class="cf">end</span></span></code></pre></div>
<p>Conflicts among several inherited systems can be avoided by renaming the signals and instances that collide with one another as shown in the next section.</p>
<h4 id="shadowed-signals-and-instances">Shadowed signals and instances</h4>
<p>It is possible in HDLRuby to declare a signal or an instance whose name is identical to the one used in one of the included systems. In such a case, the corresponding construct of the included system is still present, but it is not directly accessible even if exported, they are said to be shadowed.</p>
<p>To access the shadowed signals or instances, a system must be reinterpreted as the relevant parent system using the <code>as</code> operator as follows: <code>as(system)</code>.</p>
<p>For example, in the following code signal, <code>db</code> of system <code>dff_db</code> is shadowed by signal <code>db</code> of system <code>dff_shadow</code>, but it is accessed using the <code>as</code> operator.</p>
<div class="sourceCode" id="cb179"><pre class="sourceCode ruby"><code class="sourceCode ruby"><span id="cb179-1"><a href="#cb179-1" aria-hidden="true" tabindex="-1"></a><span class="fu">system</span> <span class="wa">:dff_db</span> <span class="cf">do</span></span>
<span id="cb179-2"><a href="#cb179-2" aria-hidden="true" tabindex="-1"></a>   input <span class="wa">:clk</span>,<span class="wa">:rst</span>,<span class="wa">:d</span></span>
<span id="cb179-3"><a href="#cb179-3" aria-hidden="true" tabindex="-1"></a>   inner <span class="wa">:db</span></span>
<span id="cb179-4"><a href="#cb179-4" aria-hidden="true" tabindex="-1"></a>   output <span class="wa">:q</span></span>
<span id="cb179-5"><a href="#cb179-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb179-6"><a href="#cb179-6" aria-hidden="true" tabindex="-1"></a>   db <span class="kw">&lt;=</span> <span class="kw">~</span>d</span>
<span id="cb179-7"><a href="#cb179-7" aria-hidden="true" tabindex="-1"></a>   (q <span class="kw">&lt;=</span> d <span class="kw">&amp;</span> <span class="kw">~</span>rst)<span class="at">.at</span>(clk<span class="at">.posedge</span>)</span>
<span id="cb179-8"><a href="#cb179-8" aria-hidden="true" tabindex="-1"></a><span class="cf">end</span></span>
<span id="cb179-9"><a href="#cb179-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb179-10"><a href="#cb179-10" aria-hidden="true" tabindex="-1"></a><span class="fu">system</span> <span class="wa">:dff_shadow</span>, dff_db <span class="cf">do</span></span>
<span id="cb179-11"><a href="#cb179-11" aria-hidden="true" tabindex="-1"></a>   output <span class="wa">:qb</span>, <span class="wa">:db</span></span>
<span id="cb179-12"><a href="#cb179-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb179-13"><a href="#cb179-13" aria-hidden="true" tabindex="-1"></a>   db <span class="kw">&lt;=</span> <span class="kw">~</span>d</span>
<span id="cb179-14"><a href="#cb179-14" aria-hidden="true" tabindex="-1"></a>   qb <span class="kw">&lt;=</span> as(dff_db)<span class="at">.db</span></span>
<span id="cb179-15"><a href="#cb179-15" aria-hidden="true" tabindex="-1"></a><span class="cf">end</span></span></code></pre></div>
<h3 id="opening-a-system">Opening a system</h3>
<p><a name="system_open"></a></p>
<p>It is possible to pursue the definition of a system after it has been declared using the <code>open</code> methods as follows:</p>
<div class="sourceCode" id="cb180"><pre class="sourceCode ruby"><code class="sourceCode ruby"><span id="cb180-1"><a href="#cb180-1" aria-hidden="true" tabindex="-1"></a><span class="kw">&lt;</span><span class="fu">system</span><span class="kw">&gt;</span><span class="at">.open</span> <span class="cf">do</span></span>
<span id="cb180-2"><a href="#cb180-2" aria-hidden="true" tabindex="-1"></a>   <span class="kw">&lt;</span>additional <span class="fu">system</span> description<span class="kw">&gt;</span></span>
<span id="cb180-3"><a href="#cb180-3" aria-hidden="true" tabindex="-1"></a><span class="cf">end</span></span></code></pre></div>
<p>For example, <code>dff</code>, a system describing a D-FF, can be modified to have an inverted output as follows:</p>
<div class="sourceCode" id="cb181"><pre class="sourceCode ruby"><code class="sourceCode ruby"><span id="cb181-1"><a href="#cb181-1" aria-hidden="true" tabindex="-1"></a>dff<span class="at">.open</span> <span class="cf">do</span></span>
<span id="cb181-2"><a href="#cb181-2" aria-hidden="true" tabindex="-1"></a>   output <span class="wa">:qb</span></span>
<span id="cb181-3"><a href="#cb181-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb181-4"><a href="#cb181-4" aria-hidden="true" tabindex="-1"></a>   qb <span class="kw">&lt;=</span> <span class="kw">~</span>q</span>
<span id="cb181-5"><a href="#cb181-5" aria-hidden="true" tabindex="-1"></a><span class="cf">end</span></span></code></pre></div>
<h3 id="opening-an-instance">Opening an instance</h3>
<p><a name="instance_open"></a></p>
<p>When there is a modification to apply to an instance, it is sometimes preferable to modify this sole instance rather than declaring a new system to derivate the instance from. For that purpose, it is possible to open an instance for modification as follows:</p>
<div class="sourceCode" id="cb182"><pre class="sourceCode ruby"><code class="sourceCode ruby"><span id="cb182-1"><a href="#cb182-1" aria-hidden="true" tabindex="-1"></a><span class="kw">&lt;</span>instance name<span class="kw">&gt;</span><span class="at">.open</span> <span class="cf">do</span></span>
<span id="cb182-2"><a href="#cb182-2" aria-hidden="true" tabindex="-1"></a>   <span class="kw">&lt;</span>additional description <span class="cf">for</span> the instance<span class="kw">&gt;</span></span>
<span id="cb182-3"><a href="#cb182-3" aria-hidden="true" tabindex="-1"></a><span class="cf">end</span></span></code></pre></div>
<p>For example, an instance of the previous <code>dff</code> system can be extended with an inverted output as follows:</p>
<div class="sourceCode" id="cb183"><pre class="sourceCode ruby"><code class="sourceCode ruby"><span id="cb183-1"><a href="#cb183-1" aria-hidden="true" tabindex="-1"></a><span class="fu">system</span> <span class="wa">:some_system</span> <span class="cf">do</span></span>
<span id="cb183-2"><a href="#cb183-2" aria-hidden="true" tabindex="-1"></a>   <span class="kw">...</span></span>
<span id="cb183-3"><a href="#cb183-3" aria-hidden="true" tabindex="-1"></a>   dff <span class="wa">:dff0</span></span>
<span id="cb183-4"><a href="#cb183-4" aria-hidden="true" tabindex="-1"></a>   dff0<span class="at">.open</span> <span class="cf">do</span></span>
<span id="cb183-5"><a href="#cb183-5" aria-hidden="true" tabindex="-1"></a>      output <span class="wa">:qb</span></span>
<span id="cb183-6"><a href="#cb183-6" aria-hidden="true" tabindex="-1"></a>      qb <span class="kw">&lt;=</span> <span class="kw">~</span>q</span>
<span id="cb183-7"><a href="#cb183-7" aria-hidden="true" tabindex="-1"></a>   <span class="cf">end</span></span>
<span id="cb183-8"><a href="#cb183-8" aria-hidden="true" tabindex="-1"></a>   <span class="kw">...</span></span>
<span id="cb183-9"><a href="#cb183-9" aria-hidden="true" tabindex="-1"></a><span class="cf">end</span></span></code></pre></div>
<h3 id="overloading-of-operators">Overloading of operators</h3>
<p>Operators can be overloaded for specific types. This allows for instance to support seamlessly fixed-point computations without requiring explicit readjustment of the position of the decimal point.</p>
<p>An operator is redefined as follows:</p>
<div class="sourceCode" id="cb184"><pre class="sourceCode ruby"><code class="sourceCode ruby"><span id="cb184-1"><a href="#cb184-1" aria-hidden="true" tabindex="-1"></a><span class="kw">&lt;</span>type<span class="kw">&gt;</span><span class="at">.define_operator</span>(:<span class="kw">&lt;</span>op<span class="kw">&gt;</span>) <span class="cf">do</span> <span class="kw">|&lt;</span>args<span class="kw">&gt;|</span></span>
<span id="cb184-2"><a href="#cb184-2" aria-hidden="true" tabindex="-1"></a>   <span class="kw">&lt;</span>operation description<span class="kw">&gt;</span></span>
<span id="cb184-3"><a href="#cb184-3" aria-hidden="true" tabindex="-1"></a><span class="cf">end</span></span></code></pre></div>
<p>Where:</p>
<ul>
<li><code>type</code> is the type from which the operation is overloaded.</li>
<li><code>op</code> is the operator that is overloaded (e.g., <code>+</code>)</li>
<li><code>args</code> are the arguments of the operation.</li>
<li><code>operation description</code> is an HDLRuby expression of the new operation.</li>
</ul>
<p>For example, for <code>fix32</code> a 32-bit (decimal point at 16-bit) fixed-point type defined as follows:</p>
<div class="sourceCode" id="cb185"><pre class="sourceCode ruby"><code class="sourceCode ruby"><span id="cb185-1"><a href="#cb185-1" aria-hidden="true" tabindex="-1"></a>signed<span class="kw">[</span><span class="dv">31</span><span class="kw">..</span><span class="dv">0</span><span class="kw">]</span><span class="at">.typedef</span>(<span class="wa">:fix32</span>)</span></code></pre></div>
<p>The multiplication operator can be overloaded as follows to ensure the decimal point have always the right position:</p>
<div class="sourceCode" id="cb186"><pre class="sourceCode ruby"><code class="sourceCode ruby"><span id="cb186-1"><a href="#cb186-1" aria-hidden="true" tabindex="-1"></a>fix32<span class="at">.define_operator</span>(:<span class="kw">*</span>) <span class="cf">do</span> <span class="kw">|</span>left,right<span class="kw">|</span></span>
<span id="cb186-2"><a href="#cb186-2" aria-hidden="true" tabindex="-1"></a>   (left<span class="at">.as</span>(signed<span class="kw">[</span><span class="dv">31</span><span class="kw">..</span><span class="dv">0</span><span class="kw">]</span>) <span class="kw">*</span> right) <span class="kw">&gt;&gt;</span> <span class="dv">16</span></span>
<span id="cb186-3"><a href="#cb186-3" aria-hidden="true" tabindex="-1"></a><span class="cf">end</span></span></code></pre></div>
<p>Please notice, that in the code above, the left value has been cast to a plain bit-vector to avoid the infinite recursive call of the <code>*</code> operator.</p>
<p>Operators can also be overloaded with generic types. However, in such a case, the generic argument must also be present in the list of arguments of the overloaded operators. For instance, let us consider the following fixed-point type of variable width (whose decimal point is set at half of its bit range):</p>
<div class="sourceCode" id="cb187"><pre class="sourceCode ruby"><code class="sourceCode ruby"><span id="cb187-1"><a href="#cb187-1" aria-hidden="true" tabindex="-1"></a>typedef(<span class="wa">:fixed</span>) <span class="cf">do</span> <span class="kw">|</span>width<span class="kw">|</span></span>
<span id="cb187-2"><a href="#cb187-2" aria-hidden="true" tabindex="-1"></a>   signed<span class="kw">[</span>(width<span class="dv">-1</span>)<span class="kw">..</span><span class="dv">0</span><span class="kw">]</span></span>
<span id="cb187-3"><a href="#cb187-3" aria-hidden="true" tabindex="-1"></a><span class="cf">end</span></span></code></pre></div>
<p>The multiplication operator would be overloaded as follows:</p>
<div class="sourceCode" id="cb188"><pre class="sourceCode ruby"><code class="sourceCode ruby"><span id="cb188-1"><a href="#cb188-1" aria-hidden="true" tabindex="-1"></a>fixed<span class="at">.define_operator</span> <span class="cf">do</span> <span class="kw">|</span>width,left,right<span class="kw">|</span></span>
<span id="cb188-2"><a href="#cb188-2" aria-hidden="true" tabindex="-1"></a>   (left<span class="at">.as</span>(signed<span class="kw">[</span>(width<span class="dv">-1</span>)<span class="kw">..</span><span class="dv">0</span><span class="kw">]</span>) <span class="kw">*</span> right) <span class="kw">&gt;&gt;</span> width<span class="kw">/</span><span class="dv">2</span></span>
<span id="cb188-3"><a href="#cb188-3" aria-hidden="true" tabindex="-1"></a><span class="cf">end</span></span></code></pre></div>
<h3 id="predicate-and-access-methods">Predicate and access methods</h3>
<p>To get information about the current state of the hardware description HDLRuby provides the following predicates:</p>
<table>
<colgroup>
<col style="width: 33%" />
<col style="width: 33%" />
<col style="width: 33%" />
</colgroup>
<thead>
<tr class="header">
<th style="text-align: left;">predicate name</th>
<th style="text-align: left;">predicate type</th>
<th style="text-align: left;">predicate meaning</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><code>is_block?</code></td>
<td style="text-align: left;">bit</td>
<td style="text-align: left;">tells if in execution block</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>is_par?</code></td>
<td style="text-align: left;">bit</td>
<td style="text-align: left;">tells if current parallel block is parallel</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>is_seq?</code></td>
<td style="text-align: left;">bit</td>
<td style="text-align: left;">tells if current parallel block is sequential</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>is_clocked?</code></td>
<td style="text-align: left;">bit</td>
<td style="text-align: left;">tells if current behavior is clocked (activated on a sole rising or falling edge of a signal)</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>cur_block</code></td>
<td style="text-align: left;">block</td>
<td style="text-align: left;">gets the current block</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>cur_behavior</code></td>
<td style="text-align: left;">behavior</td>
<td style="text-align: left;">gets the current behavior</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>cur_systemT</code></td>
<td style="text-align: left;">system</td>
<td style="text-align: left;">gets the current system</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>top_block</code></td>
<td style="text-align: left;">block</td>
<td style="text-align: left;">gets the top block of the current behavior</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>one_up</code></td>
<td style="text-align: left;">block/system</td>
<td style="text-align: left;">gets the upper construct (block or system)</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>last_one</code></td>
<td style="text-align: left;">any</td>
<td style="text-align: left;">last declared construct</td>
</tr>
</tbody>
</table>
<p>Several enumerators are also provided for accessing the internals of the current construct (in the current state):</p>
<table>
<colgroup>
<col style="width: 50%" />
<col style="width: 50%" />
</colgroup>
<thead>
<tr class="header">
<th style="text-align: left;">enumerator name</th>
<th style="text-align: left;">accessed elements</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><code>each_input</code></td>
<td style="text-align: left;">input signals of the current system</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>each_output</code></td>
<td style="text-align: left;">output signals of the current system</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>each_inout</code></td>
<td style="text-align: left;">inout signals of the current system</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>each_behavior</code></td>
<td style="text-align: left;">behaviors of the current system</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>each_event</code></td>
<td style="text-align: left;">events of the current behavior</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>each_block</code></td>
<td style="text-align: left;">blocks of the current behavior</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>each_statement</code></td>
<td style="text-align: left;">statements of the current block</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>each_inner</code></td>
<td style="text-align: left;">inner signals of the current block (or system if not within a block)</td>
</tr>
</tbody>
</table>
<h3 id="defining-and-executing-ruby-methods-within-hdlruby-constructs">Defining and executing Ruby methods within HDLRuby constructs</h3>
<p><a name="method"></a></p>
<p>Like with any Ruby program, it is possible to define and execute methods anywhere in HDLRuby using the standard Ruby syntax. When defined, a method is attached to the enclosing HDLRuby construct. For instance, when defining a method when declaring a system, it can be used within this system only, while when defining a method outside any construct, it can be used everywhere in the HDLRuby description.</p>
<p>A method can include HDLRuby code in which case the resulting hardware is appended to the current construct. For example, the following code adds a connection between <code>sig0</code> and <code>sig1</code> in the system <code>sys0</code>, and transmission between <code>sig0</code> and <code>sig1</code> in the behavior of <code>sys1</code>.</p>
<div class="sourceCode" id="cb189"><pre class="sourceCode ruby"><code class="sourceCode ruby"><span id="cb189-1"><a href="#cb189-1" aria-hidden="true" tabindex="-1"></a><span class="cf">def</span> some_arrow</span>
<span id="cb189-2"><a href="#cb189-2" aria-hidden="true" tabindex="-1"></a>   sig1 <span class="kw">&lt;=</span> sig0</span>
<span id="cb189-3"><a href="#cb189-3" aria-hidden="true" tabindex="-1"></a><span class="cf">end</span></span>
<span id="cb189-4"><a href="#cb189-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb189-5"><a href="#cb189-5" aria-hidden="true" tabindex="-1"></a><span class="fu">system</span> <span class="wa">:sys0</span> <span class="cf">do</span></span>
<span id="cb189-6"><a href="#cb189-6" aria-hidden="true" tabindex="-1"></a>   input <span class="wa">:sig0</span></span>
<span id="cb189-7"><a href="#cb189-7" aria-hidden="true" tabindex="-1"></a>   output <span class="wa">:sig1</span></span>
<span id="cb189-8"><a href="#cb189-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb189-9"><a href="#cb189-9" aria-hidden="true" tabindex="-1"></a>   some_arrow</span>
<span id="cb189-10"><a href="#cb189-10" aria-hidden="true" tabindex="-1"></a><span class="cf">end</span></span>
<span id="cb189-11"><a href="#cb189-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb189-12"><a href="#cb189-12" aria-hidden="true" tabindex="-1"></a><span class="fu">system</span> <span class="wa">:sys1</span> <span class="cf">do</span></span>
<span id="cb189-13"><a href="#cb189-13" aria-hidden="true" tabindex="-1"></a>   input <span class="wa">:sig0</span>, <span class="wa">:clk</span></span>
<span id="cb189-14"><a href="#cb189-14" aria-hidden="true" tabindex="-1"></a>   output <span class="wa">:sig1</span></span>
<span id="cb189-15"><a href="#cb189-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb189-16"><a href="#cb189-16" aria-hidden="true" tabindex="-1"></a>   par(clk<span class="at">.posedge</span>) <span class="cf">do</span></span>
<span id="cb189-17"><a href="#cb189-17" aria-hidden="true" tabindex="-1"></a>      some_arrow</span>
<span id="cb189-18"><a href="#cb189-18" aria-hidden="true" tabindex="-1"></a>   <span class="cf">end</span></span>
<span id="cb189-19"><a href="#cb189-19" aria-hidden="true" tabindex="-1"></a><span class="cf">end</span></span></code></pre></div>
<p><strong>Warning</strong>:</p>
<ul>
<li><p>In the above example, the semantic of <code>some_arrow</code> changes depending on where it is invoked from, e.g., within a system, it is a connection, within a behavior, it is a transmission.</p></li>
<li><p>Using Ruby methods for describing hardware might lead to weak code, for example, in the following code, the method declares <code>in0</code> as an input signal. Hence, while used in <code>sys0</code> no problem happens, an exception will be raised for <code>sys1</code> because a signal <code>in0</code> is already declared and will also be raised for <code>sys2</code> because it is not possible to declare an input from within a behavior.</p>
<div class="sourceCode" id="cb190"><pre class="sourceCode ruby"><code class="sourceCode ruby"><span id="cb190-1"><a href="#cb190-1" aria-hidden="true" tabindex="-1"></a><span class="cf">def</span> in_decl</span>
<span id="cb190-2"><a href="#cb190-2" aria-hidden="true" tabindex="-1"></a>   input <span class="wa">:in0</span></span>
<span id="cb190-3"><a href="#cb190-3" aria-hidden="true" tabindex="-1"></a><span class="cf">end</span></span>
<span id="cb190-4"><a href="#cb190-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb190-5"><a href="#cb190-5" aria-hidden="true" tabindex="-1"></a><span class="fu">system</span> <span class="wa">:sys0</span> <span class="cf">do</span></span>
<span id="cb190-6"><a href="#cb190-6" aria-hidden="true" tabindex="-1"></a>   in_decl</span>
<span id="cb190-7"><a href="#cb190-7" aria-hidden="true" tabindex="-1"></a><span class="cf">end</span></span>
<span id="cb190-8"><a href="#cb190-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb190-9"><a href="#cb190-9" aria-hidden="true" tabindex="-1"></a><span class="fu">system</span> <span class="wa">:sys1</span> <span class="cf">do</span></span>
<span id="cb190-10"><a href="#cb190-10" aria-hidden="true" tabindex="-1"></a>   input <span class="wa">:in0</span></span>
<span id="cb190-11"><a href="#cb190-11" aria-hidden="true" tabindex="-1"></a>   in_decl</span>
<span id="cb190-12"><a href="#cb190-12" aria-hidden="true" tabindex="-1"></a><span class="cf">end</span></span>
<span id="cb190-13"><a href="#cb190-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb190-14"><a href="#cb190-14" aria-hidden="true" tabindex="-1"></a><span class="fu">system</span> <span class="wa">:sys2</span> <span class="cf">do</span></span>
<span id="cb190-15"><a href="#cb190-15" aria-hidden="true" tabindex="-1"></a>   par <span class="cf">do</span></span>
<span id="cb190-16"><a href="#cb190-16" aria-hidden="true" tabindex="-1"></a>      in_decl</span>
<span id="cb190-17"><a href="#cb190-17" aria-hidden="true" tabindex="-1"></a>   <span class="cf">end</span></span>
<span id="cb190-18"><a href="#cb190-18" aria-hidden="true" tabindex="-1"></a><span class="cf">end</span></span></code></pre></div></li>
</ul>
<p>Like any other Ruby method, methods defined in HDLRuby support variadic arguments named arguments, and block arguments. For example, the following method can be used to connect a driver to multiple signals:</p>
<div class="sourceCode" id="cb191"><pre class="sourceCode ruby"><code class="sourceCode ruby"><span id="cb191-1"><a href="#cb191-1" aria-hidden="true" tabindex="-1"></a><span class="cf">def</span> mconnect(driver, <span class="kw">*</span>signals)</span>
<span id="cb191-2"><a href="#cb191-2" aria-hidden="true" tabindex="-1"></a>   signals<span class="at">.each</span> <span class="cf">do</span> <span class="kw">|</span>signal<span class="kw">|</span></span>
<span id="cb191-3"><a href="#cb191-3" aria-hidden="true" tabindex="-1"></a>      signal <span class="kw">&lt;=</span> driver</span>
<span id="cb191-4"><a href="#cb191-4" aria-hidden="true" tabindex="-1"></a>   <span class="cf">end</span></span>
<span id="cb191-5"><a href="#cb191-5" aria-hidden="true" tabindex="-1"></a><span class="cf">end</span></span>
<span id="cb191-6"><a href="#cb191-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb191-7"><a href="#cb191-7" aria-hidden="true" tabindex="-1"></a><span class="fu">system</span> <span class="wa">:sys0</span> <span class="cf">do</span></span>
<span id="cb191-8"><a href="#cb191-8" aria-hidden="true" tabindex="-1"></a>   input <span class="wa">:i0</span></span>
<span id="cb191-9"><a href="#cb191-9" aria-hidden="true" tabindex="-1"></a>   input <span class="wa">:o0</span>, <span class="wa">:o1</span>, <span class="wa">:o2</span>, <span class="wa">:o3</span></span>
<span id="cb191-10"><a href="#cb191-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb191-11"><a href="#cb191-11" aria-hidden="true" tabindex="-1"></a>   mconnect(i0,o0,o1,o2,o3)</span>
<span id="cb191-12"><a href="#cb191-12" aria-hidden="true" tabindex="-1"></a><span class="cf">end</span></span></code></pre></div>
<p>While requiring caution, a properly designed method can be very useful for clean code reuse. For example, the following method allows to start the execution of a block after a given number of cycles:</p>
<div class="sourceCode" id="cb192"><pre class="sourceCode ruby"><code class="sourceCode ruby"><span id="cb192-1"><a href="#cb192-1" aria-hidden="true" tabindex="-1"></a><span class="cf">def</span> after(cycles, rst, <span class="kw">&amp;</span>code)</span>
<span id="cb192-2"><a href="#cb192-2" aria-hidden="true" tabindex="-1"></a>   <span class="fu">sub</span> <span class="cf">do</span></span>
<span id="cb192-3"><a href="#cb192-3" aria-hidden="true" tabindex="-1"></a>      inner <span class="wa">:count</span></span>
<span id="cb192-4"><a href="#cb192-4" aria-hidden="true" tabindex="-1"></a>      hif rst <span class="kw">==</span> <span class="dv">1</span> <span class="cf">do</span></span>
<span id="cb192-5"><a href="#cb192-5" aria-hidden="true" tabindex="-1"></a>         count <span class="kw">&lt;=</span> <span class="dv">0</span></span>
<span id="cb192-6"><a href="#cb192-6" aria-hidden="true" tabindex="-1"></a>      <span class="cf">end</span></span>
<span id="cb192-7"><a href="#cb192-7" aria-hidden="true" tabindex="-1"></a>      helse <span class="cf">do</span></span>
<span id="cb192-8"><a href="#cb192-8" aria-hidden="true" tabindex="-1"></a>         hif count <span class="kw">&lt;</span> cycles <span class="cf">do</span></span>
<span id="cb192-9"><a href="#cb192-9" aria-hidden="true" tabindex="-1"></a>            count <span class="kw">&lt;=</span> count <span class="kw">+</span> <span class="dv">1</span></span>
<span id="cb192-10"><a href="#cb192-10" aria-hidden="true" tabindex="-1"></a>         <span class="cf">end</span></span>
<span id="cb192-11"><a href="#cb192-11" aria-hidden="true" tabindex="-1"></a>         helse <span class="cf">do</span></span>
<span id="cb192-12"><a href="#cb192-12" aria-hidden="true" tabindex="-1"></a>            instance_eval(<span class="kw">&amp;</span>code)</span>
<span id="cb192-13"><a href="#cb192-13" aria-hidden="true" tabindex="-1"></a>         <span class="cf">end</span></span>
<span id="cb192-14"><a href="#cb192-14" aria-hidden="true" tabindex="-1"></a>      <span class="cf">end</span></span>
<span id="cb192-15"><a href="#cb192-15" aria-hidden="true" tabindex="-1"></a>   <span class="cf">end</span></span>
<span id="cb192-16"><a href="#cb192-16" aria-hidden="true" tabindex="-1"></a><span class="cf">end</span></span></code></pre></div>
<p>In the code above:</p>
<ul>
<li><p><code>sub</code> ensures that the <code>count</code> signal does not conflict with another signal with the same name.</p></li>
<li><p>the <code>instance_eval</code> keyword is a standard Ruby method that executes the block passed as an argument in context.</p></li>
</ul>
<p>The following is an example that switches an LED on after 1000000 clock cycles using the previously defined <code>after</code> ruby method:</p>
<div class="sourceCode" id="cb193"><pre class="sourceCode ruby"><code class="sourceCode ruby"><span id="cb193-1"><a href="#cb193-1" aria-hidden="true" tabindex="-1"></a><span class="fu">system</span> <span class="wa">:led_after</span> <span class="cf">do</span></span>
<span id="cb193-2"><a href="#cb193-2" aria-hidden="true" tabindex="-1"></a>   output <span class="wa">:led</span></span>
<span id="cb193-3"><a href="#cb193-3" aria-hidden="true" tabindex="-1"></a>   input <span class="wa">:clk</span>, <span class="wa">:rst</span></span>
<span id="cb193-4"><a href="#cb193-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb193-5"><a href="#cb193-5" aria-hidden="true" tabindex="-1"></a>   par(clk<span class="at">.posedge</span>) <span class="cf">do</span></span>
<span id="cb193-6"><a href="#cb193-6" aria-hidden="true" tabindex="-1"></a>      (led <span class="kw">&lt;=</span> <span class="dv">0</span>)<span class="at">.hif</span>(rst)</span>
<span id="cb193-7"><a href="#cb193-7" aria-hidden="true" tabindex="-1"></a>      after(<span class="dv">100000</span>,rst) <span class="kw">{</span> led <span class="kw">&lt;=</span> <span class="dv">1</span> <span class="kw">}</span></span>
<span id="cb193-8"><a href="#cb193-8" aria-hidden="true" tabindex="-1"></a>   <span class="cf">end</span></span>
<span id="cb193-9"><a href="#cb193-9" aria-hidden="true" tabindex="-1"></a><span class="cf">end</span></span></code></pre></div>
<p><strong>Note</strong>:</p>
<ul>
<li>Ruby’s closure still applies in HDLRuby, hence, the block sent to <code>after</code> can use the signals and instances of the current block. Moreover, the signals declared in this method will not collide with them.</li>
</ul>
<h2 id="extending-hdlruby">Extending HDLRuby</h2>
<p>Like any Ruby class, the constructs of HDLRuby can be dynamically extended. If it is not recommended to change their internal structure, it is possible to add methods to them for an extension.</p>
<h3 id="extending-hdlruby-constructs-globally">Extending HDLRuby constructs globally</h3>
<p>By global extension of hardware constructs, we mean the classical extension of Ruby classes by monkey patching the corresponding class. For example, it is possible to add a method giving the number of signals in the interface of a system instance as follows:</p>
<div class="sourceCode" id="cb194"><pre class="sourceCode ruby"><code class="sourceCode ruby"><span id="cb194-1"><a href="#cb194-1" aria-hidden="true" tabindex="-1"></a><span class="cf">class</span> <span class="dt">SystemI</span></span>
<span id="cb194-2"><a href="#cb194-2" aria-hidden="true" tabindex="-1"></a>   <span class="cf">def</span> interface_size</span>
<span id="cb194-3"><a href="#cb194-3" aria-hidden="true" tabindex="-1"></a>      <span class="cf">return</span> each_input<span class="at">.size</span> <span class="kw">+</span> each_output<span class="at">.size</span> <span class="kw">+</span> each_inout<span class="at">.size</span></span>
<span id="cb194-4"><a href="#cb194-4" aria-hidden="true" tabindex="-1"></a>   <span class="cf">end</span></span>
<span id="cb194-5"><a href="#cb194-5" aria-hidden="true" tabindex="-1"></a><span class="cf">end</span></span></code></pre></div>
<p>From there, the method <code>interface_size</code> can be used on any system instance as follows: <code>&lt;system instance&gt;.interface_size</code>.</p>
<p>The following table gives the class of each construct of HDLRuby.</p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">construct</th>
<th style="text-align: left;">class</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">data type</td>
<td style="text-align: left;">Type</td>
</tr>
<tr class="even">
<td style="text-align: left;">system</td>
<td style="text-align: left;">SystemT</td>
</tr>
<tr class="odd">
<td style="text-align: left;">scope</td>
<td style="text-align: left;">Scope</td>
</tr>
<tr class="even">
<td style="text-align: left;">system instance</td>
<td style="text-align: left;">SystemI</td>
</tr>
<tr class="odd">
<td style="text-align: left;">signal</td>
<td style="text-align: left;">Signal</td>
</tr>
<tr class="even">
<td style="text-align: left;">connection</td>
<td style="text-align: left;">Connection</td>
</tr>
<tr class="odd">
<td style="text-align: left;">par/seq</td>
<td style="text-align: left;">Behavior</td>
</tr>
<tr class="even">
<td style="text-align: left;">timed</td>
<td style="text-align: left;">TimeBehavior</td>
</tr>
<tr class="odd">
<td style="text-align: left;">event</td>
<td style="text-align: left;">Event</td>
</tr>
<tr class="even">
<td style="text-align: left;">par/seq/sub</td>
<td style="text-align: left;">Block</td>
</tr>
<tr class="odd">
<td style="text-align: left;">transmit</td>
<td style="text-align: left;">Transmit</td>
</tr>
<tr class="even">
<td style="text-align: left;">hif</td>
<td style="text-align: left;">If</td>
</tr>
<tr class="odd">
<td style="text-align: left;">hcase</td>
<td style="text-align: left;">Case</td>
</tr>
<tr class="even">
<td style="text-align: left;">program</td>
<td style="text-align: left;">Program</td>
</tr>
</tbody>
</table>
<h3 id="extending-hdlruby-constructs-locally">Extending HDLRuby constructs locally</h3>
<p>By local extension of a hardware construct, we mean that while the construct will be changed, all the other constructs will remain unchanged. This is achieved like with Ruby by accessing the Eigen class using the <code>singleton_class</code> method and extending it using the <code>class_eval</code> method. For example, with the following code, only system <code>dff</code> will respond to method <code>interface_size</code>:</p>
<div class="sourceCode" id="cb195"><pre class="sourceCode ruby"><code class="sourceCode ruby"><span id="cb195-1"><a href="#cb195-1" aria-hidden="true" tabindex="-1"></a>dff<span class="at">.singleton_class.class_eval</span> <span class="cf">do</span></span>
<span id="cb195-2"><a href="#cb195-2" aria-hidden="true" tabindex="-1"></a>   <span class="cf">def</span> interface_size</span>
<span id="cb195-3"><a href="#cb195-3" aria-hidden="true" tabindex="-1"></a>      <span class="cf">return</span> each_input<span class="at">.size</span> <span class="kw">+</span> each_output<span class="at">.size</span> <span class="kw">+</span> each_inout<span class="at">.size</span></span>
<span id="cb195-4"><a href="#cb195-4" aria-hidden="true" tabindex="-1"></a>   <span class="cf">end</span></span>
<span id="cb195-5"><a href="#cb195-5" aria-hidden="true" tabindex="-1"></a><span class="cf">end</span></span></code></pre></div>
<p>It is also possible to extend locally an instance using the same methods. For example, with the following code, only instance <code>dff0</code> will respond to method <code>interface_size</code>:</p>
<div class="sourceCode" id="cb196"><pre class="sourceCode ruby"><code class="sourceCode ruby"><span id="cb196-1"><a href="#cb196-1" aria-hidden="true" tabindex="-1"></a>dff <span class="wa">:dff0</span></span>
<span id="cb196-2"><a href="#cb196-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb196-3"><a href="#cb196-3" aria-hidden="true" tabindex="-1"></a>dff0<span class="at">.singleton_class.class_eval</span> <span class="cf">do</span></span>
<span id="cb196-4"><a href="#cb196-4" aria-hidden="true" tabindex="-1"></a>   <span class="cf">def</span> interface_size</span>
<span id="cb196-5"><a href="#cb196-5" aria-hidden="true" tabindex="-1"></a>      <span class="cf">return</span> each_input<span class="at">.size</span> <span class="kw">+</span> each_output<span class="at">.size</span> <span class="kw">+</span> each_inout<span class="at">.size</span></span>
<span id="cb196-6"><a href="#cb196-6" aria-hidden="true" tabindex="-1"></a>   <span class="cf">end</span></span>
<span id="cb196-7"><a href="#cb196-7" aria-hidden="true" tabindex="-1"></a><span class="cf">end</span></span></code></pre></div>
<p>Finally, it is possible to extend locally all the instances of a system using method <code>singleton_instance</code> in place of method <code>singleton_class</code>. For example, with the following code, all the instances of system <code>dff</code> will respond to method <code>interface_size</code>:</p>
<div class="sourceCode" id="cb197"><pre class="sourceCode ruby"><code class="sourceCode ruby"><span id="cb197-1"><a href="#cb197-1" aria-hidden="true" tabindex="-1"></a>dff<span class="at">.singleton_instance.class_eval</span> <span class="cf">do</span></span>
<span id="cb197-2"><a href="#cb197-2" aria-hidden="true" tabindex="-1"></a>   <span class="cf">def</span> interface_size</span>
<span id="cb197-3"><a href="#cb197-3" aria-hidden="true" tabindex="-1"></a>      <span class="cf">return</span> each_input<span class="at">.size</span> <span class="kw">+</span> each_output<span class="at">.size</span> <span class="kw">+</span> each_inout<span class="at">.size</span></span>
<span id="cb197-4"><a href="#cb197-4" aria-hidden="true" tabindex="-1"></a>   <span class="cf">end</span></span>
<span id="cb197-5"><a href="#cb197-5" aria-hidden="true" tabindex="-1"></a><span class="cf">end</span></span></code></pre></div>
<h3 id="modifying-the-generation-behavior">Modifying the generation behavior</h3>
<p>The main purpose of allowing global and local extensions for hardware constructs is to give the user the possibility to implement its synthesis methods. For example, one may want to implement some algorithm for a given kind of system. For that purpose, the user can define an abstract system (without any hardware content), that holds the specific algorithm as follows:</p>
<div class="sourceCode" id="cb198"><pre class="sourceCode ruby"><code class="sourceCode ruby"><span id="cb198-1"><a href="#cb198-1" aria-hidden="true" tabindex="-1"></a><span class="fu">system</span>(<span class="wa">:my_base</span>) <span class="kw">{}</span></span>
<span id="cb198-2"><a href="#cb198-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb198-3"><a href="#cb198-3" aria-hidden="true" tabindex="-1"></a>my_base<span class="at">.singleton_instance.class_eval</span> <span class="cf">do</span></span>
<span id="cb198-4"><a href="#cb198-4" aria-hidden="true" tabindex="-1"></a>   <span class="cf">def</span> my_generation</span>
<span id="cb198-5"><a href="#cb198-5" aria-hidden="true" tabindex="-1"></a>      <span class="kw">&lt;</span>some code<span class="kw">&gt;</span></span>
<span id="cb198-6"><a href="#cb198-6" aria-hidden="true" tabindex="-1"></a>   <span class="cf">end</span></span>
<span id="cb198-7"><a href="#cb198-7" aria-hidden="true" tabindex="-1"></a><span class="cf">end</span></span></code></pre></div>
<p>Then, when this system named <code>my_base</code> is included in another system, this latter will inherit from the algorithms implemented inside method <code>my_generation</code> as shown in the following code:</p>
<div class="sourceCode" id="cb199"><pre class="sourceCode ruby"><code class="sourceCode ruby"><span id="cb199-1"><a href="#cb199-1" aria-hidden="true" tabindex="-1"></a><span class="fu">system</span> <span class="wa">:some_system</span>, my_base <span class="cf">do</span></span>
<span id="cb199-2"><a href="#cb199-2" aria-hidden="true" tabindex="-1"></a>   <span class="kw">&lt;</span>some <span class="fu">system</span> description<span class="kw">&gt;</span></span>
<span id="cb199-3"><a href="#cb199-3" aria-hidden="true" tabindex="-1"></a><span class="cf">end</span></span></code></pre></div>
<p>However, when generation the low-level description of this system, code like the following will have to be written for applying <code>my_generation</code>:</p>
<div class="sourceCode" id="cb200"><pre class="sourceCode ruby"><code class="sourceCode ruby"><span id="cb200-1"><a href="#cb200-1" aria-hidden="true" tabindex="-1"></a>some_system <span class="wa">:instance0</span></span>
<span id="cb200-2"><a href="#cb200-2" aria-hidden="true" tabindex="-1"></a>instance0<span class="at">.my_generation</span></span>
<span id="cb200-3"><a href="#cb200-3" aria-hidden="true" tabindex="-1"></a>low <span class="kw">=</span> instance0<span class="at">.to_low</span></span></code></pre></div>
<p>This can be avoided by redefining the <code>to_low</code> method as follows:</p>
<div class="sourceCode" id="cb201"><pre class="sourceCode ruby"><code class="sourceCode ruby"><span id="cb201-1"><a href="#cb201-1" aria-hidden="true" tabindex="-1"></a><span class="fu">system</span>(<span class="wa">:my_base</span>) <span class="kw">{}</span></span>
<span id="cb201-2"><a href="#cb201-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb201-3"><a href="#cb201-3" aria-hidden="true" tabindex="-1"></a>my_base<span class="at">.singleton_instance.class_eval</span> <span class="cf">do</span></span>
<span id="cb201-4"><a href="#cb201-4" aria-hidden="true" tabindex="-1"></a>   <span class="cf">def</span> my_generation</span>
<span id="cb201-5"><a href="#cb201-5" aria-hidden="true" tabindex="-1"></a>      <span class="kw">&lt;</span>some code<span class="kw">&gt;</span></span>
<span id="cb201-6"><a href="#cb201-6" aria-hidden="true" tabindex="-1"></a>   <span class="cf">end</span></span>
<span id="cb201-7"><a href="#cb201-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb201-8"><a href="#cb201-8" aria-hidden="true" tabindex="-1"></a>   <span class="kw">alias</span> <span class="wa">:_to_low</span> <span class="wa">:to_low</span></span>
<span id="cb201-9"><a href="#cb201-9" aria-hidden="true" tabindex="-1"></a>   <span class="cf">def</span> to_low</span>
<span id="cb201-10"><a href="#cb201-10" aria-hidden="true" tabindex="-1"></a>      my_generation</span>
<span id="cb201-11"><a href="#cb201-11" aria-hidden="true" tabindex="-1"></a>      _to_low</span>
<span id="cb201-12"><a href="#cb201-12" aria-hidden="true" tabindex="-1"></a>   <span class="cf">end</span></span>
<span id="cb201-13"><a href="#cb201-13" aria-hidden="true" tabindex="-1"></a><span class="cf">end</span></span></code></pre></div>
<p>This way, calling directly <code>to_low</code> will automatically use <code>my_generation</code>.</p>
<h1 id="standard-libraries">Standard libraries</h1>
<p>The standard libraries are included in the module <code>Std</code>. They can be loaded as follows, where <code>&lt;library name&gt;</code> is the name of the library:</p>
<div class="sourceCode" id="cb202"><pre class="sourceCode ruby"><code class="sourceCode ruby"><span id="cb202-1"><a href="#cb202-1" aria-hidden="true" tabindex="-1"></a><span class="fu">require</span> <span class="vs">&#39;std/&lt;library name&gt;&#39;</span> </span></code></pre></div>
<p>After the libraries are loaded, the module <code>Std</code> must be included as follows:</p>
<div class="sourceCode" id="cb203"><pre class="sourceCode ruby"><code class="sourceCode ruby"><span id="cb203-1"><a href="#cb203-1" aria-hidden="true" tabindex="-1"></a><span class="fu">include</span> <span class="dt">HDLRuby</span><span class="kw">::</span><span class="dt">High</span><span class="kw">::</span><span class="dt">Std</span></span></code></pre></div>
<blockquote>
<p>However, <code>hdrcc</code> loads the stable components of the standard library by default, so you do not need to require nor include anything more to use them. In the current version, the stable components are the following:</p>
</blockquote>
<ul>
<li><p><code>std/clocks.rb</code></p></li>
<li><p><code>std/fixpoint.rb</code></p></li>
<li><p><code>std/decoder.rb</code></p></li>
<li><p><code>std/fsm.rb</code></p></li>
<li><p><code>std/sequencer.rb</code></p></li>
<li><p><code>std/sequencer_sync.rb</code></p></li>
</ul>
<h2 id="clocks-stdclocks.rb">Clocks: <code>std/clocks.rb</code></h2>
<p><a name="clocks"></a></p>
<p>The <code>clocks</code> library provides utilities for easier handling of clock synchronizations.</p>
<p>It adds the possibility to multiply events by an integer. The result is a new event whose frequency is divided by the integer multiplicand. For example, the following code describes a D-FF that memorizes each three clock cycles.</p>
<div class="sourceCode" id="cb204"><pre class="sourceCode ruby"><code class="sourceCode ruby"><span id="cb204-1"><a href="#cb204-1" aria-hidden="true" tabindex="-1"></a><span class="fu">require</span> <span class="vs">&#39;std/clocks&#39;</span></span>
<span id="cb204-2"><a href="#cb204-2" aria-hidden="true" tabindex="-1"></a><span class="fu">include</span> <span class="dt">HDLRuby</span><span class="kw">::</span><span class="dt">High</span><span class="kw">::</span><span class="dt">Std</span></span>
<span id="cb204-3"><a href="#cb204-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb204-4"><a href="#cb204-4" aria-hidden="true" tabindex="-1"></a><span class="fu">system</span> <span class="wa">:dff_slow</span> <span class="cf">do</span></span>
<span id="cb204-5"><a href="#cb204-5" aria-hidden="true" tabindex="-1"></a>   input <span class="wa">:clk</span>, <span class="wa">:rst</span></span>
<span id="cb204-6"><a href="#cb204-6" aria-hidden="true" tabindex="-1"></a>   input <span class="wa">:d</span></span>
<span id="cb204-7"><a href="#cb204-7" aria-hidden="true" tabindex="-1"></a>   output <span class="wa">:q</span></span>
<span id="cb204-8"><a href="#cb204-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb204-9"><a href="#cb204-9" aria-hidden="true" tabindex="-1"></a>   ( q <span class="kw">&lt;=</span> d <span class="kw">&amp;</span> <span class="kw">~</span>rst )<span class="at">.at</span>(clk<span class="at">.posedge</span> <span class="kw">*</span> <span class="dv">3</span>)</span>
<span id="cb204-10"><a href="#cb204-10" aria-hidden="true" tabindex="-1"></a><span class="cf">end</span></span></code></pre></div>
<p><strong>Note</strong>: this library generates all the RTL code for the circuit handling the frequency division.</p>
<h2 id="counters-stdcounters.rb">Counters: <code>std/counters.rb</code></h2>
<p><a name="counters"></a></p>
<p>This library provides two new constructs for implementing synthesizable wait statements.</p>
<p>The first construct is the <code>after</code> statement that activates a block after a given number of clock cycles is passed. Its syntax is the following:</p>
<div class="sourceCode" id="cb205"><pre class="sourceCode ruby"><code class="sourceCode ruby"><span id="cb205-1"><a href="#cb205-1" aria-hidden="true" tabindex="-1"></a>after(<span class="kw">&lt;</span>number<span class="kw">&gt;</span>,<span class="kw">&lt;</span>clock<span class="kw">&gt;</span>,<span class="kw">&lt;</span>reset<span class="kw">&gt;</span>)</span></code></pre></div>
<p>Where:</p>
<ul>
<li><code>&lt;number&gt;</code> is the number of cycles to wait.</li>
<li><code>&lt;clock&gt;</code> is the clock to use, this argument can be omitted.</li>
<li><code>&lt;reset&gt;</code> is the signal used to reset the counter used for waiting, this argument can be omitted.</li>
</ul>
<p>This statement can be used inside a clocked behavior where the clock event of the behavior is used for the counter unless specified otherwise.</p>
<p>The second construct is the <code>before</code> statement that activates a block until a given number of clock cycles is passed. Its syntax and usage are identical to the <code>after</code> statement.</p>
<h2 id="decoder-stddecoder.rb">Decoder: <code>std/decoder.rb</code></h2>
<p><a name="decoder"></a></p>
<p>This library provides a new set of control statements for easily describing an instruction decoder.</p>
<p>A decoder can be declared anywhere in the code describing a system using the <code>decoder</code> keyword as follows:</p>
<div class="sourceCode" id="cb206"><pre class="sourceCode ruby"><code class="sourceCode ruby"><span id="cb206-1"><a href="#cb206-1" aria-hidden="true" tabindex="-1"></a>decoder(<span class="kw">&lt;</span>signal<span class="kw">&gt;</span>) <span class="kw">&lt;</span>block<span class="kw">&gt;</span></span></code></pre></div>
<p>Where <code>signal</code> is the signal to decode and <code>block</code> is a procedure block (i.e., Ruby <code>proc</code>) describing the decoding procedure. This procedure block can contain any code supported by a standard behavior but also supports the <code>entry</code> statement that describes a pattern of a bit vector to decode and the corresponding action to perform when the signal matches this pattern. The syntax of the <code>entry</code> statement is the following:</p>
<div class="sourceCode" id="cb207"><pre class="sourceCode ruby"><code class="sourceCode ruby"><span id="cb207-1"><a href="#cb207-1" aria-hidden="true" tabindex="-1"></a>entry(<span class="kw">&lt;</span>pattern<span class="kw">&gt;</span>) <span class="kw">&lt;</span>block<span class="kw">&gt;</span></span></code></pre></div>
<p>Where <code>pattern</code> is a string describing the pattern to match the entry, and <code>block</code> is a procedure block describing the actions (some HDLRuby code) that are performed when the entry matches. The string describing the pattern can include <code>0</code> and <code>1</code> characters for specifying a specific value for the corresponding bit, or any alphabetical character for specifying a field in the pattern. The fields in the pattern can then be used by name in the block describing the action. When a letter is used several times within a pattern, the corresponding bits are concatenated and used as a multi-bit signal in the block.</p>
<p>For example, the following code describes a decoder for signal <code>ir</code> with two entries, the first one computing the sum of fields <code>x</code> and <code>y</code> and assigning the result to signal <code>s</code> and the second one computing the sum of fields <code>x</code> <code>y</code> and <code>z</code> and assigning the result to signal <code>s</code>:</p>
<div class="sourceCode" id="cb208"><pre class="sourceCode ruby"><code class="sourceCode ruby"><span id="cb208-1"><a href="#cb208-1" aria-hidden="true" tabindex="-1"></a>decoder(ir) <span class="cf">do</span></span>
<span id="cb208-2"><a href="#cb208-2" aria-hidden="true" tabindex="-1"></a>   entry(<span class="st">&quot;000xx0yy&quot;</span>) <span class="kw">{</span> s <span class="kw">&lt;=</span> x <span class="kw">+</span> y <span class="kw">}</span></span>
<span id="cb208-3"><a href="#cb208-3" aria-hidden="true" tabindex="-1"></a>   entry(<span class="st">&quot;10zxxzyy&quot;</span>) <span class="kw">{</span> s <span class="kw">&lt;=</span> x <span class="kw">+</span> y <span class="kw">+</span> z <span class="kw">}</span></span>
<span id="cb208-4"><a href="#cb208-4" aria-hidden="true" tabindex="-1"></a><span class="cf">end</span></span></code></pre></div>
<p>It can be noticed for field <code>z</code> in the example above that the bits are not required to be contiguous.</p>
<h2 id="fsm-stdfsm.rb">FSM: <code>std/fsm.rb</code></h2>
<p><a name="fsm"></a></p>
<p>This library provides a new set of control statements for easily describing a finite state machine (FSM).</p>
<p>A finite state machine can be declared anywhere in a system provided it is outside a behavior using the <code>fsm</code> keyword as follows:</p>
<div class="sourceCode" id="cb209"><pre class="sourceCode ruby"><code class="sourceCode ruby"><span id="cb209-1"><a href="#cb209-1" aria-hidden="true" tabindex="-1"></a>fsm(<span class="kw">&lt;</span>event<span class="kw">&gt;</span>,<span class="kw">&lt;</span>reset<span class="kw">&gt;</span>,<span class="kw">&lt;</span>mode<span class="kw">&gt;</span>) <span class="kw">&lt;</span>block<span class="kw">&gt;</span></span></code></pre></div>
<p>Where <code>event</code> is the event (rising or falling edge of a signal) activating the state transitions, <code>rst</code> is the reset signal, <code>mode</code> is the default execution mode, and <code>block</code> is the execution block describing the states of the FSM. This last parameter can be either <code>:sync</code> for synchronous (Moore type) or <code>:async</code> for asynchronous (Mealy type).</p>
<p>The states of an FSM are described as follows:</p>
<div class="sourceCode" id="cb210"><pre class="sourceCode ruby"><code class="sourceCode ruby"><span id="cb210-1"><a href="#cb210-1" aria-hidden="true" tabindex="-1"></a><span class="kw">&lt;</span>kind<span class="kw">&gt;</span>(<span class="kw">&lt;</span>name<span class="kw">&gt;</span>) <span class="kw">&lt;</span>block<span class="kw">&gt;</span></span></code></pre></div>
<p>Where <code>kind</code> is the kind of state, <code>name</code> is the name of the state, and <code>block</code> is the actions to execute for the corresponding state. The kinds of states are the following:</p>
<ul>
<li>reset: the state reached when resetting the FSM. This state can be forced to be asynchronous by setting the <code>name</code> argument to <code>:async</code> and forced to be synchronous by setting the <code>name</code> argument to <code>:sync</code>. By default, the <code>name</code> argument is to be omitted.</li>
<li>state: the default kind of state, will be synchronous if the FSM is synchronous or asynchronous otherwise.</li>
<li>sync: the synchronous kind of state, will be synchronous whatever the kind of FSM is used.</li>
<li>async: the asynchronous kind of state, will be asynchronous whatever the kind of FSM is used.</li>
</ul>
<p>In addition, it is possible to define a default action that will be executed whatever the state is using the following statement:</p>
<div class="sourceCode" id="cb211"><pre class="sourceCode ruby"><code class="sourceCode ruby"><span id="cb211-1"><a href="#cb211-1" aria-hidden="true" tabindex="-1"></a>default <span class="kw">&lt;</span>block<span class="kw">&gt;</span></span></code></pre></div>
<p>Where <code>block</code> is the action to execute.</p>
<p>State transitions are by default set to be from one state to the following in the description order. If no more transition is declared the next one is the first declared transition. A specific transition is defined using the <code>goto</code> statement as the last statement of the action block as follows:</p>
<div class="sourceCode" id="cb212"><pre class="sourceCode ruby"><code class="sourceCode ruby"><span id="cb212-1"><a href="#cb212-1" aria-hidden="true" tabindex="-1"></a>goto(<span class="kw">&lt;</span>condition<span class="kw">&gt;</span>,<span class="kw">&lt;</span>names<span class="kw">&gt;</span>)</span></code></pre></div>
<p>Where <code>condition</code> is a signal whose value is used as an index for selecting the target state among the ones specified in the <code>names</code> list. For example, the following statement indicates to go to the state named <code>st_a</code> if the <code>cond</code> is 0, <code>st_b</code> if the condition is 1, and <code>st_c</code> if the condition is 2, otherwise this specific transition is ignored:</p>
<div class="sourceCode" id="cb213"><pre class="sourceCode ruby"><code class="sourceCode ruby"><span id="cb213-1"><a href="#cb213-1" aria-hidden="true" tabindex="-1"></a>goto(cond,<span class="wa">:st_a</span>,<span class="wa">:st_b</span>,<span class="wa">:st_c</span>)</span></code></pre></div>
<p>Several goto statements can be used, the last one having priority provided it is taken (i.e., its condition corresponds to one of the target states). If no goto is taken, the next transition is the next declared one.</p>
<p>For example, the following code describes an FSM describing a circuit that checks if two buttons (<code>but_a</code> and <code>but_b</code>) are pressed and released in sequence for activating an output signal (<code>ok</code>):</p>
<div class="sourceCode" id="cb214"><pre class="sourceCode ruby"><code class="sourceCode ruby"><span id="cb214-1"><a href="#cb214-1" aria-hidden="true" tabindex="-1"></a>fsm(clk<span class="at">.posedge</span>,rst,<span class="wa">:sync</span>) <span class="cf">do</span></span>
<span id="cb214-2"><a href="#cb214-2" aria-hidden="true" tabindex="-1"></a>   default <span class="kw">{</span> ok <span class="kw">&lt;=</span> <span class="dv">0</span> <span class="kw">}</span></span>
<span id="cb214-3"><a href="#cb214-3" aria-hidden="true" tabindex="-1"></a>   reset <span class="cf">do</span></span>
<span id="cb214-4"><a href="#cb214-4" aria-hidden="true" tabindex="-1"></a>      goto(but_a, <span class="wa">:reset</span>, but_a_on)</span>
<span id="cb214-5"><a href="#cb214-5" aria-hidden="true" tabindex="-1"></a>   <span class="cf">end</span></span>
<span id="cb214-6"><a href="#cb214-6" aria-hidden="true" tabindex="-1"></a>   state(<span class="wa">:but_a_on</span>) <span class="cf">do</span></span>
<span id="cb214-7"><a href="#cb214-7" aria-hidden="true" tabindex="-1"></a>      goto(but_a, <span class="wa">:but_a_off</span>, <span class="wa">:but_a_on</span>)</span>
<span id="cb214-8"><a href="#cb214-8" aria-hidden="true" tabindex="-1"></a>   <span class="cf">end</span></span>
<span id="cb214-9"><a href="#cb214-9" aria-hidden="true" tabindex="-1"></a>   state(<span class="wa">:but_a_off</span>) <span class="cf">do</span></span>
<span id="cb214-10"><a href="#cb214-10" aria-hidden="true" tabindex="-1"></a>      goto(but_b, <span class="wa">:but_a_off</span>, <span class="wa">:but_b_on</span>)</span>
<span id="cb214-11"><a href="#cb214-11" aria-hidden="true" tabindex="-1"></a>   <span class="cf">end</span></span>
<span id="cb214-12"><a href="#cb214-12" aria-hidden="true" tabindex="-1"></a>   state(<span class="wa">:but_b_on</span>) <span class="cf">do</span></span>
<span id="cb214-13"><a href="#cb214-13" aria-hidden="true" tabindex="-1"></a>      goto(but_b, <span class="wa">:but_b_off</span>, <span class="wa">:but_b_on</span>)</span>
<span id="cb214-14"><a href="#cb214-14" aria-hidden="true" tabindex="-1"></a>   <span class="cf">end</span></span>
<span id="cb214-15"><a href="#cb214-15" aria-hidden="true" tabindex="-1"></a>   state(<span class="wa">:but_b_off</span>) <span class="cf">do</span></span>
<span id="cb214-16"><a href="#cb214-16" aria-hidden="true" tabindex="-1"></a>      ok <span class="kw">&lt;=</span> <span class="dv">1</span></span>
<span id="cb214-17"><a href="#cb214-17" aria-hidden="true" tabindex="-1"></a>      goto(<span class="wa">:but_b_off</span>)</span>
<span id="cb214-18"><a href="#cb214-18" aria-hidden="true" tabindex="-1"></a>   <span class="cf">end</span></span>
<span id="cb214-19"><a href="#cb214-19" aria-hidden="true" tabindex="-1"></a><span class="cf">end</span></span></code></pre></div>
<p><strong>Note</strong>: the goto statements act globally, i.e., they are independent of the place where they are declared within the state. For example for both following statements, the next state will always be <code>st_a</code> whatever <code>cond</code> may be:</p>
<div class="sourceCode" id="cb215"><pre class="sourceCode ruby"><code class="sourceCode ruby"><span id="cb215-1"><a href="#cb215-1" aria-hidden="true" tabindex="-1"></a>   state(<span class="wa">:st_0</span>) <span class="cf">do</span></span>
<span id="cb215-2"><a href="#cb215-2" aria-hidden="true" tabindex="-1"></a>      goto(<span class="wa">:st_a</span>)</span>
<span id="cb215-3"><a href="#cb215-3" aria-hidden="true" tabindex="-1"></a>   <span class="cf">end</span></span>
<span id="cb215-4"><a href="#cb215-4" aria-hidden="true" tabindex="-1"></a>   state(<span class="wa">:st_1</span>) <span class="cf">do</span></span>
<span id="cb215-5"><a href="#cb215-5" aria-hidden="true" tabindex="-1"></a>      hif(cond) <span class="kw">{</span> goto(<span class="wa">:st_a</span>) <span class="kw">}</span></span>
<span id="cb215-6"><a href="#cb215-6" aria-hidden="true" tabindex="-1"></a>   <span class="cf">end</span></span></code></pre></div>
<p>That is to say, for a conditional <code>goto</code> for <code>st_1</code> the code should have been written as follows:</p>
<div class="sourceCode" id="cb216"><pre class="sourceCode ruby"><code class="sourceCode ruby"><span id="cb216-1"><a href="#cb216-1" aria-hidden="true" tabindex="-1"></a>   state(<span class="wa">:st_1</span>) <span class="cf">do</span></span>
<span id="cb216-2"><a href="#cb216-2" aria-hidden="true" tabindex="-1"></a>      goto(cond,<span class="wa">:st_a</span>)</span>
<span id="cb216-3"><a href="#cb216-3" aria-hidden="true" tabindex="-1"></a>   <span class="cf">end</span></span></code></pre></div>
<p>The use of <code>goto</code> makes the design of FSM shorter for a majority of the cases, be sometimes, a finer control is required. For that purpose, it is also possible to configure the FSM in <code>static</code> mode where the <code>next_state</code> statement indicates implicitly the next state. Putting in static mode is done by passing <code>:static</code> as an argument when declaring the FSM. For example, the following FSM uses <code>next_state</code> to specify explicitly the next states depending on some condition signals <code>cond0</code> and <code>cond1</code>:</p>
<div class="sourceCode" id="cb217"><pre class="sourceCode ruby"><code class="sourceCode ruby"><span id="cb217-1"><a href="#cb217-1" aria-hidden="true" tabindex="-1"></a>fsm(clk<span class="at">.posedge</span>,rst,<span class="wa">:static</span>)</span>
<span id="cb217-2"><a href="#cb217-2" aria-hidden="true" tabindex="-1"></a>   state(<span class="wa">:st_0</span>) <span class="cf">do</span></span>
<span id="cb217-3"><a href="#cb217-3" aria-hidden="true" tabindex="-1"></a>      next_state(<span class="wa">:st_1</span>)</span>
<span id="cb217-4"><a href="#cb217-4" aria-hidden="true" tabindex="-1"></a>   state(<span class="wa">:st_1</span>) <span class="cf">do</span></span>
<span id="cb217-5"><a href="#cb217-5" aria-hidden="true" tabindex="-1"></a>      hif(cond) <span class="kw">{</span> next_state(<span class="wa">:st_1</span>) <span class="kw">}</span></span>
<span id="cb217-6"><a href="#cb217-6" aria-hidden="true" tabindex="-1"></a>      helse <span class="kw">{</span> next_state(<span class="wa">:st_0</span>) <span class="kw">}</span></span>
<span id="cb217-7"><a href="#cb217-7" aria-hidden="true" tabindex="-1"></a>   <span class="cf">end</span></span>
<span id="cb217-8"><a href="#cb217-8" aria-hidden="true" tabindex="-1"></a><span class="cf">end</span></span></code></pre></div>
<h2 id="sequencer-software-like-hardware-coding-stdsequencer.rb">Sequencer (software-like hardware coding):: <code>std/sequencer.rb</code></h2>
<p><a name="sequencer"></a></p>
<p>This library provides a new set of control statements for describing the behavior of a circuit. Behind the curtain, these constructs build a finite state machine where states are deduced from the control points within the description.</p>
<p>A sequencer can be declared anywhere in a system provided it is outside a behavior using the <code>sequencer</code> keyword as follows:</p>
<div class="sourceCode" id="cb218"><pre class="sourceCode ruby"><code class="sourceCode ruby"><span id="cb218-1"><a href="#cb218-1" aria-hidden="true" tabindex="-1"></a>sequencer(<span class="kw">&lt;</span>clock<span class="kw">&gt;</span>,<span class="kw">&lt;</span>start<span class="kw">&gt;</span>) <span class="kw">&lt;</span>block<span class="kw">&gt;</span></span></code></pre></div>
<p>Where <code>clock</code> is the clock signal advancing the execution of the sequence, <code>start</code> is the signal starting the execution, and <code>block</code> is the description of the sequence to be executed. Both <code>clock</code> and <code>start</code> can also be events (i.e., <code>posedge</code> or <code>negedge</code>).</p>
<p>A sequence is a specific case of a <code>seq</code> block that includes the following software-like additional constructs:</p>
<ul>
<li><p><code>step</code>: wait until the next event (given argument <code>event</code> of the sequencer).</p></li>
<li><p><code>steps(&lt;num&gt;)</code>: perform <code>num</code> times <code>step</code> (<code>num</code> can be any expression).</p></li>
<li><p><code>sif(&lt;condition&gt;) &lt;block&gt;</code>: executes <code>block</code> if <code>condition</code> is met.</p></li>
<li><p><code>selsif(&lt;condition&gt;) &lt;block&gt;</code>: executes <code>block</code> if the previous <code>sif</code> or <code>selsif</code> condition is not met and if the current <code>condition</code> is met.</p></li>
<li><p><code>selse &lt;block&gt;</code>: executes <code>block</code> if the condition of the previous <code>sif</code> statement is not met.</p></li>
<li><p><code>swait(&lt;condition&gt;)</code>: waits until that <code>condition</code> is met.</p></li>
<li><p><code>swhile(&lt;condition&gt;) &lt;block&gt;</code>: executes <code>block</code> while <code>condition</code> is met.</p></li>
<li><p><code>sfor(&lt;enumerable&gt;) &lt;block&gt;</code>: executes <code>block</code> on each element of <code>enumerable</code>. This latter can be any enumerable Ruby object or any signal. If the signal is not hierarchical (e.g., bit vector), the iteration will be over each bit.</p></li>
<li><p><code>sbreak</code>: ends current iteration.</p></li>
<li><p><code>scontinue</code>: goes to the next step of the iteration.</p></li>
<li><p><code>sterminate</code>: ends the execution of the sequence.</p></li>
</ul>
<p>It is also possible to use enumerators (iterators) similar to the Ruby <code>each</code> using the following methods within sequences:</p>
<ul>
<li><p><code>&lt;object&gt;.seach</code>: <code>object</code> any enumerable Ruby object or any signal. If a block is given, it works like <code>sfor</code>, otherwise, it returns a HDLRuby enumerator (please see <a href="#hdlruby-enumerators-and-enumerable-objects-stdsequencerrb">enumerator</a> for details about them).</p></li>
<li><p><code>&lt;object&gt;.stimes</code>: can be used on integers and is equivalent to <code>seach</code> on each integer from 0 up to <code>object-1</code>.</p></li>
<li><p><code>&lt;object&gt;.supto(&lt;last&gt;)</code>: can be used on integers and is equivalent to <code>seach</code> on each integer from <code>object</code> up to <code>last</code>.</p></li>
<li><p><code>&lt;object&gt;.sdownto(&lt;last&gt;)</code>: can be used on an integer and is equivalent to <code>seach</code> on each integer from <code>object</code> down to <code>last</code>.</p></li>
</ul>
<p>The objects that support these methods are called <em>enumerable</em> objects. They include the HDLRuby signals, the HDLRuby enumerators, and all the Ruby enumerable objects (e.g., ranges, arrays).</p>
<p>Here are a few examples of sequencers synchronized in the positive edge of <code>clk</code> and starting when <code>start</code> becomes one. The first one computes the Fibonacci series until 100, producing a new term in signal <code>v</code> at each cycle:</p>
<div class="sourceCode" id="cb219"><pre class="sourceCode ruby"><code class="sourceCode ruby"><span id="cb219-1"><a href="#cb219-1" aria-hidden="true" tabindex="-1"></a><span class="fu">require</span> <span class="vs">&#39;std/sequencer.rb&#39;</span></span>
<span id="cb219-2"><a href="#cb219-2" aria-hidden="true" tabindex="-1"></a><span class="fu">include</span> <span class="dt">HDLRuby</span><span class="kw">::</span><span class="dt">High</span><span class="kw">::</span><span class="dt">Std</span></span>
<span id="cb219-3"><a href="#cb219-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb219-4"><a href="#cb219-4" aria-hidden="true" tabindex="-1"></a><span class="fu">system</span> <span class="wa">:a_circuit</span> <span class="cf">do</span></span>
<span id="cb219-5"><a href="#cb219-5" aria-hidden="true" tabindex="-1"></a>   inner <span class="wa">:clk</span>, <span class="wa">:start</span></span>
<span id="cb219-6"><a href="#cb219-6" aria-hidden="true" tabindex="-1"></a>   <span class="kw">[</span><span class="dv">16</span><span class="kw">]</span><span class="at">.inner</span> <span class="wa">:a</span>, <span class="wa">:b</span></span>
<span id="cb219-7"><a href="#cb219-7" aria-hidden="true" tabindex="-1"></a>   </span>
<span id="cb219-8"><a href="#cb219-8" aria-hidden="true" tabindex="-1"></a>   sequencer(clk<span class="at">.posedge</span>,start) <span class="cf">do</span></span>
<span id="cb219-9"><a href="#cb219-9" aria-hidden="true" tabindex="-1"></a>      a <span class="kw">&lt;=</span> <span class="dv">0</span></span>
<span id="cb219-10"><a href="#cb219-10" aria-hidden="true" tabindex="-1"></a>      b <span class="kw">&lt;=</span> <span class="dv">1</span></span>
<span id="cb219-11"><a href="#cb219-11" aria-hidden="true" tabindex="-1"></a>      swhile(v <span class="kw">&lt;</span> <span class="dv">100</span>) <span class="cf">do</span></span>
<span id="cb219-12"><a href="#cb219-12" aria-hidden="true" tabindex="-1"></a>         b <span class="kw">&lt;=</span> a <span class="kw">+</span> b</span>
<span id="cb219-13"><a href="#cb219-13" aria-hidden="true" tabindex="-1"></a>         a <span class="kw">&lt;=</span> b <span class="kw">-</span> a</span>
<span id="cb219-14"><a href="#cb219-14" aria-hidden="true" tabindex="-1"></a>      <span class="cf">end</span></span>
<span id="cb219-15"><a href="#cb219-15" aria-hidden="true" tabindex="-1"></a>   <span class="cf">end</span></span>
<span id="cb219-16"><a href="#cb219-16" aria-hidden="true" tabindex="-1"></a><span class="cf">end</span></span></code></pre></div>
<p>The second one computes the square of the integers from 10 to 100, producing one result per cycle in signal <code>a</code>:</p>
<div class="sourceCode" id="cb220"><pre class="sourceCode ruby"><code class="sourceCode ruby"><span id="cb220-1"><a href="#cb220-1" aria-hidden="true" tabindex="-1"></a>inner <span class="wa">:clk</span>, <span class="wa">:start</span></span>
<span id="cb220-2"><a href="#cb220-2" aria-hidden="true" tabindex="-1"></a><span class="kw">[</span><span class="dv">16</span><span class="kw">]</span><span class="at">.inner</span> <span class="wa">:a</span></span>
<span id="cb220-3"><a href="#cb220-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb220-4"><a href="#cb220-4" aria-hidden="true" tabindex="-1"></a>sequencer(clk<span class="at">.posedge</span>,start) <span class="cf">do</span></span>
<span id="cb220-5"><a href="#cb220-5" aria-hidden="true" tabindex="-1"></a>   <span class="dv">10</span><span class="at">.supto</span>(<span class="dv">100</span>) <span class="kw">{</span> <span class="kw">|</span>i<span class="kw">|</span> a <span class="kw">&lt;=</span> i<span class="kw">*</span>i <span class="kw">}</span></span>
<span id="cb220-6"><a href="#cb220-6" aria-hidden="true" tabindex="-1"></a><span class="cf">end</span></span></code></pre></div>
<p>The third one reverses the content of memory <code>mem</code> (the result will be “!dlrow olleH”):</p>
<div class="sourceCode" id="cb221"><pre class="sourceCode ruby"><code class="sourceCode ruby"><span id="cb221-1"><a href="#cb221-1" aria-hidden="true" tabindex="-1"></a>inner <span class="wa">:clk</span>, <span class="wa">:start</span></span>
<span id="cb221-2"><a href="#cb221-2" aria-hidden="true" tabindex="-1"></a>bit<span class="kw">[</span><span class="dv">8</span><span class="kw">][-</span><span class="dv">12</span><span class="kw">]</span><span class="at">.inner</span> <span class="wa">mem: </span><span class="st">&quot;Hello world!&quot;</span></span>
<span id="cb221-3"><a href="#cb221-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb221-4"><a href="#cb221-4" aria-hidden="true" tabindex="-1"></a>sequencer(clk<span class="at">.posedge</span>,start) <span class="cf">do</span></span>
<span id="cb221-5"><a href="#cb221-5" aria-hidden="true" tabindex="-1"></a>   mem<span class="at">.size.stimes</span> <span class="cf">do</span> <span class="kw">|</span>i<span class="kw">|</span></span>
<span id="cb221-6"><a href="#cb221-6" aria-hidden="true" tabindex="-1"></a>      <span class="kw">[</span><span class="dv">8</span><span class="kw">]</span><span class="at">.inner</span> <span class="wa">:tmp</span></span>
<span id="cb221-7"><a href="#cb221-7" aria-hidden="true" tabindex="-1"></a>      tmp       <span class="kw">&lt;=</span> mem<span class="kw">[</span>i<span class="kw">]</span></span>
<span id="cb221-8"><a href="#cb221-8" aria-hidden="true" tabindex="-1"></a>      mem<span class="kw">[</span>i<span class="kw">]</span>    <span class="kw">&lt;=</span> mem<span class="kw">[-</span>i<span class="dv">-1</span><span class="kw">]</span></span>
<span id="cb221-9"><a href="#cb221-9" aria-hidden="true" tabindex="-1"></a>      mem<span class="kw">[-</span>i<span class="dv">-1</span><span class="kw">]</span> <span class="kw">&lt;=</span> tmp</span>
<span id="cb221-10"><a href="#cb221-10" aria-hidden="true" tabindex="-1"></a>   <span class="cf">end</span></span>
<span id="cb221-11"><a href="#cb221-11" aria-hidden="true" tabindex="-1"></a><span class="cf">end</span></span></code></pre></div>
<p>The fourth one computes the sum of all the elements of memory <code>mem</code> but stops if the sum is larger than 16:</p>
<div class="sourceCode" id="cb222"><pre class="sourceCode ruby"><code class="sourceCode ruby"><span id="cb222-1"><a href="#cb222-1" aria-hidden="true" tabindex="-1"></a>inner <span class="wa">:clk</span>, <span class="wa">:start</span></span>
<span id="cb222-2"><a href="#cb222-2" aria-hidden="true" tabindex="-1"></a>bit<span class="kw">[</span><span class="dv">8</span><span class="kw">][-</span><span class="dv">8</span><span class="kw">]</span><span class="at">.inner</span> <span class="wa">mem: </span><span class="kw">[</span> _h02, _h04, _h06, _h08, _h0A, _h0C, _h0E <span class="kw">]</span></span>
<span id="cb222-3"><a href="#cb222-3" aria-hidden="true" tabindex="-1"></a>bit<span class="kw">[</span><span class="dv">8</span><span class="kw">]</span> <span class="wa">:sum</span></span>
<span id="cb222-4"><a href="#cb222-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb222-5"><a href="#cb222-5" aria-hidden="true" tabindex="-1"></a>sequencer(clk<span class="at">.posedge</span>,start) <span class="cf">do</span></span>
<span id="cb222-6"><a href="#cb222-6" aria-hidden="true" tabindex="-1"></a>   sum <span class="kw">&lt;=</span> <span class="dv">0</span></span>
<span id="cb222-7"><a href="#cb222-7" aria-hidden="true" tabindex="-1"></a>   sfor(mem) <span class="cf">do</span> <span class="kw">|</span>elem<span class="kw">|</span></span>
<span id="cb222-8"><a href="#cb222-8" aria-hidden="true" tabindex="-1"></a>      sum <span class="kw">&lt;=</span> sum <span class="kw">+</span> elem</span>
<span id="cb222-9"><a href="#cb222-9" aria-hidden="true" tabindex="-1"></a>      sif(sum <span class="kw">&gt;</span> <span class="dv">16</span>) <span class="kw">{</span> sterminate <span class="kw">}</span></span>
<span id="cb222-10"><a href="#cb222-10" aria-hidden="true" tabindex="-1"></a>   <span class="cf">end</span></span>
<span id="cb222-11"><a href="#cb222-11" aria-hidden="true" tabindex="-1"></a><span class="cf">end</span></span></code></pre></div>
<h3 id="hdlruby-enumerators-and-enumerable-objects-stdsequencer.rb">HDLRuby enumerators and enumerable objects: <code>std/sequencer.rb</code></h3>
<p>HDLRuby enumerators are objects for generating iterations within sequencers. They are created using the method <code>seach</code> on enumerable objects as presented in the previous section.</p>
<p>The enumerators can be controlled using the following methods:</p>
<ul>
<li><p><code>size</code>: returns the number of elements the enumerator can access.</p></li>
<li><p><code>type</code>: returns the type of the elements accessed by the enumerator.</p></li>
<li><p><code>seach</code>: returns the current enumerator. If a block is given, it performs the iteration instead of returning an enumerator.</p></li>
<li><p><code>seach_with_index</code>: returns an enumerator over the elements of the current enumerator associated with their index position. If a block is given, it performs the iteration instead of returning an enumerator.</p></li>
<li><p><code>seach_with_object(&lt;obj&gt;)</code>: returns an enumerator over the elements of the current enumerator associated with object <code>obj</code> (any object, HDLRuby or not, can be used). If a block is given, it performs the iteration instead of returning an enumerator.</p></li>
<li><p><code>with_index</code>: identical to <code>seach_with_index</code>.</p></li>
<li><p><code>with_object(&lt;obj&gt;)</code>: identical to <code>seach_with_object</code>.</p></li>
<li><p><code>clone</code>: create a new enumerator on the same elements.</p></li>
<li><p><code>speek</code>: returns the current element pointed by the enumerator without advancing it.</p></li>
<li><p><code>snext</code>: returns the current element pointed by the enumerator and goes to the next one.</p></li>
<li><p><code>srewind</code>: restart the enumeration.</p></li>
<li><p><code>+</code>: concatenation of enumerators.</p></li>
</ul>
<p>It is also possible to define a custom enumerator using the following command:</p>
<div class="sourceCode" id="cb223"><pre class="sourceCode ruby"><code class="sourceCode ruby"><span id="cb223-1"><a href="#cb223-1" aria-hidden="true" tabindex="-1"></a><span class="kw">&lt;</span>enum<span class="kw">&gt;</span> <span class="kw">=</span> senumerator(<span class="kw">&lt;</span>typ<span class="kw">&gt;</span>,<span class="kw">&lt;</span>size<span class="kw">&gt;</span>) <span class="kw">&lt;</span>block<span class="kw">&gt;</span></span></code></pre></div>
<p>Where <code>enum</code> is a Ruby variable referring to the enumerator, <code>typ</code> is the data type, <code>size</code> is the number of the elements to enumerate, and <code>block</code> is the block that implements the access to an element by index. For example, an enumerator on a memory could be defined as follows:</p>
<div class="sourceCode" id="cb224"><pre class="sourceCode ruby"><code class="sourceCode ruby"><span id="cb224-1"><a href="#cb224-1" aria-hidden="true" tabindex="-1"></a>    bit<span class="kw">[</span><span class="dv">8</span><span class="kw">][-</span><span class="dv">8</span><span class="kw">]</span><span class="at">.inner</span> <span class="wa">mem: </span><span class="kw">[</span> _h01, _h02, _h03, _h04, _h30, _h30, _h30, _h30 <span class="kw">]</span></span>
<span id="cb224-2"><a href="#cb224-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">[</span><span class="dv">3</span><span class="kw">]</span><span class="at">.inner</span> <span class="wa">:addr</span></span>
<span id="cb224-3"><a href="#cb224-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">[</span><span class="dv">8</span><span class="kw">]</span><span class="at">.inner</span> <span class="wa">:data</span></span>
<span id="cb224-4"><a href="#cb224-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb224-5"><a href="#cb224-5" aria-hidden="true" tabindex="-1"></a>    data <span class="kw">&lt;=</span> mem<span class="kw">[</span>addr<span class="kw">]</span></span>
<span id="cb224-6"><a href="#cb224-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb224-7"><a href="#cb224-7" aria-hidden="true" tabindex="-1"></a>    mem_enum <span class="kw">=</span> senumerator(bit<span class="kw">[</span><span class="dv">8</span><span class="kw">]</span>,<span class="dv">8</span>) <span class="cf">do</span> <span class="kw">|</span>i<span class="kw">|</span></span>
<span id="cb224-8"><a href="#cb224-8" aria-hidden="true" tabindex="-1"></a>        addr <span class="kw">&lt;=</span> i</span>
<span id="cb224-9"><a href="#cb224-9" aria-hidden="true" tabindex="-1"></a>        step</span>
<span id="cb224-10"><a href="#cb224-10" aria-hidden="true" tabindex="-1"></a>        data</span>
<span id="cb224-11"><a href="#cb224-11" aria-hidden="true" tabindex="-1"></a>    <span class="cf">end</span></span></code></pre></div>
<p>In the code above, <code>mem_enum</code> is the variable referring to the resulting enumerator built for accessing memory <code>mem</code>. For the access, it is assumed that one cycle must be waited for after the address is set, and therefore a <code>step</code> command is added in the access procedure before <code>data</code> can be returned.</p>
<p>With this basis, several algorithms have been implemented using enumerators and are usable for all the enumerable objects. All these algorithms are HW implantation of the Ruby Enumerable methods. They are accessible using the corresponding ruby method prefixed by character <code>s</code>. For example, the HW implementation of the ruby <code>all?</code> method is generated by the <code>sall?</code> method. In details:</p>
<ul>
<li><p><code>sall?</code>: HW implementation of the Ruby <code>all?</code> method. Returns a single-bit signal. When 0 this value means false and when 1 it means true.</p></li>
<li><p><code>sany?</code>: HW implementation of the Ruby <code>any?</code> method. Returns a single-bit signal. When 0 this value means false and when 1 it means true.</p></li>
<li><p><code>schain</code>: HW implementation of the Ruby <code>chain</code>.</p></li>
<li><p><code>smap</code>: HW implementation of the Ruby <code>map</code> method. When used with a block returns a vector signal containing each computation result.</p></li>
<li><p><code>scompact</code>: HW implementation of the Ruby <code>compact</code> method. However, since there is no nil value in HW, use 0 instead for compacting. Returns a vector signal containing the compaction result.</p></li>
<li><p><code>scount</code>: HW implementation of the Ruby <code>count</code> method. Returns a signal whose bit width matches the size of the enumerator containing the count result.</p></li>
<li><p><code>scycle</code>: HW implementation of the Ruby <code>cycle</code> method.</p></li>
<li><p><code>sfind</code>: HW implementation of the Ruby <code>find</code> method. Returns a signal containing the found element, or 0 if not found.</p></li>
<li><p><code>sdrop</code>: HW implementation of the Ruby <code>drop</code> method. Returns a vector signal containing the remaining elements.</p></li>
<li><p><code>sdrop_while</code>: HW implementation of the Ruby <code>drop_while</code> method. Returns a vector signal containing the remaining elements.</p></li>
<li><p><code>seach_cons</code>: HW implementation of the Ruby <code>each_cons</code> method.</p></li>
<li><p><code>seach_slice</code>: HW implementation of the Ruby <code>each_slice</code> method.</p></li>
<li><p><code>seach_with_index</code>: HW implementation of the Ruby <code>each_with_index</code> method.</p></li>
<li><p><code>seach_with_object</code>: HW implementation of the Ruby <code>each_with_object</code> method.</p></li>
<li><p><code>sto_a</code>: HW implementation of the Ruby <code>to_a</code> method. Returns a vector signal containing all the elements of the enumerator.</p></li>
<li><p><code>sselect</code>: HW implementation of the Ruby <code>select</code> method. Returns a vector signal containing the selected elements.</p></li>
<li><p><code>sfind_index</code>: HW implementation of the Ruby <code>find_index</code> method. Returns the index of the found element or -1 if not.</p></li>
<li><p><code>sfirst</code>: HW implementation of the Ruby <code>first</code> method. Returns a vector signal containing the first elements.</p></li>
<li><p><code>sinclude?</code>: HW implementation of the Ruby <code>include?</code> method. Returns a single-bit signal. When 0 this value means false and when 1 it means true.</p></li>
<li><p><code>sinject</code>: HW implementation of the Ruby <code>inject</code> method. Return a signal of the type of elements containing the computation result.</p></li>
<li><p><code>smax</code>: HW implementation of the Ruby <code>max</code> method. Return a vector signal containing the found max values.</p></li>
<li><p><code>smax_by</code>: HW implementation of the Ruby <code>max_by</code> method. Return a vector signal containing the found max values.</p></li>
<li><p><code>smin</code>: HW implementation of the Ruby <code>min</code> method. Return a vector signal containing the found min values.</p></li>
<li><p><code>smin_by</code>: HW implementation of the Ruby <code>min_by</code> method. Return a vector signal containing the found min values.</p></li>
<li><p><code>sminmax</code>: HW implementation of the Ruby <code>minmax</code> method. Returns a 2-element vector signal containing the resulting min and max values.</p></li>
<li><p><code>sminmax_by</code>: HW implementation of the Ruby <code>minmax_by</code> method. Returns a 2-element vector signal containing the resulting min and max values.</p></li>
<li><p><code>snone?</code>: HW implementation of the Ruby <code>none?</code> method. Returns a single-bit signal. When 0 this value means false and when 1 it means true.</p></li>
<li><p><code>sone?</code>: HW implementation of the Ruby <code>one?</code> method. Returns a single-bit signal. When 0 this value means false and when 1 it means true.</p></li>
<li><p><code>sreject</code>: HW implementation of the Ruby <code>reject</code> method. Returns a vector signal containing the remaining elements.</p></li>
<li><p><code>sreverse_each</code>: HW implementation of the Ruby <code>reverse_each</code> method.</p></li>
<li><p><code>ssort</code>: HW implementation of the Ruby <code>sort</code> method. Returns a vector signal containing the sorted elements.</p></li>
<li><p><code>ssort_by</code>: HW implementation of the Ruby <code>sort_by</code> method. Returns a vector signal containing the sorted elements.</p></li>
<li><p><code>ssum</code>: HW implementation of the Ruby <code>sum</code> method. Returns a signal with the type of elements containing the sum result.</p></li>
<li><p><code>stake</code>: HW implementation of the Ruby <code>take</code> method. Returns a vector signal containing the taken elements.</p></li>
<li><p><code>stake_while</code>: HW implementation of the Ruby <code>take_while</code> method. Returns a vector signal containing the taken elements.</p></li>
<li><p><code>suniq</code>: HW implementation the Ruby <code>uniq</code> method. Returns a vector signal containing the selected elements.</p></li>
</ul>
<h3 id="shared-signals-arbiters-and-monitors-stdsequencer_sync.rb">Shared signals, arbiters, and monitors: <code>std/sequencer_sync.rb</code></h3>
<p><a name="shared"></a></p>
<h4 id="shared-signals">Shared signals</h4>
<p>Like any other process, several sequencers can’t write to the same signal. This is because there would be race competition that may physically destroy the device if such operations were authorized. In standard RTL design, this limitation is overcome by implementing three-state buses, multiplexers, and arbiters. However, HDLRuby sequencers support another kind of signal called the <em>shared signals</em> that abstract the implementation details for avoiding race competition.</p>
<p>The shared signals are declared like the other kind of signals from their type. The syntax is the following:</p>
<div class="sourceCode" id="cb225"><pre class="sourceCode ruby"><code class="sourceCode ruby"><span id="cb225-1"><a href="#cb225-1" aria-hidden="true" tabindex="-1"></a><span class="kw">&lt;</span>type<span class="kw">&gt;</span><span class="at">.shared</span> <span class="kw">&lt;</span>list of names<span class="kw">&gt;</span></span></code></pre></div>
<p>They can also have an initial (and default) value when declared as follows:</p>
<div class="sourceCode" id="cb226"><pre class="sourceCode ruby"><code class="sourceCode ruby"><span id="cb226-1"><a href="#cb226-1" aria-hidden="true" tabindex="-1"></a><span class="kw">&lt;</span>type<span class="kw">&gt;</span><span class="at">.shared</span> <span class="kw">&lt;</span>list of names with initialization<span class="kw">&gt;</span></span></code></pre></div>
<p>For example, the following code declares two 8-bit shared signals <code>x</code> and <code>y</code>, and two signed 16-bit shared signals initialized to 0 <code>u</code> and <code>v</code>:</p>
<div class="sourceCode" id="cb227"><pre class="sourceCode ruby"><code class="sourceCode ruby"><span id="cb227-1"><a href="#cb227-1" aria-hidden="true" tabindex="-1"></a><span class="kw">[</span><span class="dv">8</span><span class="kw">]</span><span class="at">.shared</span> <span class="wa">:x</span>, <span class="wa">:y</span></span>
<span id="cb227-2"><a href="#cb227-2" aria-hidden="true" tabindex="-1"></a>signed<span class="kw">[</span><span class="dv">8</span><span class="kw">]</span><span class="at">.shared</span> <span class="wa">u: </span><span class="dv">0</span>, <span class="wa">v: </span><span class="dv">0</span></span></code></pre></div>
<p>A shared signal can then be read and written to by any sequencer from anywhere in the subsequent code of the current scope. However, they cannot be written outside a sequencer. For example, the following code is valid:</p>
<div class="sourceCode" id="cb228"><pre class="sourceCode ruby"><code class="sourceCode ruby"><span id="cb228-1"><a href="#cb228-1" aria-hidden="true" tabindex="-1"></a>input <span class="wa">:clk</span>, <span class="wa">:start</span></span>
<span id="cb228-2"><a href="#cb228-2" aria-hidden="true" tabindex="-1"></a><span class="kw">[</span><span class="dv">8</span><span class="kw">]</span><span class="at">.inner</span> <span class="wa">:val0</span>, <span class="wa">:val1</span></span>
<span id="cb228-3"><a href="#cb228-3" aria-hidden="true" tabindex="-1"></a><span class="kw">[</span><span class="dv">8</span><span class="kw">]</span><span class="at">.shared</span> <span class="wa">:x</span>, <span class="wa">:y</span></span>
<span id="cb228-4"><a href="#cb228-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb228-5"><a href="#cb228-5" aria-hidden="true" tabindex="-1"></a>val0 <span class="kw">&lt;=</span> x<span class="kw">+</span>y</span>
<span id="cb228-6"><a href="#cb228-6" aria-hidden="true" tabindex="-1"></a>par(clk<span class="at">.posedge</span>) <span class="kw">{</span> val1 <span class="kw">&lt;=</span> x<span class="kw">+</span>y <span class="kw">}</span></span>
<span id="cb228-7"><a href="#cb228-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb228-8"><a href="#cb228-8" aria-hidden="true" tabindex="-1"></a>sequencer(clk<span class="at">.posedge</span>,start) <span class="cf">do</span></span>
<span id="cb228-9"><a href="#cb228-9" aria-hidden="true" tabindex="-1"></a>   <span class="dv">10</span><span class="at">.stimes</span> <span class="kw">{</span> <span class="kw">|</span>i<span class="kw">|</span> x <span class="kw">&lt;=</span> i <span class="kw">}</span></span>
<span id="cb228-10"><a href="#cb228-10" aria-hidden="true" tabindex="-1"></a><span class="cf">end</span></span>
<span id="cb228-11"><a href="#cb228-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb228-12"><a href="#cb228-12" aria-hidden="true" tabindex="-1"></a>sequencer(clk<span class="at">.posedge</span>,start) <span class="cf">do</span></span>
<span id="cb228-13"><a href="#cb228-13" aria-hidden="true" tabindex="-1"></a>   <span class="dv">5</span><span class="at">.stimes</span> <span class="kw">{</span> <span class="kw">|</span>i<span class="kw">|</span> x <span class="kw">&lt;=</span> i<span class="kw">*</span><span class="dv">2</span> ; y <span class="kw">&lt;=</span> i<span class="kw">*</span><span class="dv">2</span> <span class="kw">}</span></span>
<span id="cb228-14"><a href="#cb228-14" aria-hidden="true" tabindex="-1"></a><span class="cf">end</span></span></code></pre></div>
<p>But the following code is not valid:</p>
<div class="sourceCode" id="cb229"><pre class="sourceCode ruby"><code class="sourceCode ruby"><span id="cb229-1"><a href="#cb229-1" aria-hidden="true" tabindex="-1"></a><span class="kw">[</span><span class="dv">8</span><span class="kw">]</span><span class="at">.shared</span> <span class="wa">w: </span><span class="dv">0</span></span>
<span id="cb229-2"><a href="#cb229-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb229-3"><a href="#cb229-3" aria-hidden="true" tabindex="-1"></a>par(clk<span class="at">.posedge</span>) <span class="kw">{</span> w <span class="kw">&lt;=</span> w <span class="kw">+</span> <span class="dv">1</span> <span class="kw">}</span></span></code></pre></div>
<p>By default, a shared signal acknowledges writing from the first sequencer that accesses it in order of declaration, the others are ignored. In the first example given above, that means for signal <code>x</code> the value is always the one written by the first sequencer, i.e., from 0 to 9 changing once per clock cycle. However, the value of signal <code>y</code> is set by the second sequencer since it is this one only that writes to this signal.</p>
<p>This default behavior of shared signal avoids race competition but is not very useful in practice. For better control, it is possible to select which sequencer is to be acknowledged for writing. This is done by setting the number of the sequencer which can write the signal that controls the sharing accessed as follows:</p>
<div class="sourceCode" id="cb230"><pre class="sourceCode ruby"><code class="sourceCode ruby"><span id="cb230-1"><a href="#cb230-1" aria-hidden="true" tabindex="-1"></a><span class="kw">&lt;</span>shared signal<span class="kw">&gt;</span><span class="at">.select</span></span></code></pre></div>
<p>The select value starts from 0 for the first sequencer writing to the shared signal and is increased by one per writing sequencer. For example, in the first example, for selecting the second sequencer for writing to <code>x</code> the following code can be added after this signal is declared:</p>
<div class="sourceCode" id="cb231"><pre class="sourceCode ruby"><code class="sourceCode ruby"><span id="cb231-1"><a href="#cb231-1" aria-hidden="true" tabindex="-1"></a>   x<span class="at">.select</span> <span class="kw">&lt;=</span> <span class="dv">1</span></span></code></pre></div>
<p>This value can be changed at runtime too. For example, instead of setting the second sequencer, it is possible to switch the sequencer every clock cycle as follows:</p>
<div class="sourceCode" id="cb232"><pre class="sourceCode ruby"><code class="sourceCode ruby"><span id="cb232-1"><a href="#cb232-1" aria-hidden="true" tabindex="-1"></a>   par(clk<span class="at">.posedge</span>) <span class="kw">{</span> x<span class="at">.select</span> <span class="kw">&lt;=</span> x<span class="at">.select</span> <span class="kw">+</span> <span class="dv">1</span> <span class="kw">}</span></span></code></pre></div>
<p><strong>Note</strong>: this select sub-signal is a standard RTL signal that has the same properties and limitations as the other ones, i.e., this is not a shared signal itself.</p>
<h4 id="arbiters">Arbiters</h4>
<p>Usually, it is not the signals that we want to share, but the resources they drive. For example, with a CPU, it is the ALU that is shared as a whole rather than each of its inputs separately. To support such cases and ease the handling of shared signals, the library also provides the <em>arbiter</em> components. This component is instantiated like a standard module as follows, where <code>name</code> is the name of the arbiter instance:</p>
<div class="sourceCode" id="cb233"><pre class="sourceCode ruby"><code class="sourceCode ruby"><span id="cb233-1"><a href="#cb233-1" aria-hidden="true" tabindex="-1"></a>arbiter(:<span class="kw">&lt;</span>name<span class="kw">&gt;</span>)<span class="kw">.</span>(<span class="kw">&lt;</span>list of shared signal<span class="kw">&gt;</span>)</span></code></pre></div>
<p>When instantiated, an arbiter will take control of the select sub-signals of the shared signals (hence, you cannot control the selection yourself for them any longer). In return, it provides the possibility of requiring or releasing access to the shared signals. Requiring access is done by sending the value 1 to the arbiter, and releasing is done by sending the value 0. If a sequencer writes to a shared signal under arbitration without requiring access first, the write will simply be ignored.</p>
<p>The following is an example of an arbiter that controls access to shared signals <code>x</code> and <code>y</code> and two sequencers acquiring and releasing accesses to them:</p>
<div class="sourceCode" id="cb234"><pre class="sourceCode ruby"><code class="sourceCode ruby"><span id="cb234-1"><a href="#cb234-1" aria-hidden="true" tabindex="-1"></a>input <span class="wa">:clk</span>, <span class="wa">:start</span></span>
<span id="cb234-2"><a href="#cb234-2" aria-hidden="true" tabindex="-1"></a><span class="kw">[</span><span class="dv">8</span><span class="kw">]</span><span class="at">.shared</span> x, y</span>
<span id="cb234-3"><a href="#cb234-3" aria-hidden="true" tabindex="-1"></a>arbiter(<span class="wa">:ctrl_xy</span>)<span class="kw">.</span>(x,y)</span>
<span id="cb234-4"><a href="#cb234-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb234-5"><a href="#cb234-5" aria-hidden="true" tabindex="-1"></a>sequencer(clk<span class="at">.posedge</span>,start) <span class="cf">do</span></span>
<span id="cb234-6"><a href="#cb234-6" aria-hidden="true" tabindex="-1"></a>   ctrl_xy <span class="kw">&lt;=</span> <span class="dv">1</span></span>
<span id="cb234-7"><a href="#cb234-7" aria-hidden="true" tabindex="-1"></a>   x <span class="kw">&lt;=</span> <span class="dv">0</span> ; y <span class="kw">&lt;=</span> <span class="dv">0</span></span>
<span id="cb234-8"><a href="#cb234-8" aria-hidden="true" tabindex="-1"></a>   <span class="dv">5</span><span class="at">.stime</span> <span class="cf">do</span> <span class="kw">|</span>i<span class="kw">|</span></span>
<span id="cb234-9"><a href="#cb234-9" aria-hidden="true" tabindex="-1"></a>      x <span class="kw">&lt;=</span> x <span class="kw">+</span> <span class="dv">1</span></span>
<span id="cb234-10"><a href="#cb234-10" aria-hidden="true" tabindex="-1"></a>      y <span class="kw">&lt;=</span> y <span class="kw">+</span> <span class="dv">2</span></span>
<span id="cb234-11"><a href="#cb234-11" aria-hidden="true" tabindex="-1"></a>   <span class="cf">end</span></span>
<span id="cb234-12"><a href="#cb234-12" aria-hidden="true" tabindex="-1"></a>   ctrl_xy <span class="kw">&lt;=</span> <span class="dv">0</span></span>
<span id="cb234-13"><a href="#cb234-13" aria-hidden="true" tabindex="-1"></a><span class="cf">end</span></span>
<span id="cb234-14"><a href="#cb234-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb234-15"><a href="#cb234-15" aria-hidden="true" tabindex="-1"></a>sequencer(clk<span class="at">.posedge</span>,start) <span class="cf">do</span></span>
<span id="cb234-16"><a href="#cb234-16" aria-hidden="true" tabindex="-1"></a>   ctrl_xy <span class="kw">&lt;=</span> <span class="dv">1</span></span>
<span id="cb234-17"><a href="#cb234-17" aria-hidden="true" tabindex="-1"></a>   x <span class="kw">&lt;=</span> <span class="dv">2</span>; y <span class="kw">&lt;=</span> <span class="dv">1</span></span>
<span id="cb234-18"><a href="#cb234-18" aria-hidden="true" tabindex="-1"></a>   <span class="dv">10</span><span class="at">.stime</span> <span class="cf">do</span> <span class="kw">|</span>i<span class="kw">|</span></span>
<span id="cb234-19"><a href="#cb234-19" aria-hidden="true" tabindex="-1"></a>      x <span class="kw">&lt;=</span> x <span class="kw">+</span> <span class="dv">2</span></span>
<span id="cb234-20"><a href="#cb234-20" aria-hidden="true" tabindex="-1"></a>      y <span class="kw">&lt;=</span> y <span class="kw">+</span> <span class="dv">1</span></span>
<span id="cb234-21"><a href="#cb234-21" aria-hidden="true" tabindex="-1"></a>   <span class="cf">end</span></span>
<span id="cb234-22"><a href="#cb234-22" aria-hidden="true" tabindex="-1"></a>   ctrl_xy <span class="kw">&lt;=</span> <span class="dv">0</span></span>
<span id="cb234-23"><a href="#cb234-23" aria-hidden="true" tabindex="-1"></a><span class="cf">end</span></span></code></pre></div>
<p>In the example, both sequencers require access to signals <code>x</code> and <code>y</code> before accessing them and then releasing the access.</p>
<p>Requiring access does not guarantee that the access will be granted by the arbiter though. In the access is not granted, the write access will be ignored. The default access granting policy of an arbiter is the priority in the order of sequencer declaration. I.e., if several sequencers are requiring one at the same time, then the one declared the earliest in the code gains write access. For example, with the code given above, the first sequencer has to write access to <code>x</code> and <code>y</code>, and since after five write cycles it releases access, the second sequencer can then write to these signals. However, not obtaining write access does not block the execution of the sequencer, simply, its write access to the corresponding shared signals is ignored. In the example, the second sequencer will do its first five loop cycles without any effect and have only its five last ones that change the shared signals. To avoid such a behavior, it is possible to check if the write access is granted using arbiter sub signal <code>acquired</code>: if this signal is one in the current sequencer, that means the access is granted, otherwise it is 0. For example the following will increase signal <code>x</code> only if write access is granted:</p>
<div class="sourceCode" id="cb235"><pre class="sourceCode ruby"><code class="sourceCode ruby"><span id="cb235-1"><a href="#cb235-1" aria-hidden="true" tabindex="-1"></a>hif(ctrl_xy<span class="at">.acquired</span>) <span class="kw">{</span> x <span class="kw">&lt;=</span> x <span class="kw">+</span> <span class="dv">1</span> <span class="kw">}</span></span></code></pre></div>
<p>The policy of an arbiter can be changed using command policy. You can either provide a new priority table, containing the number of the sequencers in order of priority (the first one having higher priority. The number of a sequencer is assigned in order of declaration provided it uses the arbiter. For example, in the previous code, the second sequencer can be given higher priority by adding the following code after having declared the arbiter:</p>
<div class="sourceCode" id="cb236"><pre class="sourceCode ruby"><code class="sourceCode ruby"><span id="cb236-1"><a href="#cb236-1" aria-hidden="true" tabindex="-1"></a>ctrl_xy<span class="at">.policy</span>(<span class="kw">[</span><span class="dv">1</span>,<span class="dv">0</span><span class="kw">]</span>)</span></code></pre></div>
<p>It is also possible to set a more complex policy by providing to the policy method a block of code whose argument is a vector indicating which sequencer is currently requiring write access to the shared signals and whose result will be the number of the sequencer to grant the access. This code will be executed each time write access is performed. For example, in the previous code, a policy switch priorities at each access can be implemented as follows:</p>
<div class="sourceCode" id="cb237"><pre class="sourceCode ruby"><code class="sourceCode ruby"><span id="cb237-1"><a href="#cb237-1" aria-hidden="true" tabindex="-1"></a>inner <span class="wa">priority_xy: </span><span class="dv">0</span></span>
<span id="cb237-2"><a href="#cb237-2" aria-hidden="true" tabindex="-1"></a>inner grant_xy</span>
<span id="cb237-3"><a href="#cb237-3" aria-hidden="true" tabindex="-1"></a>ctrl_xy<span class="at">.policy</span> <span class="cf">do</span> <span class="kw">|</span>acq<span class="kw">|</span></span>
<span id="cb237-4"><a href="#cb237-4" aria-hidden="true" tabindex="-1"></a>   hcase(acq)</span>
<span id="cb237-5"><a href="#cb237-5" aria-hidden="true" tabindex="-1"></a>   hwhen(_b01) <span class="cf">do</span></span>
<span id="cb237-6"><a href="#cb237-6" aria-hidden="true" tabindex="-1"></a>      grant_xy <span class="kw">&lt;=</span> <span class="dv">0</span></span>
<span id="cb237-7"><a href="#cb237-7" aria-hidden="true" tabindex="-1"></a>      priority_xy <span class="kw">&lt;=</span> <span class="kw">~</span>priority_xy</span>
<span id="cb237-8"><a href="#cb237-8" aria-hidden="true" tabindex="-1"></a>   <span class="cf">end</span></span>
<span id="cb237-9"><a href="#cb237-9" aria-hidden="true" tabindex="-1"></a>   hwhen(_b10) <span class="cf">do</span></span>
<span id="cb237-10"><a href="#cb237-10" aria-hidden="true" tabindex="-1"></a>      grant_xy <span class="kw">&lt;=</span> <span class="dv">1</span></span>
<span id="cb237-11"><a href="#cb237-11" aria-hidden="true" tabindex="-1"></a>      priority_xy <span class="kw">&lt;=</span> <span class="kw">~</span>priority_xy</span>
<span id="cb237-12"><a href="#cb237-12" aria-hidden="true" tabindex="-1"></a>   <span class="cf">end</span></span>
<span id="cb237-13"><a href="#cb237-13" aria-hidden="true" tabindex="-1"></a>   hwhen(_b11) <span class="cf">do</span></span>
<span id="cb237-14"><a href="#cb237-14" aria-hidden="true" tabindex="-1"></a>      grant_xy <span class="kw">&lt;=</span> priority_xy</span>
<span id="cb237-15"><a href="#cb237-15" aria-hidden="true" tabindex="-1"></a>      priority_xy <span class="kw">&lt;=</span> <span class="kw">~</span>priority_xy</span>
<span id="cb237-16"><a href="#cb237-16" aria-hidden="true" tabindex="-1"></a>   <span class="cf">end</span></span>
<span id="cb237-17"><a href="#cb237-17" aria-hidden="true" tabindex="-1"></a>   grant_xy</span>
<span id="cb237-18"><a href="#cb237-18" aria-hidden="true" tabindex="-1"></a><span class="cf">end</span></span></code></pre></div>
<p>As seen in the code above, each bit of the <code>acq</code> vector is one when the corresponding sequencer requires access or 0 otherwise, bit 0 corresponds to sequencer 0, bit 1 to sequencer 1, and so on.</p>
<h4 id="monitors">Monitors</h4>
<p>Arbiters are especially useful when we can ensure that the sequencers accessing the same resource do not overlap or when they do not need to synchronize with each other. If such synchronizations are required, instead of arbiters, it is possible to use the <em>monitor</em> components.</p>
<p>The monitor component is instantiated like the arbiters as follows:</p>
<div class="sourceCode" id="cb238"><pre class="sourceCode ruby"><code class="sourceCode ruby"><span id="cb238-1"><a href="#cb238-1" aria-hidden="true" tabindex="-1"></a>monitor(:<span class="kw">&lt;</span>name<span class="kw">&gt;</span>)<span class="kw">.</span>(<span class="kw">&lt;</span>list of shared signals<span class="kw">&gt;</span>)</span></code></pre></div>
<p>Monitors are used the same ways as arbiters (including the write access granting policies) but block the execution of the sequencers that require write access until the access is granted. If we take the example of code with two sequencers given as an illustration of arbiter usage, replacing the arbiter with a monitor as follows will lock the second sequencer until it can write to shared variables <code>x</code> and <code>y</code> ensuring that all its loop cycles have the specified result:</p>
<div class="sourceCode" id="cb239"><pre class="sourceCode ruby"><code class="sourceCode ruby"><span id="cb239-1"><a href="#cb239-1" aria-hidden="true" tabindex="-1"></a>monitor(<span class="wa">:ctrl_xy</span>)<span class="kw">.</span>(x,y)</span></code></pre></div>
<p>Since monitors lock processes, they automatically insert a step. Hence to avoid confusion, acquiring access to a monitor is done by using the method <code>lock</code> instead of assigning 1, and releasing is done by using the method <code>unlock</code> instead of assigning 0. Hence, when using a monitor, the previous arbiter-based code should be rewritten as follows:</p>
<div class="sourceCode" id="cb240"><pre class="sourceCode ruby"><code class="sourceCode ruby"><span id="cb240-1"><a href="#cb240-1" aria-hidden="true" tabindex="-1"></a>input <span class="wa">:clk</span>, <span class="wa">:start</span></span>
<span id="cb240-2"><a href="#cb240-2" aria-hidden="true" tabindex="-1"></a><span class="kw">[</span><span class="dv">8</span><span class="kw">]</span><span class="at">.shared</span> x, y</span>
<span id="cb240-3"><a href="#cb240-3" aria-hidden="true" tabindex="-1"></a>monitor(<span class="wa">:ctrl_xy</span>)<span class="kw">.</span>(x,y)</span>
<span id="cb240-4"><a href="#cb240-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb240-5"><a href="#cb240-5" aria-hidden="true" tabindex="-1"></a>sequencer(clk<span class="at">.posedge</span>,start) <span class="cf">do</span></span>
<span id="cb240-6"><a href="#cb240-6" aria-hidden="true" tabindex="-1"></a>   ctrl_xy<span class="at">.lock</span></span>
<span id="cb240-7"><a href="#cb240-7" aria-hidden="true" tabindex="-1"></a>   x <span class="kw">&lt;=</span> <span class="dv">0</span> ; y <span class="kw">&lt;=</span> <span class="dv">0</span></span>
<span id="cb240-8"><a href="#cb240-8" aria-hidden="true" tabindex="-1"></a>   <span class="dv">5</span><span class="at">.stime</span> <span class="cf">do</span> <span class="kw">|</span>i<span class="kw">|</span></span>
<span id="cb240-9"><a href="#cb240-9" aria-hidden="true" tabindex="-1"></a>      x <span class="kw">&lt;=</span> x <span class="kw">+</span> <span class="dv">1</span></span>
<span id="cb240-10"><a href="#cb240-10" aria-hidden="true" tabindex="-1"></a>      y <span class="kw">&lt;=</span> y <span class="kw">+</span> <span class="dv">2</span></span>
<span id="cb240-11"><a href="#cb240-11" aria-hidden="true" tabindex="-1"></a>   <span class="cf">end</span></span>
<span id="cb240-12"><a href="#cb240-12" aria-hidden="true" tabindex="-1"></a>   ctrl_xy<span class="at">.unlock</span></span>
<span id="cb240-13"><a href="#cb240-13" aria-hidden="true" tabindex="-1"></a><span class="cf">end</span></span>
<span id="cb240-14"><a href="#cb240-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb240-15"><a href="#cb240-15" aria-hidden="true" tabindex="-1"></a>sequencer(clk<span class="at">.posedge</span>,start) <span class="cf">do</span></span>
<span id="cb240-16"><a href="#cb240-16" aria-hidden="true" tabindex="-1"></a>   ctrl_xy<span class="at">.lock</span></span>
<span id="cb240-17"><a href="#cb240-17" aria-hidden="true" tabindex="-1"></a>   x <span class="kw">&lt;=</span> <span class="dv">2</span>; y <span class="kw">&lt;=</span> <span class="dv">1</span></span>
<span id="cb240-18"><a href="#cb240-18" aria-hidden="true" tabindex="-1"></a>   <span class="dv">10</span><span class="at">.stime</span> <span class="cf">do</span> <span class="kw">|</span>i<span class="kw">|</span></span>
<span id="cb240-19"><a href="#cb240-19" aria-hidden="true" tabindex="-1"></a>      x <span class="kw">&lt;=</span> x <span class="kw">+</span> <span class="dv">2</span></span>
<span id="cb240-20"><a href="#cb240-20" aria-hidden="true" tabindex="-1"></a>      y <span class="kw">&lt;=</span> y <span class="kw">+</span> <span class="dv">1</span></span>
<span id="cb240-21"><a href="#cb240-21" aria-hidden="true" tabindex="-1"></a>   <span class="cf">end</span></span>
<span id="cb240-22"><a href="#cb240-22" aria-hidden="true" tabindex="-1"></a>   ctrl_xy<span class="at">.unlock</span></span>
<span id="cb240-23"><a href="#cb240-23" aria-hidden="true" tabindex="-1"></a><span class="cf">end</span></span></code></pre></div>
<h3 id="sequencer-specific-function-stdsequencer_func.rb">Sequencer-specific function: <code>std/sequencer_func.rb</code></h3>
<p>HDLRuby function defined by <code>hdef</code> can be used in a sequencer like any other HDLRuyby construct. But like the process constructs <code>hif</code> and so on, the body of these functions cannot include any sequencer-specific constructs.</p>
<p>However, it is possible to define functions that do support the sequencer constructs using <code>sdef</code> instead of <code>hdef</code> as follows:</p>
<div class="sourceCode" id="cb241"><pre class="sourceCode ruby"><code class="sourceCode ruby"><span id="cb241-1"><a href="#cb241-1" aria-hidden="true" tabindex="-1"></a>   sdef :<span class="kw">&lt;</span>function name<span class="kw">&gt;</span> <span class="cf">do</span> <span class="kw">|&lt;</span>arguments<span class="kw">&gt;|</span></span>
<span id="cb241-2"><a href="#cb241-2" aria-hidden="true" tabindex="-1"></a>   <span class="kw">&lt;</span>sequencer code<span class="kw">&gt;</span></span>
<span id="cb241-3"><a href="#cb241-3" aria-hidden="true" tabindex="-1"></a>   <span class="cf">end</span></span></code></pre></div>
<p>Such functions can be defined anywhere in a HDLRuby description, but can only be called within a sequencer.</p>
<p>As additional features, since the <code>sdef</code> function is made to support the software-like code description of the sequencers, it also supports recursion. For example, a function describing a factorial can be described as follows:</p>
<div class="sourceCode" id="cb242"><pre class="sourceCode ruby"><code class="sourceCode ruby"><span id="cb242-1"><a href="#cb242-1" aria-hidden="true" tabindex="-1"></a>sdef(<span class="wa">:fact</span>) <span class="cf">do</span> <span class="kw">|</span>n<span class="kw">|</span></span>
<span id="cb242-2"><a href="#cb242-2" aria-hidden="true" tabindex="-1"></a>    sif(n <span class="kw">&gt;</span> <span class="dv">1</span>) <span class="kw">{</span> sreturn(n<span class="kw">*</span>fact(n<span class="dv">-1</span>)) <span class="kw">}</span></span>
<span id="cb242-3"><a href="#cb242-3" aria-hidden="true" tabindex="-1"></a>    selse      <span class="kw">{</span> sreturn(<span class="dv">1</span>) <span class="kw">}</span></span>
<span id="cb242-4"><a href="#cb242-4" aria-hidden="true" tabindex="-1"></a><span class="cf">end</span></span></code></pre></div>
<p>As seen in the code above, a new construct <code>sreturn</code> can be used for returning a value from anywhere inside the function.</p>
<p>When a recursion is present, HDLRuby automatically defines a stack for storing the return state and the arguments of the function. The size of the stack is heuristically set to the maximum number of bits of the arguments of the function when it is recursively called. For example, for the previous <code>fact</code> function, if when called, <code>n</code> is 16-bit, the stack will be able to hold 16 recursions. If this heuristic does not match the circuit’s needs, the size can be forced as a second argument when defining the function. For example, the following code sets the size to 32 whatever the arguments are:</p>
<div class="sourceCode" id="cb243"><pre class="sourceCode ruby"><code class="sourceCode ruby"><span id="cb243-1"><a href="#cb243-1" aria-hidden="true" tabindex="-1"></a>sdef(<span class="wa">:fact</span>,<span class="dv">32</span>) <span class="cf">do</span> <span class="kw">|</span>n<span class="kw">|</span></span>
<span id="cb243-2"><a href="#cb243-2" aria-hidden="true" tabindex="-1"></a>    sif(n <span class="kw">&gt;</span> <span class="dv">1</span>) <span class="kw">{</span> sreturn(n<span class="kw">*</span>fact(n<span class="dv">-1</span>)) <span class="kw">}</span></span>
<span id="cb243-3"><a href="#cb243-3" aria-hidden="true" tabindex="-1"></a>    selse      <span class="kw">{</span> sreturn(<span class="dv">1</span>) <span class="kw">}</span></span>
<span id="cb243-4"><a href="#cb243-4" aria-hidden="true" tabindex="-1"></a><span class="cf">end</span></span></code></pre></div>
<p><strong>Notes</strong>:</p>
<ul>
<li><p>A call to such a function and a return take respectively one and two cycles of the sequencer.</p></li>
<li><p>For now, there is no tail call optimization.</p></li>
<li><p>In case of stack overflow (the number of recursive calls exceeds the size of the sack), the current recursion is terminated and the sequencer goes on its execution. It is possible to add a process that is to be executed in such a case as follows:</p>
<div class="sourceCode" id="cb244"><pre class="sourceCode ruby"><code class="sourceCode ruby"><span id="cb244-1"><a href="#cb244-1" aria-hidden="true" tabindex="-1"></a>   sdef(:<span class="kw">&lt;</span>name<span class="kw">&gt;</span>,<span class="kw">&lt;</span>depth<span class="kw">&gt;</span>, <span class="fu">proc</span> <span class="kw">&lt;</span>block<span class="kw">&gt;</span>) <span class="cf">do</span></span>
<span id="cb244-2"><a href="#cb244-2" aria-hidden="true" tabindex="-1"></a>      <span class="kw">&lt;</span>function code<span class="kw">&gt;</span></span>
<span id="cb244-3"><a href="#cb244-3" aria-hidden="true" tabindex="-1"></a>   <span class="cf">end</span></span></code></pre></div>
<p>Where <code>block</code> contains the code of the stack overflow process. For now, this process cannot contain a sequencer construct. For example, the previous factorial function can be modified as follows so that signal <code>stack_overflow</code> is set to 1 in case of overflow:</p>
<div class="sourceCode" id="cb245"><pre class="sourceCode ruby"><code class="sourceCode ruby"><span id="cb245-1"><a href="#cb245-1" aria-hidden="true" tabindex="-1"></a>sdef(<span class="wa">:fact</span>,<span class="dv">32</span>, <span class="fu">proc</span> <span class="kw">{</span> stack_overflow <span class="kw">&lt;=</span> <span class="dv">1</span> <span class="kw">}</span>) <span class="cf">do</span> <span class="kw">|</span>n<span class="kw">|</span></span>
<span id="cb245-2"><a href="#cb245-2" aria-hidden="true" tabindex="-1"></a>    sif(n <span class="kw">&gt;</span> <span class="dv">1</span>) <span class="kw">{</span> sreturn(n<span class="kw">*</span>fact(n<span class="dv">-1</span>)) <span class="kw">}</span></span>
<span id="cb245-3"><a href="#cb245-3" aria-hidden="true" tabindex="-1"></a>    selse      <span class="kw">{</span> sreturn(<span class="dv">1</span>) <span class="kw">}</span></span>
<span id="cb245-4"><a href="#cb245-4" aria-hidden="true" tabindex="-1"></a><span class="cf">end</span></span></code></pre></div>
<p>With the code above, the only restriction is that the signal <code>stack_overflow</code> is declared before the function <code>fact</code> is called.</p></li>
</ul>
<h2 id="fixed-point-fixpoint-stdfixpoint.rb">Fixed-point (fixpoint): <code>std/fixpoint.rb</code></h2>
<p><a name="fixpoint"></a></p>
<p>This library provides a new fixed point set of data types. These new data types can be bit vectors, unsigned or signed values and are declared respectively as follows:</p>
<div class="sourceCode" id="cb246"><pre class="sourceCode ruby"><code class="sourceCode ruby"><span id="cb246-1"><a href="#cb246-1" aria-hidden="true" tabindex="-1"></a>bit<span class="kw">[&lt;</span>integer part range<span class="kw">&gt;</span>,<span class="kw">&lt;</span>fractional part range<span class="kw">&gt;]</span></span>
<span id="cb246-2"><a href="#cb246-2" aria-hidden="true" tabindex="-1"></a>unsigned<span class="kw">[&lt;</span>integer part range<span class="kw">&gt;</span>,<span class="kw">&lt;</span>fractional part range<span class="kw">&gt;]</span></span>
<span id="cb246-3"><a href="#cb246-3" aria-hidden="true" tabindex="-1"></a>signed<span class="kw">[&lt;</span>integer part range<span class="kw">&gt;</span>,<span class="kw">&lt;</span>fractional part range<span class="kw">&gt;]</span></span></code></pre></div>
<p>For example, a signed 4-bit integer part 4-bit fractional part fixed point inner signal named <code>sig</code> can be declared as follows:</p>
<div class="sourceCode" id="cb247"><pre class="sourceCode ruby"><code class="sourceCode ruby"><span id="cb247-1"><a href="#cb247-1" aria-hidden="true" tabindex="-1"></a>bit<span class="kw">[</span><span class="dv">4</span>,<span class="dv">4</span><span class="kw">]</span><span class="at">.inner</span> <span class="wa">:sig</span></span></code></pre></div>
<p>When performing computation with fixed-point types, HDLRuby ensures that the result’s decimal point position is correct.</p>
<p>In addition to the fixed point data type, a method is added to the literal objects (Numeric) to convert them to fixed-point representation:</p>
<div class="sourceCode" id="cb248"><pre class="sourceCode ruby"><code class="sourceCode ruby"><span id="cb248-1"><a href="#cb248-1" aria-hidden="true" tabindex="-1"></a><span class="kw">&lt;</span>litteral<span class="kw">&gt;</span><span class="at">.to_fix</span>(<span class="kw">&lt;</span>number of bits after the decimal point<span class="kw">&gt;</span>)</span></code></pre></div>
<p>For example, the following code converts a floating-point value to a fixed-point value with 16 bits after the decimal point:</p>
<pre><code>3.178.to_fix(16)</code></pre>
<h2 id="channel-stdchannel.rb">Channel: <code>std/channel.rb</code></h2>
<p><a name="channel"></a></p>
<p>This library provides a unified interface to complex communication protocols through a new kind of component called the channels that abstract the details of communication protocols. The channels can be used similarly to the ports of a system and are used through a unified interface so that changing the kind of channel, i.e., the communication protocol, does not require any modification of the code.</p>
<h3 id="using-a-channel">Using a channel</h3>
<p>A channel is used similarly to a pipe: it has an input where data can be written and an output where data can be read. The ordering of the data and the synchronization depend on the internals of the channel, e.g., a channel can be FIFO or LIFO. The interaction with the channel is done using the following methods:</p>
<ul>
<li><code>write(&lt;args&gt;) &lt;block&gt;</code>: write to the channel and execute <code>block</code> when <code>write</code> completes. <code>args</code> is a list of arguments required for performing the write that depends on the channel.</li>
<li><code>read(&lt;args&gt;) &lt;block&gt;</code>: read the channel and execute <code>block</code> when the read completes. <code>args</code> is a list of arguments required for performing the write that depends on the channel.</li>
</ul>
<p>For example, a system sending successive 8-bit values through a channel can be described as follows:</p>
<div class="sourceCode" id="cb250"><pre class="sourceCode ruby"><code class="sourceCode ruby"><span id="cb250-1"><a href="#cb250-1" aria-hidden="true" tabindex="-1"></a><span class="fu">system</span> <span class="wa">:producer8</span> <span class="cf">do</span> <span class="kw">|</span>channel<span class="kw">|</span></span>
<span id="cb250-2"><a href="#cb250-2" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Inputs of the producer: clock and reset.</span></span>
<span id="cb250-3"><a href="#cb250-3" aria-hidden="true" tabindex="-1"></a>    input <span class="wa">:clk</span>, <span class="wa">:rst</span></span>
<span id="cb250-4"><a href="#cb250-4" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Inner 8-bit counter for generating values.</span></span>
<span id="cb250-5"><a href="#cb250-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">[</span><span class="dv">8</span><span class="kw">]</span><span class="at">.inner</span> <span class="wa">:counter</span></span>
<span id="cb250-6"><a href="#cb250-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb250-7"><a href="#cb250-7" aria-hidden="true" tabindex="-1"></a>    <span class="co"># The value production process</span></span>
<span id="cb250-8"><a href="#cb250-8" aria-hidden="true" tabindex="-1"></a>    par(clk<span class="at">.posedge</span>) <span class="cf">do</span></span>
<span id="cb250-9"><a href="#cb250-9" aria-hidden="true" tabindex="-1"></a>        hif(rst) <span class="kw">{</span> counter <span class="kw">&lt;=</span> <span class="dv">0</span> <span class="kw">}</span></span>
<span id="cb250-10"><a href="#cb250-10" aria-hidden="true" tabindex="-1"></a>        helse <span class="cf">do</span></span>
<span id="cb250-11"><a href="#cb250-11" aria-hidden="true" tabindex="-1"></a>            channel<span class="at">.write</span>(counter) <span class="kw">{</span> counter <span class="kw">&lt;=</span> counter <span class="kw">+</span> <span class="dv">1</span> <span class="kw">}</span></span>
<span id="cb250-12"><a href="#cb250-12" aria-hidden="true" tabindex="-1"></a>        <span class="cf">end</span></span>
<span id="cb250-13"><a href="#cb250-13" aria-hidden="true" tabindex="-1"></a>    <span class="cf">end</span></span>
<span id="cb250-14"><a href="#cb250-14" aria-hidden="true" tabindex="-1"></a><span class="cf">end</span></span></code></pre></div>
<p><strong>Note</strong>: In the code above, the channel is passed as a generic argument of the system.</p>
<p>The access points to a channel can also be handled individually by declaring ports using the following methods:</p>
<ul>
<li><code>input &lt;name&gt;</code>: declares a port for reading from the channel and associates them to <code>name</code> if any</li>
<li><code>output &lt;name&gt;</code>: declares a port for writing to the channel and associates them to <code>name</code> if any</li>
<li><code>inout &lt;name&gt;</code>: declares a port for reading and writing to the channel and associates them to <code>name</code> if any</li>
</ul>
<p>Such a port can then be accessed using the same <code>read</code> and <code>write</code> method of a channel, the difference being that they can also be configured for new access procedures using the <code>wrap</code> method:</p>
<ul>
<li><code>wrap(&lt;args&gt;) &lt;code&gt;</code>: creates a new port whose read or write procedure has the elements of <code>&lt;args&gt;</code> and the ones produced by <code>&lt;code&gt;</code> assigned to the arguments of the read or write procedure.</li>
</ul>
<p>For example, assuming <code>mem</code> is a channel whose read and write access have as argument the target address and data signals, the following code creates a port for always accessing at address 0:</p>
<div class="sourceCode" id="cb251"><pre class="sourceCode ruby"><code class="sourceCode ruby"><span id="cb251-1"><a href="#cb251-1" aria-hidden="true" tabindex="-1"></a>  addr0 <span class="kw">=</span> channel<span class="at">.input.wrap</span>(<span class="dv">0</span>) </span></code></pre></div>
<h3 id="channel-branches">Channel branches</h3>
<p>Some channels may include several branches, they are accessed by name using the following method:</p>
<ul>
<li><code>branch(&lt;name&gt;)</code>: gets branch named <code>name</code> from the channel. This name can be any ruby object (e.g., a number) but it will be converted internally to a ruby symbol.</li>
</ul>
<p>A branch is a full-fledged channel and is used identically. For instance, the following code gets access to branch number 0 of channel <code>ch</code>, gets its inputs port, reads it, and put the result in signal <code>val</code> on the rising edges of signal <code>clk</code>:</p>
<div class="sourceCode" id="cb252"><pre class="sourceCode ruby"><code class="sourceCode ruby"><span id="cb252-1"><a href="#cb252-1" aria-hidden="true" tabindex="-1"></a>br <span class="kw">=</span> ch<span class="at">.branch</span>(<span class="dv">0</span>)</span>
<span id="cb252-2"><a href="#cb252-2" aria-hidden="true" tabindex="-1"></a>br<span class="at">.input</span></span>
<span id="cb252-3"><a href="#cb252-3" aria-hidden="true" tabindex="-1"></a>par(clk<span class="at">.posedge</span>) <span class="kw">{</span> br<span class="at">.read</span>(val) <span class="kw">}</span></span></code></pre></div>
<h3 id="declaring-a-channel">Declaring a channel</h3>
<p>A new channel is declared using the keyword <code>channel</code> as follows:</p>
<div class="sourceCode" id="cb253"><pre class="sourceCode ruby"><code class="sourceCode ruby"><span id="cb253-1"><a href="#cb253-1" aria-hidden="true" tabindex="-1"></a>channel <span class="kw">&lt;</span>name<span class="kw">&gt;</span> <span class="kw">&lt;</span>block<span class="kw">&gt;</span></span></code></pre></div>
<p>Where <code>name</code> is the name of the channel and <code>block</code> is a procedure block describing the channel. This block can contain any HDLRuby code, and is comparable to the content of a block describing a system with the difference that it does not have standard input, output, and inout ports are declared differently, and that it supports the following additional keywords:</p>
<ul>
<li><code>reader_input &lt;list of names&gt;</code>: declares the input ports on the reader side. The list must give the names of the inner signals of the channel that can be read using the reader procedure.</li>
<li><code>reader_output &lt;list of names&gt;</code>: declares the output ports on the reader side. The list must give the names of the inner signals of the channel that can be written using the reader procedure.</li>
<li><code>reader_inout &lt;list of names&gt;</code>: declares the inout ports on the reader side. The list must give the names of the inner signals of the channel that can be written using the reader procedure.</li>
<li><code>writer_input &lt;list of names&gt;</code>: declares the input ports on the writer side. The list must give the names of the inner signals of the channel that can be read using the writer procedure.</li>
<li><code>writer_output &lt;list of names&gt;</code>: declares the output ports on the writer side. The list must give the names of the inner signals of the channel that can be written using the writer procedure.</li>
<li><code>writer_inout &lt;list of names&gt;</code>: declares the inout ports on the writer side. The list must give the names of the inner signals of the channel that can be written using the writer procedure.</li>
<li><code>accesser_input &lt;list of names&gt;</code>: declares the input ports on both the reader and writer sides. The list must give the names of the inner signals of the channel that can be read using the writer procedure.</li>
<li><code>accesser_output &lt;list of names&gt;</code>: declares the output ports on both the reader and writer sides. The list must give the names of the inner signals of the channel that can be written using the writer procedure.</li>
<li><code>accesser_inout &lt;list of names&gt;</code>: declares the inout ports on both the reader and writer sides. The list must give the names of the inner signals of the channel that can be written using the writer procedure.</li>
<li><code>reader &lt;block&gt;</code>: defines the reader’s access procedure. This procedure is invoked by the method <code>read</code> of the channel (please refer to the previous example). The first argument of the block must be the following:
<ul>
<li><code>blk</code>: the block to execute when the read completes. Other arguments can be freely defined and will be required by the <code>read</code> method.</li>
</ul></li>
<li><code>writer &lt; block&gt;</code>: defines the writer’s access procedure. This procedure is invoked by the method <code>write</code> of the channel (please refer to the previous example). The first argument of the block must be the following:
<ul>
<li><code>blk</code>: the block to execute when the write completes. Other arguments can be freely defined and will be required by the <code>write</code> command.</li>
</ul></li>
<li><code>brancher(name) &lt;block&gt;</code>: defines branch named +name+ described in <code>block</code>. The content of the block can be any content valid for a channel, with the additional possibility to access the internals of the upper channel.</li>
</ul>
<p>For example, a channel implemented by a simple register of generic type <code>typ</code>, that can be set to 0 using the <code>reset</code> command can be described as follows:</p>
<div class="sourceCode" id="cb254"><pre class="sourceCode ruby"><code class="sourceCode ruby"><span id="cb254-1"><a href="#cb254-1" aria-hidden="true" tabindex="-1"></a>channel <span class="wa">:regch</span> <span class="cf">do</span> <span class="kw">|</span>typ<span class="kw">|</span></span>
<span id="cb254-2"><a href="#cb254-2" aria-hidden="true" tabindex="-1"></a>   <span class="co"># The register.</span></span>
<span id="cb254-3"><a href="#cb254-3" aria-hidden="true" tabindex="-1"></a>   typ<span class="at">.inner</span> <span class="wa">:reg</span></span>
<span id="cb254-4"><a href="#cb254-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb254-5"><a href="#cb254-5" aria-hidden="true" tabindex="-1"></a>   <span class="co"># The reader procedure can read reg</span></span>
<span id="cb254-6"><a href="#cb254-6" aria-hidden="true" tabindex="-1"></a>   reader_input <span class="wa">:reg</span></span>
<span id="cb254-7"><a href="#cb254-7" aria-hidden="true" tabindex="-1"></a>   <span class="co"># The writer procedure can write reg</span></span>
<span id="cb254-8"><a href="#cb254-8" aria-hidden="true" tabindex="-1"></a>   writer_output <span class="wa">:reg</span></span>
<span id="cb254-9"><a href="#cb254-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb254-10"><a href="#cb254-10" aria-hidden="true" tabindex="-1"></a>   <span class="co"># Declares a reset</span></span>
<span id="cb254-11"><a href="#cb254-11" aria-hidden="true" tabindex="-1"></a>   command(<span class="wa">:reset</span>) <span class="kw">{</span> reg <span class="kw">&lt;=</span> <span class="dv">0</span> <span class="kw">}</span></span>
<span id="cb254-12"><a href="#cb254-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb254-13"><a href="#cb254-13" aria-hidden="true" tabindex="-1"></a>   <span class="co"># Defines the reader procedure.</span></span>
<span id="cb254-14"><a href="#cb254-14" aria-hidden="true" tabindex="-1"></a>   reader <span class="cf">do</span> <span class="kw">|</span>blk,target<span class="kw">|</span></span>
<span id="cb254-15"><a href="#cb254-15" aria-hidden="true" tabindex="-1"></a>      target <span class="kw">&lt;=</span> reg</span>
<span id="cb254-16"><a href="#cb254-16" aria-hidden="true" tabindex="-1"></a>      blk<span class="at">.call</span> <span class="cf">if</span> blk</span>
<span id="cb254-17"><a href="#cb254-17" aria-hidden="true" tabindex="-1"></a>   <span class="cf">end</span></span>
<span id="cb254-18"><a href="#cb254-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb254-19"><a href="#cb254-19" aria-hidden="true" tabindex="-1"></a>   <span class="co"># Defines the writer procedure.</span></span>
<span id="cb254-20"><a href="#cb254-20" aria-hidden="true" tabindex="-1"></a>   writer <span class="cf">do</span> <span class="kw">|</span>blk,target<span class="kw">|</span></span>
<span id="cb254-21"><a href="#cb254-21" aria-hidden="true" tabindex="-1"></a>      reg <span class="kw">&lt;=</span> target</span>
<span id="cb254-22"><a href="#cb254-22" aria-hidden="true" tabindex="-1"></a>      blk<span class="at">.call</span> <span class="cf">if</span> blk</span>
<span id="cb254-23"><a href="#cb254-23" aria-hidden="true" tabindex="-1"></a>   <span class="cf">end</span></span>
<span id="cb254-24"><a href="#cb254-24" aria-hidden="true" tabindex="-1"></a><span class="cf">end</span></span></code></pre></div>
<p><strong>Notes</strong>:</p>
<ul>
<li>The described channel assumes that the <code>write</code> method of the channel is invoked within a clocked process (otherwise, the register will become a latch).</li>
<li>The described channel supports the <code>read</code> and <code>write</code> methods to be invoked with or without a block.</li>
</ul>
<p>Like systems, a channel must be instantiated for being used, and the instantiation procedure is identical:</p>
<div class="sourceCode" id="cb255"><pre class="sourceCode ruby"><code class="sourceCode ruby"><span id="cb255-1"><a href="#cb255-1" aria-hidden="true" tabindex="-1"></a><span class="kw">&lt;</span>channel name<span class="kw">&gt;</span> :<span class="kw">&lt;</span>instance name<span class="kw">&gt;</span></span></code></pre></div>
<p>And in case there is a generic parameter, the instantiation procedure is as follows:</p>
<div class="sourceCode" id="cb256"><pre class="sourceCode ruby"><code class="sourceCode ruby"><span id="cb256-1"><a href="#cb256-1" aria-hidden="true" tabindex="-1"></a><span class="kw">&lt;</span>channel name<span class="kw">&gt;</span>(:<span class="kw">&lt;</span>instance name<span class="kw">&gt;</span>)<span class="kw">.</span>(<span class="kw">&lt;</span>generic parameters<span class="kw">&gt;</span>)</span></code></pre></div>
<p>After a channel is instantiated, it must be linked to the circuits that will communicate through it. This is done when instantiating these circuits. If a circuit reads or writes on the channel, it will be instantiated as follows:</p>
<div class="sourceCode" id="cb257"><pre class="sourceCode ruby"><code class="sourceCode ruby"><span id="cb257-1"><a href="#cb257-1" aria-hidden="true" tabindex="-1"></a><span class="kw">&lt;</span><span class="fu">system</span> name<span class="kw">&gt;</span>(<span class="kw">&lt;</span>channel instance<span class="kw">&gt;</span>)<span class="kw">.</span>(:<span class="kw">&lt;</span>instance name<span class="kw">&gt;</span>)<span class="kw">.</span>(<span class="kw">&lt;</span>circuit standard connections<span class="kw">&gt;</span>)</span></code></pre></div>
<p><strong>Notes</strong>:</p>
<ul>
<li>It is possible for a circuit to access several channels. For that purpose, each channel must be passed as generic arguments, and their corresponding <code>reader_signals</code> and <code>writer_signals</code> are to be put in the order of declaration.</li>
<li>It is also possible for a circuit to read and write on the same channel. For that purpose, the channel will be passed several times as generic arguments, and the corresponding <code>reader_signals</code> and <code>writer_signals</code> are to be put in the order of declaration.</li>
</ul>
<p>The following code is an example instantiating the register channel presented above for connecting an instance of <code>producer8</code> and another circuit called <code>consumer8</code>:</p>
<div class="sourceCode" id="cb258"><pre class="sourceCode ruby"><code class="sourceCode ruby"><span id="cb258-1"><a href="#cb258-1" aria-hidden="true" tabindex="-1"></a><span class="co"># System wrapping the producer and the consumer circuits.</span></span>
<span id="cb258-2"><a href="#cb258-2" aria-hidden="true" tabindex="-1"></a><span class="fu">system</span> <span class="wa">:producer_consumer8</span> <span class="cf">do</span></span>
<span id="cb258-3"><a href="#cb258-3" aria-hidden="true" tabindex="-1"></a>   <span class="co"># The clock and reset of the circuits</span></span>
<span id="cb258-4"><a href="#cb258-4" aria-hidden="true" tabindex="-1"></a>   input <span class="wa">:clk</span>, <span class="wa">:rst</span></span>
<span id="cb258-5"><a href="#cb258-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb258-6"><a href="#cb258-6" aria-hidden="true" tabindex="-1"></a>   <span class="co"># Instance of the channel (using 8-bit data).</span></span>
<span id="cb258-7"><a href="#cb258-7" aria-hidden="true" tabindex="-1"></a>   regch(<span class="kw">[</span><span class="dv">8</span><span class="kw">]</span>)<span class="kw">.</span>(<span class="wa">:regchI</span>)</span>
<span id="cb258-8"><a href="#cb258-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb258-9"><a href="#cb258-9" aria-hidden="true" tabindex="-1"></a>   <span class="co"># Reset the channel on positive edges of signal rst.</span></span>
<span id="cb258-10"><a href="#cb258-10" aria-hidden="true" tabindex="-1"></a>   regchI<span class="at">.reset.at</span>(rst<span class="at">.posedge</span>)</span>
<span id="cb258-11"><a href="#cb258-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb258-12"><a href="#cb258-12" aria-hidden="true" tabindex="-1"></a>   <span class="co"># Instantiate the producer.</span></span>
<span id="cb258-13"><a href="#cb258-13" aria-hidden="true" tabindex="-1"></a>   producer8(regch)<span class="kw">.</span>(<span class="wa">:producerI</span>)<span class="kw">.</span>(clk,rst)</span>
<span id="cb258-14"><a href="#cb258-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb258-15"><a href="#cb258-15" aria-hidden="true" tabindex="-1"></a>   <span class="co"># Instantiate the consumer.</span></span>
<span id="cb258-16"><a href="#cb258-16" aria-hidden="true" tabindex="-1"></a>   consumer8(regch)<span class="kw">.</span>(<span class="wa">:consumerI</span>)<span class="kw">.</span>(clk<span class="at">.rst</span>)</span>
<span id="cb258-17"><a href="#cb258-17" aria-hidden="true" tabindex="-1"></a><span class="cf">end</span></span></code></pre></div>
<p><strong>Note</strong>:</p>
<ul>
<li>The code of the circuits, in the examples <code>producer8</code>, <code>consumer8</code>, and <code>producer_consummer8</code> is independent of the content of the channel. For example, the sample <code>with_channel.rb</code> (please see <a href="#sample-hdlruby-descriptions">samples</a>) uses the same circuits with a channel implementing handshaking.</li>
</ul>
<!---

## Pipeline
<a name="pipeline"></a>

This library provides a construct for an easy description of pipeline architectures.

-->
<h1 id="sample-hdlruby-descriptions">Sample HDLRuby descriptions</h1>
<p>Several samples HDLRuby descriptions are available in the following directory:</p>
<p>path/to/HDLRuby/lib/HDLRuby/hdr_samples</p>
<p>For the gem install, the path to HDLRuby can be found using the following:</p>
<div class="sourceCode" id="cb259"><pre class="sourceCode bash"><code class="sourceCode bash"><span id="cb259-1"><a href="#cb259-1" aria-hidden="true" tabindex="-1"></a><span class="ex">gem</span> which HDLRuby</span></code></pre></div>
<p>But you can also import the samples to your local directory with the following command (recommended):</p>
<div class="sourceCode" id="cb260"><pre class="sourceCode bash"><code class="sourceCode bash"><span id="cb260-1"><a href="#cb260-1" aria-hidden="true" tabindex="-1"></a><span class="ex">hdrcc</span> <span class="at">--get-samples</span></span></code></pre></div>
<p>The naming convention of the samples is the following:</p>
<ul>
<li><code>&lt;name&gt;.rb</code>: default type of sample.</li>
<li><code>&lt;name&gt;_gen.rb</code>: generic parameters are required for processing the sample.</li>
<li><code>&lt;name&gt;_bench.rb</code>: sample including a simulation benchmark, these are the only samples that can be simulated using <code>hdrcc -S</code>. Please notice that such a sample cannot be converted to VHDL or Verilog HDL yet.</li>
<li><code>with_&lt;name&gt;.rb</code>: sample illustrating a single aspect of HDLRuby or one of its libraries, usually includes a benchmark.</li>
</ul>
<h1 id="contributing">Contributing</h1>
<p>Bug reports and pull requests are welcome on GitHub at https://github.com/civol/HDLRuby.</p>
<h1 id="to-do">To do</h1>
<ul>
<li>Find and fix the (maybe) terrifying number of bugs.</li>
<li>Add a GUI (any volunteer to do it?).</li>
</ul>
<h1 id="license">License</h1>
<p>The gem is available as open-source under the terms of the <a href="http://opensource.org/licenses/MIT">MIT License</a>.</p>

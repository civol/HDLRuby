# Use either Gosu or Curses.
$mode = :gosu
begin
  require "gosu"
rescue LoadError
  $mode = :curses
  require "curses"
end

require "rubyHDL.rb"

if $mode == :gosu then

  # Class representing the CRT monitor in Gosu
  class CRT < Gosu::Window
    def initialize(width=640,height=480,px_width,px_height)
      super(width,height,false)

      @px_width  = px_width
      @px_height = px_height
      @cols = width / @px_width
      @rows = height / @px_height
      # puts "px_width=#{px_width} px_height=#{px_height} cols=#{@cols} rows=#{@rows}"

      # The screen buffer.
      @buf = [ Gosu::Color::BLACK ] * (@cols * @rows)

      # The last pressed key
      @key = nil
    end

    def update
      # puts "Updated."
    end

    def draw
      @rows.times do |y|
        pos_y = y * @px_height
        # puts "y=#{y} pos_y=#{pos_y}"
        off_y = y * @cols
        @cols.times do |x|
          pos_x = x * @px_width
          draw_rect(pos_x,pos_y, @px_width, @px_height,@buf[x+off_y])
        end
      end
    end

    def button_down(id)
      @key = id
    end

    def put_pixel(x,y,val)
      # puts "put_pixel x=#{x} y=#{y}"
      @buf[x+y*@cols] = val
    end

    def getch
      sleep(0.02) while(@key == nil) 
      case(@key)
      when Gosu::KB_ESCAPE
        res = 27.chr
      when Gosu::KB_RETURN
        res = 10.chr
      when Gosu::KB_BACKSPACE
        res = 127.chr
      else
        res = Gosu.button_id_to_char(@key)
      end
      # puts "res=#{res}" if !res.empty?
      @key = nil
      return res
    end
  end


  class TermEMU
    # The dimensions of the screen in pixels.
    attr_reader :cols, :lines

    # Initializes the screen.
    def startup(width = 320, height = 240)
      # Set the size of the screen and create it.
      @width = width
      @height = height
      # Set the size of a pixel.
      @px_width  = 4
      @px_height = 4
      # Set the number of columns and lines.
      @cols = @width / @px_width
      @lines = @height / @px_height
      # Create the screen.
      @crt = CRT.new(width,height,@px_width,@px_height)
      @crt.tick
      # Sets the color black
      @px_black  = " ".ord
    end

    # Closes the application.
    def terminate
      exit
    end

    # Refresh the screen.
    def refresh
      # In case of GOSU, it is not required to do anything here.
      @crt.tick
    end

    # Draw a pixel.
    def put_pixel(x,y,val)
      if val == @px_black then
        @crt.put_pixel(x,y,Gosu::Color::BLACK)
      else
        @crt.put_pixel(x,y,Gosu::Color::WHITE)
      end
    end

    # Get a keyboard input.
    def getch
      return @crt.getch
    end
  end

else


  class TermEMU
    include Curses

    # Initializes the screen.
    def startup
      init_screen
      crmode
      noecho
      curs_set(1)
    end

    # Closes the screen.
    def terminate
      close_screen
    end

    # Draw a pixel.
    def put_pixel(x,y,val)
      setpos(y,x)
      addstr(val.chr)
    end
  end
end

$termEMU = TermEMU.new   

# Ruby set of programs that simulate:
# * A CPU executing a shell
# * Its memory
# * A monitor
# * A keyboard communicating using UART

V_ADDR = 0xC000
K_ADDR = 0xB000

# The global simulation configuration parameters.
def configure
  # Initialize the system.

  begin
    # For the monitor.
    $termEMU.startup

    RubyHDL.hSIZE = $termEMU.cols
    RubyHDL.hSTART = 10
    RubyHDL.hEND   = 10
    RubyHDL.vSIZE = $termEMU.lines
    RubyHDL.vSTART = 10
    RubyHDL.vEND   = 10
  rescue
    # Failed to initialize the monitor.
    $termEMU.terminate
    puts "Could not initialize the monitor."
    exit
  end

  # For the keyboard.
  RubyHDL.rxCYCLE = 8

  # For the memory mapping of the devices.
  RubyHDL.vADDR = V_ADDR
  RubyHDL.kADDR = K_ADDR
end


# Simulation of the CPU memory: filled with "." for debug purpose.
class MemoryChip
  def initialize(size,width = 8, memory_map = {})
    @sync  = Mutex.new
    @width = width
    @data_mask = (2 << @width) - 1
    @addr_mask = (2 << size) - 1
    @cells = [0] * size
    @memory_map = memory_map
  end

  def synchronize(&ruby_block)
    @sync.synchronize(&ruby_block)
  end

  # Read the memory.
  def [](addr)
    addr = addr.to_i & @addr_mask
    # Is it a memory mapped address?
    loc = @memory_map[addr]
    return loc.call if loc # Yes.
    # No, normal access.
    return @cells[addr]
  end

  # Write the memory.
  def []=(addr,val)
    addr = addr.to_i & @addr_mask
    val  = val.to_i  & @data_mask
    # Is it a memory mapped address?
    loc = @memory_map[addr]
    return loc.call(val) if loc
    # No, normal access.
    @cells[addr] = val
  end
end

MEM = MemoryChip.new(65536, 8, { K_ADDR => proc { RubyHDL.key_reg } })



# The software tasks (processes and handlers).
$tasks = []

# Simulate the reset: set up the tasks.
def cpu_rst
  # Are there any running task?
  $tasks.each do |task|
    if task then
      # First kill it.
      task.kill
    end
  end

  # Create the new process task (the shell application).
  $tasks[0] = Thread.new(&Kernel.method(:shell))
end

# Simulate the irq.
def cpu_irq
  # Tell the interrupt is being serviced.
  RubyHDL.ack = 1
  # Launch the handler.
  # Kernel.send(:handler)
  $tasks[1] = Thread.new(&Kernel.method(:handler))
end

# Simulate the wake of the process.
def iwake
  $tasks[0].run
end

# Simulate the return from interrupt instruction.
def iret
  # Rmove the handler task.
  $tasks[1] = nil
  # Tells the interrupt servicing is over.
  RubyHDL.ack = 0
end




# Simulation of the CPU bus and the underlining OS execution.
def cpu_bus
  # Is there a bus request?
  if RubyHDL.br == 1 then
    # Yes, grant it.
    RubyHDL.bg = 1
  else
    # No, release it.
    RubyHDL.bg = 0
  end

  # Is there a memory read?
  MEM.synchronize do
    if RubyHDL.rwb == 1 then
      # Read.
      RubyHDL.dout = MEM[RubyHDL.aout]
      # else
      #     # Write.
      #     MEM[RubyHDL.ain] = RubyHDL.din
    end
  end

  # Now wake the handler if any.
  $tasks[1].run if $tasks[1]
end



$monitorX = 0
$monitorY = 0

# Frame skipping for speeding up monitor.
if $mode == :gosu then
  FRAME_SKIP = 100
else
  FRAME_SKIP = 9
end
$frame = 0
$refreshed = false

# Simulate the monitor.
def monitor
  if RubyHDL.vblank == 1 then
    # Vertical blank.
    $monitorX = 0
    $monitorY = 0
    # Refresh display (if frame not skipped).
    if $frame == FRAME_SKIP then
      $frame = 0
      if !$refreshed  then
        $termEMU.refresh
        $refreshed = true
      end
    else
      $frame += 1
    end
  elsif RubyHDL.hblank == 1 then
    # Horizontal blank.
    if $monitorX != 0 then
      # Start of horizontal blank, increase Y and reset X.
      $monitorY += 1
      $monitorX = 0
    end
  else
    $refreshed = false
    # Normal run.
    # Display the pixel.
    if RubyHDL.pixel > 0 then
      $termEMU.put_pixel($monitorX,$monitorY,RubyHDL.pixel)
    end
    # Increase the X position.
    $monitorX += 1
  end
end


# Simulate the UART keyboard.

# The key buffer.
$key = nil
# The thread waiting for a key in ncurses.
$key_waiter = Thread.new do
  loop do
    if $termEMU then
      ch = $termEMU.getch
      $key = ch.ord if !ch.empty?
    end
  end
end

# Bit position (-1 if no transmission).
$key_bitpos = -1

def keyboard
  # Is there a key pressed and a previous one is not being sent.
  if $key and $key_bitpos == -1 then
    # Start a new transmission.
    $key_bitpos = 0
    RubyHDL.rx = 0
  elsif $key_bitpos >= 0 and $key_bitpos < 8 then
    # A key is in transmission, go on.
    RubyHDL.rx = ($key >> (7-$key_bitpos)) & 1
    $key_bitpos += 1
  else
    # End of transmission, or no transmission.
    RubyHDL.rx = 1
    $key_bitpos = -1
    # Clears the key.
    $key = nil
  end
end


## The actual software part.

# The interrupt handler.
def handler
  # Wake the process.
  iwake
  # Wait several clock cycles (simulate SW execution time).
  10.times { sleep }
  # Return from interrupt.
  iret
end


# The font used for displaying.
#  * 8x8 monochrome bitmap fonts for rendering
#  * Author: Daniel Hepper <daniel@hepper.net>
#  *
#  * License: Public Domain
#  *
#  * Based on:
#  * // Summary: font8x8.h
#  * // 8x8 monochrome bitmap fonts for rendering
#  * //
#  * // Author:
#  * //     Marcel Sondaar
#  * //     International Business Machines (public domain VGA fonts)
#  * //
#  * // License:
#  * //     Public Domain
#  *
#  * Fetched from: http://dimensionalrift.homelinux.net/combuster/mos3/?p=viewsource&file=/modules/gfx/font8_8.asm
#  Constant: font8x8_basic
# Contains an 8x8 font map for unicode points U+0000 - U+007F (basic latin)
Font8x8_basic = [
  [ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00],   # U+0000 (nul)
  [ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00],   # U+0001
  [ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00],   # U+0002
  [ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00],   # U+0003
  [ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00],   # U+0004
  [ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00],   # U+0005
  [ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00],   # U+0006
  [ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00],   # U+0007
  [ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00],   # U+0008
  [ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00],   # U+0009
  [ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00],   # U+000A
  [ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00],   # U+000B
  [ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00],   # U+000C
  [ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00],   # U+000D
  [ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00],   # U+000E
  [ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00],   # U+000F
  [ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00],   # U+0010
  [ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00],   # U+0011
  [ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00],   # U+0012
  [ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00],   # U+0013
  [ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00],   # U+0014
  [ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00],   # U+0015
  [ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00],   # U+0016
  [ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00],   # U+0017
  [ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00],   # U+0018
  [ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00],   # U+0019
  [ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00],   # U+001A
  [ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00],   # U+001B
  [ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00],   # U+001C
  [ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00],   # U+001D
  [ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00],   # U+001E
  [ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00],   # U+001F
  [ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00],   # U+0020 (space)
  [ 0x18, 0x3C, 0x3C, 0x18, 0x18, 0x00, 0x18, 0x00],   # U+0021 (!)
  [ 0x36, 0x36, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00],   # U+0022 (")
  [ 0x36, 0x36, 0x7F, 0x36, 0x7F, 0x36, 0x36, 0x00],   # U+0023 (#)
  [ 0x0C, 0x3E, 0x03, 0x1E, 0x30, 0x1F, 0x0C, 0x00],   # U+0024 ($)
  [ 0x00, 0x63, 0x33, 0x18, 0x0C, 0x66, 0x63, 0x00],   # U+0025 (%)
  [ 0x1C, 0x36, 0x1C, 0x6E, 0x3B, 0x33, 0x6E, 0x00],   # U+0026 (&)
  [ 0x06, 0x06, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00],   # U+0027 (')
  [ 0x18, 0x0C, 0x06, 0x06, 0x06, 0x0C, 0x18, 0x00],   # U+0028 (()
  [ 0x06, 0x0C, 0x18, 0x18, 0x18, 0x0C, 0x06, 0x00],   # U+0029 ())
  [ 0x00, 0x66, 0x3C, 0xFF, 0x3C, 0x66, 0x00, 0x00],   # U+002A (*)
  [ 0x00, 0x0C, 0x0C, 0x3F, 0x0C, 0x0C, 0x00, 0x00],   # U+002B (+)
  [ 0x00, 0x00, 0x00, 0x00, 0x00, 0x0C, 0x0C, 0x06],   # U+002C (,)
  [ 0x00, 0x00, 0x00, 0x3F, 0x00, 0x00, 0x00, 0x00],   # U+002D (-)
  [ 0x00, 0x00, 0x00, 0x00, 0x00, 0x0C, 0x0C, 0x00],   # U+002E (.)
  [ 0x60, 0x30, 0x18, 0x0C, 0x06, 0x03, 0x01, 0x00],   # U+002F (/)
  [ 0x3E, 0x63, 0x73, 0x7B, 0x6F, 0x67, 0x3E, 0x00],   # U+0030 (0)
  [ 0x0C, 0x0E, 0x0C, 0x0C, 0x0C, 0x0C, 0x3F, 0x00],   # U+0031 (1)
  [ 0x1E, 0x33, 0x30, 0x1C, 0x06, 0x33, 0x3F, 0x00],   # U+0032 (2)
  [ 0x1E, 0x33, 0x30, 0x1C, 0x30, 0x33, 0x1E, 0x00],   # U+0033 (3)
  [ 0x38, 0x3C, 0x36, 0x33, 0x7F, 0x30, 0x78, 0x00],   # U+0034 (4)
  [ 0x3F, 0x03, 0x1F, 0x30, 0x30, 0x33, 0x1E, 0x00],   # U+0035 (5)
  [ 0x1C, 0x06, 0x03, 0x1F, 0x33, 0x33, 0x1E, 0x00],   # U+0036 (6)
  [ 0x3F, 0x33, 0x30, 0x18, 0x0C, 0x0C, 0x0C, 0x00],   # U+0037 (7)
  [ 0x1E, 0x33, 0x33, 0x1E, 0x33, 0x33, 0x1E, 0x00],   # U+0038 (8)
  [ 0x1E, 0x33, 0x33, 0x3E, 0x30, 0x18, 0x0E, 0x00],   # U+0039 (9)
  [ 0x00, 0x0C, 0x0C, 0x00, 0x00, 0x0C, 0x0C, 0x00],   # U+003A (:)
  [ 0x00, 0x0C, 0x0C, 0x00, 0x00, 0x0C, 0x0C, 0x06],   # U+003B (;)
  [ 0x18, 0x0C, 0x06, 0x03, 0x06, 0x0C, 0x18, 0x00],   # U+003C (<)
  [ 0x00, 0x00, 0x3F, 0x00, 0x00, 0x3F, 0x00, 0x00],   # U+003D (=)
  [ 0x06, 0x0C, 0x18, 0x30, 0x18, 0x0C, 0x06, 0x00],   # U+003E (>)
  [ 0x1E, 0x33, 0x30, 0x18, 0x0C, 0x00, 0x0C, 0x00],   # U+003F (?)
  [ 0x3E, 0x63, 0x7B, 0x7B, 0x7B, 0x03, 0x1E, 0x00],   # U+0040 (@)
  [ 0x0C, 0x1E, 0x33, 0x33, 0x3F, 0x33, 0x33, 0x00],   # U+0041 (A)
  [ 0x3F, 0x66, 0x66, 0x3E, 0x66, 0x66, 0x3F, 0x00],   # U+0042 (B)
  [ 0x3C, 0x66, 0x03, 0x03, 0x03, 0x66, 0x3C, 0x00],   # U+0043 (C)
  [ 0x1F, 0x36, 0x66, 0x66, 0x66, 0x36, 0x1F, 0x00],   # U+0044 (D)
  [ 0x7F, 0x46, 0x16, 0x1E, 0x16, 0x46, 0x7F, 0x00],   # U+0045 (E)
  [ 0x7F, 0x46, 0x16, 0x1E, 0x16, 0x06, 0x0F, 0x00],   # U+0046 (F)
  [ 0x3C, 0x66, 0x03, 0x03, 0x73, 0x66, 0x7C, 0x00],   # U+0047 (G)
  [ 0x33, 0x33, 0x33, 0x3F, 0x33, 0x33, 0x33, 0x00],   # U+0048 (H)
  [ 0x1E, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x1E, 0x00],   # U+0049 (I)
  [ 0x78, 0x30, 0x30, 0x30, 0x33, 0x33, 0x1E, 0x00],   # U+004A (J)
  [ 0x67, 0x66, 0x36, 0x1E, 0x36, 0x66, 0x67, 0x00],   # U+004B (K)
  [ 0x0F, 0x06, 0x06, 0x06, 0x46, 0x66, 0x7F, 0x00],   # U+004C (L)
  [ 0x63, 0x77, 0x7F, 0x7F, 0x6B, 0x63, 0x63, 0x00],   # U+004D (M)
  [ 0x63, 0x67, 0x6F, 0x7B, 0x73, 0x63, 0x63, 0x00],   # U+004E (N)
  [ 0x1C, 0x36, 0x63, 0x63, 0x63, 0x36, 0x1C, 0x00],   # U+004F (O)
  [ 0x3F, 0x66, 0x66, 0x3E, 0x06, 0x06, 0x0F, 0x00],   # U+0050 (P)
  [ 0x1E, 0x33, 0x33, 0x33, 0x3B, 0x1E, 0x38, 0x00],   # U+0051 (Q)
  [ 0x3F, 0x66, 0x66, 0x3E, 0x36, 0x66, 0x67, 0x00],   # U+0052 (R)
  [ 0x1E, 0x33, 0x07, 0x0E, 0x38, 0x33, 0x1E, 0x00],   # U+0053 (S)
  [ 0x3F, 0x2D, 0x0C, 0x0C, 0x0C, 0x0C, 0x1E, 0x00],   # U+0054 (T)
  [ 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x3F, 0x00],   # U+0055 (U)
  [ 0x33, 0x33, 0x33, 0x33, 0x33, 0x1E, 0x0C, 0x00],   # U+0056 (V)
  [ 0x63, 0x63, 0x63, 0x6B, 0x7F, 0x77, 0x63, 0x00],   # U+0057 (W)
  [ 0x63, 0x63, 0x36, 0x1C, 0x1C, 0x36, 0x63, 0x00],   # U+0058 (X)
  [ 0x33, 0x33, 0x33, 0x1E, 0x0C, 0x0C, 0x1E, 0x00],   # U+0059 (Y)
  [ 0x7F, 0x63, 0x31, 0x18, 0x4C, 0x66, 0x7F, 0x00],   # U+005A (Z)
  [ 0x1E, 0x06, 0x06, 0x06, 0x06, 0x06, 0x1E, 0x00],   # U+005B ([)
  [ 0x03, 0x06, 0x0C, 0x18, 0x30, 0x60, 0x40, 0x00],   # U+005C (\)
  [ 0x1E, 0x18, 0x18, 0x18, 0x18, 0x18, 0x1E, 0x00],   # U+005D (])
  [ 0x08, 0x1C, 0x36, 0x63, 0x00, 0x00, 0x00, 0x00],   # U+005E (^)
  [ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF],   # U+005F (_)
  [ 0x0C, 0x0C, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00],   # U+0060 (`)
  [ 0x00, 0x00, 0x1E, 0x30, 0x3E, 0x33, 0x6E, 0x00],   # U+0061 (a)
  [ 0x07, 0x06, 0x06, 0x3E, 0x66, 0x66, 0x3B, 0x00],   # U+0062 (b)
  [ 0x00, 0x00, 0x1E, 0x33, 0x03, 0x33, 0x1E, 0x00],   # U+0063 (c)
  [ 0x38, 0x30, 0x30, 0x3e, 0x33, 0x33, 0x6E, 0x00],   # U+0064 (d)
  [ 0x00, 0x00, 0x1E, 0x33, 0x3f, 0x03, 0x1E, 0x00],   # U+0065 (e)
  [ 0x1C, 0x36, 0x06, 0x0f, 0x06, 0x06, 0x0F, 0x00],   # U+0066 (f)
  [ 0x00, 0x00, 0x6E, 0x33, 0x33, 0x3E, 0x30, 0x1F],   # U+0067 (g)
  [ 0x07, 0x06, 0x36, 0x6E, 0x66, 0x66, 0x67, 0x00],   # U+0068 (h)
  [ 0x0C, 0x00, 0x0E, 0x0C, 0x0C, 0x0C, 0x1E, 0x00],   # U+0069 (i)
  [ 0x30, 0x00, 0x30, 0x30, 0x30, 0x33, 0x33, 0x1E],   # U+006A (j)
  [ 0x07, 0x06, 0x66, 0x36, 0x1E, 0x36, 0x67, 0x00],   # U+006B (k)
  [ 0x0E, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x1E, 0x00],   # U+006C (l)
  [ 0x00, 0x00, 0x33, 0x7F, 0x7F, 0x6B, 0x63, 0x00],   # U+006D (m)
  [ 0x00, 0x00, 0x1F, 0x33, 0x33, 0x33, 0x33, 0x00],   # U+006E (n)
  [ 0x00, 0x00, 0x1E, 0x33, 0x33, 0x33, 0x1E, 0x00],   # U+006F (o)
  [ 0x00, 0x00, 0x3B, 0x66, 0x66, 0x3E, 0x06, 0x0F],   # U+0070 (p)
  [ 0x00, 0x00, 0x6E, 0x33, 0x33, 0x3E, 0x30, 0x78],   # U+0071 (q)
  [ 0x00, 0x00, 0x3B, 0x6E, 0x66, 0x06, 0x0F, 0x00],   # U+0072 (r)
  [ 0x00, 0x00, 0x3E, 0x03, 0x1E, 0x30, 0x1F, 0x00],   # U+0073 (s)
  [ 0x08, 0x0C, 0x3E, 0x0C, 0x0C, 0x2C, 0x18, 0x00],   # U+0074 (t)
  [ 0x00, 0x00, 0x33, 0x33, 0x33, 0x33, 0x6E, 0x00],   # U+0075 (u)
  [ 0x00, 0x00, 0x33, 0x33, 0x33, 0x1E, 0x0C, 0x00],   # U+0076 (v)
  [ 0x00, 0x00, 0x63, 0x6B, 0x7F, 0x7F, 0x36, 0x00],   # U+0077 (w)
  [ 0x00, 0x00, 0x63, 0x36, 0x1C, 0x36, 0x63, 0x00],   # U+0078 (x)
  [ 0x00, 0x00, 0x33, 0x33, 0x33, 0x3E, 0x30, 0x1F],   # U+0079 (y)
  [ 0x00, 0x00, 0x3F, 0x19, 0x0C, 0x26, 0x3F, 0x00],   # U+007A (z)
  [ 0x38, 0x0C, 0x0C, 0x07, 0x0C, 0x0C, 0x38, 0x00],   # U+007B ([)
  [ 0x18, 0x18, 0x18, 0x00, 0x18, 0x18, 0x18, 0x00],   # U+007C (|)
  [ 0x07, 0x0C, 0x0C, 0x38, 0x0C, 0x0C, 0x07, 0x00],   # U+007D (])
  [ 0x6E, 0x3B, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00],   # U+007E (~)
  [ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00]    # U+007F
]

# Character width and height.
CH_WIDTH = 8
CH_HEIGHT = 8

$print_count=0

# Prints a character on the monitor.
def print_char(posX, posY, ch)
  $print_count += 1
  # Compute the length of a line.
  width = $termEMU.cols
  # Compute the start address.
  addr = V_ADDR + posY*CH_HEIGHT*width + posX*CH_WIDTH
  # Draw each line.
  MEM.synchronize do
    CH_HEIGHT.times do |y|
      CH_WIDTH.times do |x|
        # Draw each pixel on the line.
        MEM[addr] = (Font8x8_basic[ch&127][y] & (1 << x)) != 0 ? "#".ord : " ".ord
        addr += 1
      end
      # Next line.
      addr += width - CH_WIDTH
    end
  end
end

# The shell process.
def shell
  posX = posY = 0 # Position of the cursor (in charcters).
  loop do
    # Wait for being waked up.
    sleep
    # Waked up, get the key.
    ch = nil
    MEM.synchronize do
      ch = MEM[K_ADDR]
    end
    # Process it.
    case ch
    when 10 # Enter
      print_char(posX,posY," ".ord)
      posY += 1
      posX = 0
    when 27 # Escape
      # close_screen
      $termEMU.terminate
      puts "The end: $print_count=#{$print_count}"
      exit
    when 127 # Backspace
      print_char(posX,posY," ".ord)
      posX -= 1
      print_char(posX,posY," ".ord)
    else
      print_char(posX,posY,ch)
      posX += 1
    end
    # Print the cursor
    print_char(posX,posY,"_".ord)
  end
end



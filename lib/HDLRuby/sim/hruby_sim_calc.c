#include <stdio.h>
#include <stdarg.h>
#include <stdlib.h>
#include <string.h>
#include <limits.h>
#include "hruby_sim.h"

#ifndef alloca
#define alloca(x)  __builtin_alloca(x)
#endif


/**
 *  The HDLRuby simulation calculation engine, to be used with C code
 *  generated by hruby_low2c. 
 **/


/* Helping macros. */

/* The number of bits in an int. */
#define INT_BIT (sizeof(int)*CHAR_BIT)
#define LONG_LONG_BIT (sizeof(long long)*CHAR_BIT)

/** The min between two values. */
#define min2(a,b) \
   ({ __typeof__ (a) _a = (a); \
      __typeof__ (b) _b = (b); \
      _a <= _b ? _a : _b; })

/** The min between three values. */
#define min3(a,b,c) \
   ({ __typeof__ (a) _a = (a); \
      __typeof__ (b) _b = (b); \
      __typeof__ (c) _c = (c); \
      _a <= _b ? (_a <= _c ? _a : _c) : (_b <= _c ? _b : _c); })

/** Get the bit used for extending a bitstring value. */
#define bitstring_ext(v) \
    ({ __typeof__ (v) _v = (v); \
       _v->type->flags.sign ? _v->data_str[type_width(v->type)-1] - '0' : 0; })

// /** Get the word used for extending a value in unsigned unsigned long long. */
// #define word_extL(v) \
//     ({ __typeof__ (v) _v = (v); \
//        _v->type->flags.sign ? (_v->data[_v->size-1] >> (INT_BIT-1)) ? ULLONG_MAX : 0 : 0; })
// 
// /** Get the word used for extending a value in unsigned unsigned int. */
// #define word_ext(v) \
//     ({ __typeof__ (v) _v = (v); \
//        _v->type->flags.sign ? (_v->data[_v->size-1] >> (INT_BIT-1)) ?  UINT_MAX : 0 : 0; })

/* The type engine: each type is simplified to a vector of X elements
 * of Y bits. */




/* The interface to the type engine. */


/* The hash table of existing types. */
#define HASH_TYPE_SIZE 1024
static List hash_type[HASH_TYPE_SIZE] = {};

/** Computes the hash value of a type.
 *  @param base the width of an element
 *  @param number the number of elements
 *  @param flags the flags of the type
 *  @return the resulting type. */
static int hash_value(unsigned long long base, unsigned long long number,
                      FlagsS flags) {
    // return ((base+flags.all)^(number)) & 1023;
    return ((base+flags.sign)^(number)) & 1023;
}

/** Adds a type to the hash of types.
 *  @param type the type to add */
static void add_hash_type(Type type) {
    /* Compute the hash value. */
    int hvalue = hash_value(type->base,type->number,type->flags);
    /* See if there is already an entry for this hash value. */
    List entry = hash_type[hvalue];
    if (!entry) {
        /* No entry, create a new one. */
        entry = malloc(sizeof(List));
        entry = build_list(entry);
    }
    /* Adds the type to the entry. */
    Elem elem = get_element(type);
    add_list(entry,elem);
}

/** Gets a type from the hash of types.
 *  @param base the type of an element
 *  @param number the number of elements
 *  @return the resulting type */
static Type get_hash_type(Type base, unsigned long long number) {
    /* Compute the width of the base. */
    unsigned long long bw = type_width(base);
    FlagsS flags = base->flags;
    /* Compute the hash value. */
    int hvalue = hash_value(bw,number,flags);
    /* See if there is already an entry for this hash value and look
     * for the type in it. */
    List entry = hash_type[hvalue];
    if (entry) {
        /* Look into the entry for the type. */
        Elem elem = entry->head;
        while(elem) {
            Type type = elem->data;
            if ((type->base == bw) && (type->number == number) &&
                // (type->flags.all == flags.all)) {
                (type->flags.sign == flags.sign)) {
                /* The type is found. */
                return type;
            }
            elem = elem->next;
        }
    }
    /* The element is not found. */
    return NULL;
}


/** Computes the width in bits of a type.
 *  @param type the type to compute the width
 *  @return the resulting width in bits */
unsigned long long type_width(Type type) {
    return type->base * type->number;
}

/** Gets the single bit type. */
Type get_type_bit() {
    static TypeS type_bit = { 1ULL, 1ULL, { 0 } };
    return &type_bit;
}

/** Gets the single signed bit type. */
Type get_type_signed() {
    static TypeS type_sign = { 1ULL, 1ULL, { 1 } };
    return &type_sign;
}

/** Creates a type by base type and number of elements.
 *  @param base the type of an element
 *  @number the number of elements */
Type make_type_vector(Type base, unsigned long long number) {
    /* Create the type. */
    Type type = calloc(sizeof(TypeS),1);
    type->base = type_width(base);
    type->number = number;
    type->flags = base->flags;
    /* Add it to the hash of types. */
    add_hash_type(type);
    /* Return the result. */
    return type;
}

/** Gets a vector type by base type and number of elements.
 *  @param base the type of an element
 *  @param number the number of elements */
Type get_type_vector(Type base, unsigned long long number) {
    Type type = get_hash_type(base,number);
    if (type == NULL)
        /* The type does not exist yet, create it. */
        return make_type_vector(base,number);
    else
        /* The type already exists, return it. */
        return type;
}

// /** Gets a vector type by width and number of elements.
//  *  @param base the width of an element
//  *  @param number the number of elements 
//  *  @param flags the flags of the type */
// static Type get_type_vector_flat(unsigned long long base, 
//                                  unsigned long long number
//                                  unsigned int flags){
//     Type type = get_hash_type(base,number);
//     if (type == NULL)
//         /* The type does not exist yet, create it. */
//         return make_type_vector_flat(base,number);
//     else
//         /* The type already exists, return it. */
//         return type;
// }



/* The calculation engine. */


/* Creating and fill values. */

/** Creates a new value.
 *  @param type the type of the value
 *  @param numeric tells if the value is numeric or not
 *  @return the resulting value */
Value make_value(Type type, int numeric) {
    /* Compute the size in words of the data contained in the value. */
    unsigned long long width = type_width(type);
    /* Allocate the value. */
    Value res = calloc(sizeof(ValueS),1);
    /* Allocates the data of the value. */
    if (!numeric) {
        /* Allocate the bit string and fill it with u (undefined) by default. */
        res->data_str = malloc(sizeof(char)*width);
        memset(res->data_str,'x',width);
        /* And set its capacity to the type width. */
        res->capacity = width;
    } else {
        res->capacity = 0;
    }

    /* Initialize it. */
    res->type = type;
    res->numeric = numeric;

    return res;
}

/** Make the size of a value able to store size ints.
 *  @note The content of the value is lost!
 *  @note do not change the type of the value, only its capacity.
 *  @praam value the value to change
 *  @param size the size to match */
void resize_value(Value value, int size) {
    if (value->capacity < size) {
        /* Resizing required, to limit frequent resize, double the
         * required new capacity. */
        /* Free the former data. */
        free(value->data_str);
        /* Reallocate it. */
        value->data_str = calloc(sizeof(char),size*2);
        /* Update the size. */
        value->capacity = size*2;
    }
}

/** Sets a value with data.
 *  @param value the value to fill
 *  @param numeric tell if the value is in numeric form or in bitstring form
 *  @param data the source data */
void set_value(Value value, int numeric, void* data) {
    value->numeric = numeric;
    if (numeric) {
    // printf("set_value with data=%llx\n",*(unsigned long long*)data);
        value->data_int = *((unsigned long long*)data);
    } else  {
        // printf("data=%s\n",(char*)data);
        memcpy(value->data_str,data,type_width(value->type)*sizeof(char));
    }
}

/** Makes and sets a value with data.
 *  @param type the type of the value
 *  @param numeric tell if the value is in numeric form or in bitstring form
 *  @param data the source data */
Value make_set_value(Type type, int numeric, void* data) {
    // printf("make_set_value with type->flags.sign=%x\n",type->flags.sign);
    Value value = make_value(type,numeric);
    set_value(value,numeric,data);
    return value;
}




/* The interface to the value computation engine. */

/* ################### Value-kind independant computations. ############## */

// /** Check if a value can be converted to a numeric.
//  *  @param value the value to process
//  *  @return 1 in case of success, 0 otherwise */
// int is_numeric_value(Value value) {
//     if (value->numeric) {
//         /* The value is already numeric. */
//         return 1;
//     } else {
//         /* Check if the value contains only 0 and 1. */
//         unsigned long long width = type_width(value->type);
//         unsigned long long i;
//         char* data_str = value->data_str;
//         for(i=0; i<width; ++i) {
//             if (data_str[i] != '0' && data_str[i] != '1')
//                 /* Cannot be converted. */
//                 return 0;
//         }
//         /* Can convert so do it. */
//         return 1;
//     }
// }

/* Defined after.*/
static unsigned long long
fix_numeric_type(Type type, unsigned long long val);


/** Copies a value to another, the type of the destination is preserved.
 *  @param src the source value
 *  @param dst the destination value
 *  @return dst */
Value copy_value(Value src, Value dst) {
    /* set the status of the destination from the source. */
    if (dst->type == NULL)
        dst->type = src->type;
    dst->numeric = src->numeric;
    /* Copy the data. */
    if (src->numeric) {
        /* Numeric copy. */
        dst->data_int = fix_numeric_type(dst->type,src->data_int);
    } else {
        // printf("copy_value with bit string: %s\n",src->data_str);
        /* Resize the destination if required. */
        resize_value(dst,type_width(dst->type));
        /* Bitstring copy up to the end of dst or src. */
        unsigned long long width = min2(type_width(src->type),type_width(dst->type));
        memcpy(dst->data_str,src->data_str,width);
    }
    return dst;
}

/* Declared afterward. */
static Value set_bitstring_value(Value src, Value dst);

/** Copies a value to another but without overwritting with Z, the type of 
 *  the destination is preserved.
 *  @param src the source value
 *  @param dst the destination value
 *  @return dst */
extern Value copy_value_no_z(Value src, Value dst) {
    /* set the status of the destination from the source. */
    // dst->type = src->type;
    /* Copy the data. */
    if (src->numeric) {
        /* Numeric copy. */
        dst->data_int = src->data_int;
        dst->numeric = 1;
    } else {
        /* Convert the destination to a bitstring. */
        if (dst->numeric) {
            dst = set_bitstring_value(dst,dst);
        }
        /* Bitstring copy up to the end of dst or src. */
        unsigned long long width = min2(type_width(src->type),type_width(dst->type));
        unsigned long long i;
        /* Access the data. */
        char* src_data = src->data_str;
        char* dst_data = dst->data_str;
        // printf("src_data=%s dst_data=%s\n",src_data,dst_data);
        /* Perform the copy skipping the Z values. */
        for(i=0; i<width; ++i) {
            char b = src_data[i];
            if (b!='z') dst_data[i] = b;
            else if (dst_data[i] == 'x') dst_data[i] = b;
        }
        // printf("dst_data=%s\n",dst_data);
    }
    return dst;
}


/* ############# Start of the computation of bitstring values. ############ */

/** Creates a bitstring value from a numeric value.
 *  @param src the numeric source value
 *  @param dst the destination value
 *  @return dst. */
static Value set_bitstring_value(Value src, Value dst) {
    /* Compute the width in bits of the result. */
    unsigned long long width = type_width(src->type);
    unsigned long long i;
    /* Resize dst to match the width. */
    resize_value(dst,width);
    /* Set the type and size of the destination from the type of the source.*/
    dst->type = src->type;
    dst->numeric = 0;

    /* Access the data of the source and the destination. */
    unsigned long long data_int = src->data_int;
    char* data_str = dst->data_str;

    /* Make the conversion. */
    for(i=0; i < width; ++i) {
        /* Get the bit from the source. */
        char bit = (data_int >> i) & 1;
        /* And write it. */
        data_str[i] = bit + '0';
    }
    /* Return the destination. */
    return dst;
}


/** Sets a value to undefined.
 *  @param dst the destination value
 *  @return the destination value */
static Value set_undefined_bitstring(Value dst) {
    /* Compute the width of the result in bits. */
    unsigned long long width = type_width(dst->type);

    /* set the type and size of the destination. */
    dst->numeric = 0;
    /* Ensures the buffer of dst has the write size (in cas it was a fromer
     * numeric for example). */
    resize_value(dst,width);

    /* Get access to the destination data. */
    char* dst_data = dst->data_str;

    /* undefine the destination. */
    unsigned long long count;
    for(count = 0; count < width; ++count) {
        dst_data[count] = 'x';
    }
    /* Return the destination. */
    return dst;
}


/** Computes the neg of a bitstring value.
 *  @param src the source value of the not
 *  @param dst the destination value
 *  @return dst */
static Value neg_value_bitstring(Value src, Value dst) {
    /* Compute the width of the result in bits. */
    unsigned long long width = type_width(src->type);

    /* Update the destination capacity if required. */
    resize_value(dst,width);
    /* Set the type and size of the destination from the type of the source.*/
    dst->type = src->type;
    dst->numeric = 0;

    /* Access the source and destination data. */
    char* src_data = src->data_str;
    char* dst_data = dst->data_str;

    /* Performs the negation. */
    unsigned long long count;
    char carry = 1;
    for(count = 0; count < width; ++count) {
        /* Performs the negation. */
        char d = src_data[count] - '0'; /* Get and convert to bit. */
        char res;
        if (d == (d&1)) { /* d is defined. */
            res = d ^ carry;
            carry = d & carry;
        } else {
            /* Undefined, end here. */
            break;
        }
        dst_data[count] = res;
    }
    /* The remaining bits are undefined. */
    for(;count < width; ++count) {
        dst_data[count] = 'x';
    }
    /* Return the destination. */
    return dst;
}


/** Computes the addition of two bitstring values.
 *  @param src0 the first source value of the addition
 *  @param src1 the second source value of the addition
 *  @param dst the destination value
 *  @return dst */
static Value add_value_bitstring(Value src0, Value src1, Value dst) {
    /* Compute the width of sources in bits. */
    unsigned long long width0 = type_width(src0->type);
    unsigned long long width1 = type_width(src1->type);

    /* Update the destination capacity if required. */
    resize_value(dst,width0);
    /* Set the type and size of the destination from the type of the source.*/
    dst->type = src0->type;
    dst->numeric = 0;

    /* Get access to the data of the sources. */
    char *src0_data = src0->data_str;
    char *src1_data = src1->data_str;
    /* Get access to the data of the destination. */
    char *dst_data = dst->data_str;

    /* Get the sign extension character of source 1 and convert it to a bit.*/
    // int ext = src1->type->flags.sign ?  src1_data[width1-1] - '0' : 0;
    int ext = bitstring_ext(src1);
    /* Perform the addition. */
    unsigned long long count;
    char carry = 0;
    for(count = 0; count < width0; ++count) {
        /* Performs the addition. */
        char d0 = src0_data[count] - '0'; /* Get and convert to bit. */
        char res;
        if (count < width1) {
            char d1 = src1_data[count] - '0';/* Get and convert to bit. */
            if ((d0 == (d0&1)) && (d1 == (d1&1))) {
                /* d0 and d1 are defined. */
                res = d0 ^ d1 ^ carry;
                carry = (d0&d1) | (d0&carry) | (d1&carry);
            } else {
                /* Either input bit is undefined, end here. */
                break;
            }
        } else {
            /* All the bit of source 1 are used, go on using the sign
             * extension. */
            if (ext != (ext&1)) {
                /* The sign extension is undefined, end here. */
                break;
            }
            if (d0 == (d0&1)) {
                /* d0 is defined. */
                res = d0 ^ ext ^ carry;
                carry = (d0&ext) | (d0&carry) | (ext&carry);
            } else {
                /* d0 is undefined. */
                break;
            }
        }
        dst_data[count] = res + '0';
    }
    /* The remaining bits are undefined. */
    for(;count < width0; ++count) {
        dst_data[count] = 'x';
    }
    /* Return the destination. */
    return dst;
}


/** Computes the subtraction of two bitstring values.
 *  @param src0 the first source value of the subtraction
 *  @param src1 the second source value of the subtraction
 *  @param dst the destination value
 *  @return dst */
static Value sub_value_bitstring(Value src0, Value src1, Value dst) {
    /* Compute the width of sources in bits. */
    unsigned long long width0 = type_width(src0->type);
    unsigned long long width1 = type_width(src1->type);

    /* Update the destination capacity if required. */
    resize_value(dst,width0);
    /* Set the type and size of the destination from the type of the source.*/
    dst->type = src0->type;
    dst->numeric = 0;

    /* Get access to the data of the sources. */
    char *src0_data = src0->data_str;
    char *src1_data = src1->data_str;
    /* Get access to the data of the destination. */
    char *dst_data = dst->data_str;

    /* Get the sign extension character of source 1 and convert it to a bit.*/
    // int ext = src1->type->flags.sign ?  src1_data[width1-1] - '0' : 0;
    int ext = bitstring_ext(src1);
    ext = !ext; /* For the subtraction: a + ~b + 1 */
    /* Perform the subtraction. */
    unsigned long long count;
    char carry = 1; /* For the subtraction: a + ~b + 1 */
    for(count = 0; count < width0; ++count) {
        /* Performs the subtraction. */
        char d0 = src0_data[count] - '0'; /* Get and convert to bit. */
        char res;
        if (count < width1) {
            char d1 = src1_data[count] - '0';/* Get and convert to bit. */
            if ((d0 == (d0&1)) && (d1 == (d1&1))) {
                d1 = !d1; /* For the subtraction: a + ~b + 1 */
                /* d0 and d1 are defined. */
                res = d0 ^ (d1) ^ carry;
                carry = (d0&d1) | (d0&carry) | (d1&carry);
            } else {
                /* Either input bit is undefined, end here. */
                break;
            }
        } else {
            /* All the bit of source 1 are used, go on using the sign
             * extension. */
            if (ext != (ext&1)) {
                /* The sign extension is undefined, end here. */
                break;
            }
            if (d0 == (d0&1)) {
                /* d0 is defined. */
                res = d0 ^ ext ^ carry;
                carry = (d0&ext) | (d0&carry) | (ext&carry);
            } else {
                /* d0 is undefined. */
                break;
            }
        }
        dst_data[count] = res + '0';
    }
    /* The remaining bits are undefined. */
    for(;count < width0; ++count) {
        dst_data[count] = 'x';
    }
    /* Return the destination. */
    return dst;
}


/** Computes the multiplication of two defined bitstring values.
 *  @param src0 the first source value of the addition
 *  @param src1 the second source value of the addition
 *  @param dst the destination value
 *  @return dst */
static Value mul_value_defined_bitstring(Value src0, Value src1, Value dst) {
    // printf("mul_value_defined_bitstring with src0=%llx src1=%llx\n",value2integer(src0),value2integer(src1));
    /* Sets state of the destination using the first source. */
    dst->type = src0->type;
    dst->numeric = 1;

    /* Perform the multiplication. */
    dst->data_int = value2integer(src0) * value2integer(src1);
    // printf("dst->data_int=%llx\n",dst->data_int);
    return dst;
}


/** Computes the division of two defined bitstring values.
 *  @param src0 the first source value of the addition
 *  @param src1 the second source value of the addition
 *  @param dst the destination value
 *  @return dst */
static Value div_value_defined_bitstring(Value src0, Value src1, Value dst) {
    /* Sets state of the destination using the first source. */
    dst->type = src0->type;
    dst->numeric = 1;

    /* Perform the division. */
    dst->data_int = value2integer(src0) / value2integer(src1);
    return dst;
}


/** Computes the modulo of two defined bitstring values.
 *  @param src0 the first source value of the addition
 *  @param src1 the second source value of the addition
 *  @param dst the destination value
 *  @return dst */
static Value mod_value_defined_bitstring(Value src0, Value src1, Value dst) {
    /* Sets state of the destination using the first source. */
    dst->type = src0->type;
    dst->numeric = 1;

    /* Perform the modulo. */
    // printf("modulo with src0=%lld src1=%lld, result=%lld\n",value2integer(src0),value2integer(src1),value2integer(src0) % value2integer(src1));
    dst->data_int = value2integer(src0) % value2integer(src1);
    return dst;
}


/** Computes the lesser comparision of two defined bitstring values.
 *  @param src0 the first source value of the addition
 *  @param src1 the second source value of the addition
 *  @param dst the destination value
 *  @return dst */
static Value lesser_value_defined_bitstring(Value src0, Value src1, Value dst) {
    /* Sets state of the destination using the first source. */
    dst->type = src0->type;
    dst->numeric = 1;

    /* Perform the comparison. */
    dst->data_int = (value2integer(src0) < value2integer(src1));
    return dst;
}


/** Computes the greater comparision of two defined bitstring values.
 *  @param src0 the first source value of the addition
 *  @param src1 the second source value of the addition
 *  @param dst the destination value
 *  @return dst */
static Value greater_value_defined_bitstring(Value src0, Value src1, Value dst) {
    /* Sets state of the destination using the first source. */
    dst->type = src0->type;
    dst->numeric = 1;

    /* Perform the comparison. */
    dst->data_int = (value2integer(src0) > value2integer(src1));
    return dst;
}


/** Computes the NOT of a bitstring value.
 *  @param src the source value of the not
 *  @param dst the destination value
 *  @return the destination value */
static Value not_value_bitstring(Value src, Value dst) {
    /* Compute the width of the result in bits. */
    unsigned long long width = type_width(src->type);

    /* Update the destination capacity if required. */
    resize_value(dst,width);
    /* Set the type and size of the destination from the type of the source.*/
    dst->type = src->type;
    dst->numeric = 0;

    /* Get access to the source and destination data. */
    char* src_data = src->data_str;
    char* dst_data = dst->data_str;

    /* Performs the not. */
    unsigned long long count;
    for(count = 0; count < width; ++count) {
        /* Performs the not. */
        char d = src_data[count] - '0'; /* Get and convert to bit. */
        char res;
        if (d == (d&1)) { /* d is defined. */
            res = !d;
        } else {
            /* res is undefined. */
            res = 'x' - '0';
        }
        dst_data[count] = res + '0';
    }
    /* Return the destination. */
    return dst;
}

/** Compute the or of the bits a bitstring value.
 *  @param src the source value
 *  @param dst the destination value
 *  @return dst */
Value reduce_or_value_bitstring(Value src, Value dst) {
    /* Compute the width of the result in bits. */
    unsigned long long width = type_width(src->type);

    /* Update the destination capacity if required. */
    resize_value(dst,width);
    /* Set the type and size of the destination from the type of the source.*/
    dst->type = src->type;
    dst->numeric = 0;

    /* Get access to the source and destination data. */
    char* src_data = src->data_str;
    char* dst_data = dst->data_str;

    /* Performs the reduce or. */
    unsigned long long count;
    char res;
    for(count = 0; count < width; ++count) {
        /* Performs the reduce or. */
        char d = src_data[count] - '0'; /* Get and convert to bit. */
        if ((d == (d&1)) && (res != 'x'-'0')) { /* d is defined. */
            res |= d;
        } else {
            /* res is undefined. */
            res = 'x' - '0';
        }
        /* Apart for the first bit, there are only 0, still we are in
         * the loop, set it. */
        dst_data[count] = '0';
    }
    dst_data[0] = res + '0';
    /* Return the destination. */
    return dst;
}


/** Computes the and of two bitstring values.
 *  @param src0 the first source value of the and
 *  @param src1 the second source value of the and
 *  @param dst the destination value
 *  @return dst */
static Value and_value_bitstring(Value src0, Value src1, Value dst) {
    /* Compute the width of sources in bits. */
    unsigned long long width0 = type_width(src0->type);
    unsigned long long width1 = type_width(src1->type);

    /* Update the destination capacity if required. */
    resize_value(dst,width0);
    /* Set the type and size of the destination from the type of the source.*/
    dst->type = src0->type;
    dst->numeric = 0;

    /* Get access to the data of the sources. */
    char *src0_data = src0->data_str;
    char *src1_data = src1->data_str;
    /* Get access to the data of the destination. */
    char *dst_data = dst->data_str;

    /* Get the sign extension character of source 1 and convert it to a bit.*/
    // int ext = src1->type->flags.sign ?  src1_data[width1-1] - '0' : 0;
    int ext = bitstring_ext(src1);

    /* Perform the and. */
    unsigned long long count;
    for(count = 0; count < width0; ++count) {
        /* Performs the and. */
        char d0 = src0_data[count] - '0'; /* Get and convert to bit. */
        char res;
        char d1;
        if (count < width1) {
            /* Still within source 1. */
            d1 = src1_data[count] - '0';/* Get and convert to bit. */
        } else {
            /* Outside source 1, use the sign extension. */
            d1 = ext;
        }
        if (d0 == (d0&1)) {
            /* d0 is defined. */
            if (d1 == (d1&1)) {
                /* d1 is also defined. */
                res = d0 & d1;
            } else if (d0 == 0) {
                /* d1 is not defined but d0 is 0. */
                res = 0;
            } else {
                /* res is undefined. */
                res = 'x'-'0';
            }
        } else {
            /* d0 is undefined. */
            if (d1 == 0) {
                /* But d1 is 0. */
                res = 0;
            } else {
                /* res is undefined. */
                res = 'x'-'0';
            }
        }
        dst_data[count] = res + '0';
    }
    /* Return the destination. */
    return dst;
}


/** Computes the or of two bitstring values.
 *  @param src0 the first source value of the and
 *  @param src1 the second source value of the and
 *  @param dst the destination value
 *  @return dst */
static Value or_value_bitstring(Value src0, Value src1, Value dst) {
    /* Compute the width of sources in bits. */
    unsigned long long width0 = type_width(src0->type);
    unsigned long long width1 = type_width(src1->type);

    /* Update the destination capacity if required. */
    resize_value(dst,width0);
    /* Set the type and size of the destination from the type of the source.*/
    dst->type = src0->type;
    dst->numeric = 0;

    /* Get access to the data of the sources. */
    char *src0_data = src0->data_str;
    char *src1_data = src1->data_str;
    /* Get access to the data of the destination. */
    char *dst_data = dst->data_str;

    /* Get the sign extension character of source 1 and convert it to a bit.*/
    // int ext = src1->type->flags.sign ?  src1_data[width1-1] - '0' : 0;
    int ext = bitstring_ext(src1);

    /* Perform the or. */
    unsigned long long count;
    for(count = 0; count < width0; ++count) {
        /* Performs the or. */
        char d0 = src0_data[count] - '0'; /* Get and convert to bit. */
        char res;
        char d1;
        if (count < width1) {
            /* Still within source 1. */
            d1 = src1_data[count] - '0';/* Get and convert to bit. */
        } else {
            /* Outside source 1, use the sign extension. */
            d1 = ext;
        }
        if (d0 == (d0&1)) {
            /* d0 is defined. */
            if (d1 == (d1&1)) {
                /* d1 is also defined. */
                res = d0 | d1;
            } else if (d0 == 1) {
                /* d1 is not defined but d0 is 1. */
                res = 1;
            } else {
                /* res is undefined. */
                res = 'x'-'0';
            }
        } else {
            /* d0 is undefined. */
            if (d1 == 1) {
                /* But d1 is 1. */
                res = 1;
            } else {
                /* res is undefined. */
                res = 'x'-'0';
            }
        }
        dst_data[count] = res + '0';
    }
    /* Return the destination. */
    return dst;
}


/** Computes the xor of two bitstring values.
 *  @param src0 the first source value of the and
 *  @param src1 the second source value of the and
 *  @param dst the destination value
 *  @return dst */
static Value xor_value_bitstring(Value src0, Value src1, Value dst) {
    /* Compute the width of sources in bits. */
    unsigned long long width0 = type_width(src0->type);
    unsigned long long width1 = type_width(src1->type);

    /* Update the destination capacity if required. */
    resize_value(dst,width0);
    /* Set the type and size of the destination from the type of the source.*/
    dst->type = src0->type;
    dst->numeric = 0;

    /* Get access to the data of the sources. */
    char *src0_data = src0->data_str;
    char *src1_data = src1->data_str;
    /* Get access to the data of the destination. */
    char *dst_data = dst->data_str;

    /* Get the sign extension character of source 1 and convert it to a bit.*/
    // int ext = src1->type->flags.sign ?  src1_data[width1-1] - '0' : 0;
    int ext = bitstring_ext(src1);

    /* Perform the xor. */
    unsigned long long count;
    for(count = 0; count < width0; ++count) {
        /* Performs the xor. */
        char d0 = src0_data[count] - '0'; /* Get and convert to bit. */
        char res;
        char d1;
        if (count < width1) {
            /* Still within source 1. */
            d1 = src1_data[count] - '0';/* Get and convert to bit. */
        } else {
            /* Outside source 1, use the sign extension. */
            d1 = ext;
        }
        if (d0 == (d0&1)) {
            /* d0 is defined. */
            if (d1 == (d1&1)) {
                /* d1 is also defined. */
                res = d0 ^ d1;
            } else  {
                /* res is undefined. */
                res = 'x'-'0';
            }
        } else {
            /* res is undefined. */
            res = 'x'-'0';
        }
        dst_data[count] = res + '0';
    }
    /* Return the destination. */
    return dst;
}


/** Computes the left shift of a bitstring value by a numeric value.
 *  @param src0 the first source value of the addition
 *  @param src1 the second source value of the addition
 *  @param dst the destination
 *  @return dst */
static Value shift_left_value_bitstring_numeric(Value src0, Value src1, Value dst) {
    unsigned long long count;
    /* Get the widths of the first source. */
    unsigned long long width0 = type_width(src0->type);

    /* Update the destination capacity if required. */
    resize_value(dst,width0);
    /* set the type and size of the destination to the type first source. */
    dst->type = src0->type;
    dst->numeric = 0;

    /* Get access to the data of the source. */
    char *src0_data = src0->data_str;
    /* Get access to the data of the destination. */
    char *dst_data = dst->data_str;

    /* Compute the amount of shift. */
    // unsigned int ext = word_ext(src1);
    long long sh  = value2integer(src1);
    // if (ext && (sh > 0)) sh = -sh; /* Ensure the shift sign is right. */
    /* Cleans the destination for a clean shift result. */
    for(count = 0; count < width0; ++count) {
        dst_data[count] = '0';
    }
    /* Perform the bit-wise shift. */
    for(count = 0; count < width0; ++count) {
        /* Access the source bit. */
        char d0 = src0_data[count];
        /* Set it to the destination at the right place. */
        unsigned long long pos = count + sh;
        if ((pos>0) && (pos<width0)) {
            dst_data[pos] = d0;
        }
    }
    /* Return the destination value. */
    return dst;
}


/** Computes the right shift of a bitstring value by a numeric value.
 *  @param src0 the first source value of the addition
 *  @param src1 the second source value of the addition
 *  @param dst the destination
 *  @return dst */
static Value shift_right_value_bitstring_numeric(Value src0, Value src1, Value dst) {
    unsigned long long count;
    /* Get the widths of the first source. */
    unsigned long long width0 = type_width(src0->type);

    /* Update the destination capacity if required. */
    resize_value(dst,width0);
    /* set the type and size of the destination to the type first source. */
    dst->type = src0->type;
    dst->numeric = 0;

    /* Get access to the data of the source. */
    char *src0_data = src0->data_str;
    /* Get access to the data of the destination. */
    char *dst_data = dst->data_str;

    /* Compute the amount of shift. */
    // unsigned int ext = word_ext(src1);
    long long sh  = -value2integer(src1);
    // if (ext && (sh > 0)) sh = -sh; /* Ensure the shift sign is right. */
    /* Cleans the destination for a clean shift result. */
    for(count = 0; count < width0; ++count) {
        dst_data[count] = '0';
    }
    /* Perform the bit-wise shift. */
    for(count = 0; count < width0; ++count) {
        /* Access the source bit. */
        char d0 = src0_data[count];
        /* Set it to the destination at the right place. */
        unsigned long long pos = count + sh;
        if ((pos>0) && (pos<width0)) {
            dst_data[pos] = d0;
        }
    }
    /* Return the destination value. */
    return dst;
}


/** Computes the left shift of two bitstring values.
 *  @param src0 the first source value of the addition
 *  @param src1 the second source value of the addition
 *  @param dst the destination
 *  @return dst */
static Value shift_left_value_bitstring(Value src0, Value src1, Value dst) {
    unsigned long long count;
    /* Get the widths of the first source. */
    unsigned long long width0 = type_width(src0->type);

    /* Update the destination capacity if required. */
    resize_value(dst,width0);
    /* set the type and size of the destination to the type first source. */
    dst->type = src0->type;
    dst->numeric = 0;

    /* Get access to the data of the destination. */
    char *dst_data = dst->data_str;

    /* Unknow shift, fills the destination with x. */
    for(count = 0; count < width0; ++count) {
        dst_data[count] = 'x';
    }
    /* Return the destination value. */
    return dst;
}


/** Computes the right shift of two bitstring values.
 *  @param src0 the first source value of the addition
 *  @param src1 the second source value of the addition
 *  @param dst the destination
 *  @return dst */
static Value shift_right_value_bitstring(Value src0, Value src1, Value dst) {
    unsigned long long count;
    /* Get the widths of the first source. */
    unsigned long long width0 = type_width(src0->type);

    /* Update the destination capacity if required. */
    resize_value(dst,width0);
    /* set the type and size of the destination to the type first source. */
    dst->type = src0->type;
    dst->numeric = 0;

    /* Get access to the data of the destination. */
    char *dst_data = dst->data_str;

    /* Unknow shift, fills the destination with x. */
    for(count = 0; count < width0; ++count) {
        dst_data[count] = 'x';
    }
    /* Return the destination value. */
    return dst;
}


/** Computes the equal (!XOR) of two bitstring values.
 *  @param src0 the first source value of the and
 *  @param src1 the second source value of the and
 *  @param dst the destination value
 *  @return dst */
static Value equal_value_bitstring(Value src0, Value src1, Value dst) {
    /* Compute the width of sources in bits. */
    unsigned long long width0 = type_width(src0->type);
    unsigned long long width1 = type_width(src1->type);

    /* Update the destination capacity if required. */
    resize_value(dst,width0);
    /* Set the type and size of the destination from the type of the source.*/
    dst->type = src0->type;
    dst->numeric = 0;

    /* Get access to the data of the sources. */
    char *src0_data = src0->data_str;
    char *src1_data = src1->data_str;
    /* Get access to the data of the destination. */
    char *dst_data = dst->data_str;

    /* Get the sign extension character of source 1 and convert it to a bit.*/
    int ext = bitstring_ext(src1);

    /* Perform the !xor. */
    unsigned long long count;
    /* Check if values are the same. */
    char same = '1';
    for(count = 0; count < width0; ++count) {
        char d0 = src0_data[count] - '0'; /* Get and convert to bit. */
        char d1;
        if (count < width1) {
            /* Still within source 1. */
            d1 = src1_data[count] - '0';/* Get and convert to bit. */
        } else {
            /* Outside source 1, use the sign extension. */
            d1 = ext;
        }
        if (d0 == (d0&1)) {
            /* d0 is defined. */
            if (d1 == (d1&1)) {
                /* d1 is also defined. */
                if (d0 != d1) {
                    same = '0';
                    break;
                }
            } else  {
                /* Undefined. */
                same = 'x';
                break;
            }
        } else {
            /* Undefined. */
            same = 'x';
            break;
        }
    }
    /* Set the destination to 0 or 1 depending of different. */
    dst_data[0] = same;
    for(count = 1; count < width0; ++count) {
        dst_data[count] = '0';
    }
    /* Return the destination. */
    return dst;
}


/** Selects a value depending on a bitstring condition.
 *  @param cond   the condition to use for selecting a value
 *  @param dst    the destination value (used only if new value is created).
 *  @param num    the number of values for the selection
 *  @return the selected value */
static Value select_value_bitstring(Value cond, Value dst, unsigned int num,
        va_list args) 
{
    // printf("select_value_bitstring with cond=%s\n",cond->data_str);
    /* Get the first alternative for sizing the result. */
    Value src = va_arg(args,Value);
    /* Compute the width of the result in bits. */
    unsigned long long width = type_width(src->type);
    // printf("select width=%llu\n",width);

    /* Update the destination capacity if required. */
    resize_value(dst,width);
    /* Set the type and size of the destination from the type of the source.*/
    dst->type = src->type;
    dst->numeric = 0;
    char *dst_data = dst->data_str;

    /* Sets the destination as undefined. */
    unsigned long long count;
    for(count = 0; count < width; ++count) {
        dst_data[count] = 'x';
    }
    /* Return the destination. */
    return dst;
}


/** Concat multiple bitstring values to a single one.
 *  @param num the number of values to concat
 *  @param dir the direction of concatenation
 *  @param dst the destination value
 *  @param args the values to concat
 *  @return dst */
static Value concat_value_bitstring_array(int num, int dir,
                                          Value dst, Value* args) {
    unsigned long long pos = 0;  /* Current position in the resulting value.*/
    unsigned long long i;
    // printf("concat_value_bitstring with dir=%d\n",dir);

    /* Compute the size of the destination. */
    unsigned long long width = 0;
    for(i=0; i<num; ++i) {
        width += type_width(args[i]->type);
    }
    /* Resize the destination accordignly. */
    resize_value(dst,width);
    /* Ensure it is not numeric. */
    dst->numeric = 0;

    /* Access the data of the destination. */
    char* dst_data = dst->data_str;

    /* Fills the destination with each value. */
    for(i=0; i<num; ++i) {
        /* The access index denpend on the concat direction. */
        unsigned int idx = dir ? (num-i-1) : i;
        Value value = args[idx];
        unsigned long long cw = type_width(value->type);
        // printf("value=%s cw=%llu pos=%llu\n",value->data_str,cw,pos);
        memcpy(dst_data+pos,value->data_str,cw);
        pos += cw;
    }
    // printf("Result=%s\n",dst->data_str);
    /* Sets the type of the resulting value: it is necesserily an
     * unsigned bit string. */
    dst->type = get_type_vector(get_type_bit(),pos);
    /* Return the destination value. */
    return dst;
}


/** Casts a bitstring value to another type.
 *  @param src the source value
 *  @param type the type to cast to
 *  @param dst the destination value
 *  @return dst */
static Value cast_value_bitstring(Value src, Type type, Value dst) {
    unsigned long long i;
    // printf("cast_value_bitstring with src=%s to width=%llu\n",src->data_str,type_width(type));
    /* Get the width of the source. */
    unsigned long long swidth = type_width(src->type);
    /* Get the size of the result from the target type. */
    unsigned long long width = type_width(type);

    /* Update the destination capacity if required. */
    resize_value(dst,width);
    /* Set the type and size of the destination from the type of the source.*/
    dst->type = type;
    dst->numeric = 0;

    /* Get access to the data of the source. */
    char *src_data = src->data_str;
    /* Get access to the data of the destination. */
    char *dst_data = dst->data_str;
    /* Get the sign extension. */
    unsigned int ext = bitstring_ext(src) + '0';

    /* Copy the source to the destination as long as there is enough room. */
    for(i=0; i<width && i<swidth; ++i) {
        dst_data[i] = src_data[i];
    }
    /* Add the extension for the remaining bits. */
    for(;i<width; ++i) {
        dst_data[i] = ext;
    }
    /* Return the destination value. */
    return dst;
}


/** Testing if two bitstring values have the same content (the type is not checked).
 *  @param value0 the first value to compare
 *  @param value1 the second value to compare
 *  @return 1 if same content. */
static unsigned int same_content_value_bitstring(Value value0, Value value1) {
    unsigned long long i;
    // unsigned long long width = type_width(value0->type);
    // printf("same_content_value_bitstring.\n");
    // print_value(value0); printf(" "); print_value(value1); printf("\n");
    // printf("width0=%llu width1=%llu\n",type_width(value0->type),
    //         type_width(value1->type));
    // /* Compare the sizes. */
    // if (type_width(value1->type) != width) return 0;
    unsigned long long width = min2(type_width(value0->type),type_width(value1->type));
    /* Compare the data up to the widths. */
    char* data0 = value0->data_str;
    char* data1 = value1->data_str;
    for(i=0; i<width; ++i) {
        if (data0[i] != data1[i])
            /* The contents are different. */
            return 0;
    }
    /* The values have the same content. */
    return 1;
}


/** Testing if two bitstring values have the same content (the type is not checked).
 *  @param value0 the first value to compare
 *  @param first the first index of the range
 *  @param last the last index of the range
 *  @param value1 the second value to compare
 *  @return 1 if same content. */
static int same_content_value_range_bitstring(Value value0,
        unsigned long long first, unsigned long long last, Value value1) {
    /* Ensure first is the smaller. */
    if (first > last) {
        long long tmp = last;
        last = first;
        first = tmp;
    }
    unsigned long long i;
    unsigned long long width0 = type_width(value0->type);
    unsigned long long width1 = type_width(value1->type);
    /* Get access to the data of both values. */
    char* data0 = value0->data_str;
    char* data1 = value1->data_str;
    /* Compare within the range. */
    for(i=first; i<=last; ++i) {
        if (i>=width0) {
            if (i>=width1) {
                /* Both values are out of range. */
                return 1;
            } else {
                /* Only value 0 is out of range. */
                return 0;
            }
        } else if (i>=width1) {
            /* Only value 1 is out of range. */
            return 0;
        } else {
            if (data0[i] != data1[i])  {
                /* Values are different within the range. */
                return 0;
            }
        }
    }
    /* Values are identical in the range. */
    return 1;
}



/** Reads a range from a bitstring value. 
 *  @param value the value to read
 *  @param first the first index of the range
 *  @param last the last index of the range
 *  @param base the type of the elements
 *  @param dst the destination value
 *  @return dst */
Value read_range_bitstring(Value src, long long first, long long last,
        Type base, Value dst) {
    // printf("read_range_bitstring with first=%lld last=%lld src=%s\n",first,last,src->data_str);
    /* Ensure first is the smaller. */
    if (first > last) {
        long long tmp = last;
        last = first;
        first = tmp;
    }
    /* Compute the number of elements to read. */
    long long length = last-first+1;
    /* Compute the elements size. */
    unsigned long long bw = type_width(base);
    /* Scale the range according to the base type. */
    first *= bw;
    length *= bw;

    /* Update the destination capacity if required. */
    resize_value(dst,length);
    /* Set the type and size of the destination from the type of the source.*/
    dst->type = make_type_vector(get_type_bit(),length);
    dst->numeric = 0;

    /* Performs the read. */
    memcpy(dst->data_str,src->data_str + first, length);

    /* Return the destination. */
    return dst;
}


/** Writes to a range within a bitstring value. 
 *  NOTE: the type of the destination is NOT changed!
 *  @param src the source value
 *  @param first the first index of the range
 *  @param last the last index of the range
 *  @param base the type of the elements
 *  @param dst the destination value
 *  @return dst */
Value write_range_bitstring(Value src, long long first, long long last,
        Type base, Value dst) {
    unsigned long long i;
    /* Ensure first is the smaller. */
    if (first > last) {
        long long tmp = last;
        last = first;
        first = tmp;
    }
    // printf("Initially first=%lld, last=%lld\n",first,last);
    /* Get the widths of the source and the desintation. */
    unsigned long long src_width = type_width(src->type);
    unsigned long long dst_width = type_width(dst->type);
    /* scale the range according to the base type. */
    // unsigned long long bw = dst->type->base;
    unsigned long long bw = type_width(base);
    first *= bw;
    last *=  bw;
    last += bw-1;
    // printf("bw=%lld, first=%lld, last=%lld\n",bw,first,last);
    /* Access the source and destination bitstring data. */
    char* dst_data = dst->data_str;
    char* src_data = src->data_str;
    /* Perform the copy. */
    for(i=0; (i+first<=last) && (i<src_width) && (i+first<dst_width); ++i) {
        dst_data[i+first] = src_data[i];
    }
    return dst;
}


/** Writes to a range within a bitstring value without overwritting with Z.
 *  NOTE: the type of the destination is NOT changed!
 *  @param src the source value
 *  @param first the first index of the range
 *  @param last the last index of the range
 *  @param base the type of the elements
 *  @param dst the destination value
 *  @return dst */
Value write_range_bitstring_no_z(Value src, long long first, long long last,
        Type base, Value dst) {
    unsigned long long i;
    /* Ensure first is the smaller. */
    if (first > last) {
        long long tmp = last;
        last = first;
        first = tmp;
    }
    /* Get the widths of the source and the desintation. */
    unsigned long long src_width = type_width(src->type);
    unsigned long long dst_width = type_width(dst->type);
    /* scale the range according to the base type. */
    // unsigned long long bw = dst->type->base;
    unsigned long long bw = type_width(base);
    first *= bw;
    last *=  bw;
    /* Access the source and destination bitstring data. */
    char* dst_data = dst->data_str;
    char* src_data = src->data_str;
    /* Perform the copy. */
    for(i=0; (i+first<=last) && (i<src_width) && (i+first<dst_width); ++i) {
        char b = src_data[i];
        if (b != 'z') 
            dst_data[i+first] = src_data[i];
    }
    return dst;
}

/* ############# End of the computation of bitstring values. ############## */

/* ############# Start of the computation of numeric values. ############## */

/** Fix the content of a numeric value according to its type so that
 *  it can be used for C numeric computation. 
 *  @param type the type to fix the value to
 *  @param val the value to fix 
 *  @return the rsulting value */
static unsigned long long
fix_numeric_type(Type type, unsigned long long val) {
    /* Get the width of the type. */
    int width = type_width(type);
    /* Compute the base mask. */
    // unsigned long long mask = ((unsigned long long)(-1)) << width;
    /* NOTE: (ull)-1 << 64 becomes (ull)-1 on Intel processors, this is
     * totally not what I expected (I expected 0). */
    unsigned long long mask = width == 64 ? 0 : ((unsigned long long)(-1)) << width;
    // printf("width=%i val=%llu mask=%llx\n",width,val,mask);

    /* Is the type signed? */
    if (type->flags.sign) {
        /* Yes, perform sign extension. */
        int is_neg = (val >> (width-1)) & 1;
        // printf("is_neg=%i\n",is_neg);
        if (is_neg) {
            /* Negative sign extension. */
            return val | mask;
        } else {
            /* Positive sign extension. */
            return val & ~mask;
        }
    } else {
        /* No, perform a zero extension. */
        return val & ~mask;
    }
}


/** Computes the neg of a numeric value.
 *  @param src the source value of the not
 *  @param dst the destination value
 *  @return dst */
static Value neg_value_numeric(Value src, Value dst) {
    /* Sets state of the destination using the source. */
    dst->type = src->type;
    dst->numeric = 1;

    /* Perform the negation. */
    dst->data_int = fix_numeric_type(dst->type,-src->data_int);
    return dst;
}


/** Computes the addition of two numeric values.
 *  @param src0 the first source value of the addition
 *  @param src1 the second source value of the addition
 *  @param dst the destination value
 *  @return dst */
static Value add_value_numeric(Value src0, Value src1, Value dst) {
    /* Sets state of the destination using the first source. */
    dst->type = src0->type;
    dst->numeric = 1;

    /* Perform the addition. */
    dst->data_int = fix_numeric_type(dst->type,src0->data_int + src1->data_int);
    return dst;
}


/** Computes the subtrasction of two numeric values.
 *  @param src0 the first source value of the addition
 *  @param src1 the second source value of the addition
 *  @param dst the destination value
 *  @return dst */
static Value sub_value_numeric(Value src0, Value src1, Value dst) {
    /* Sets state of the destination using the first source. */
    dst->type = src0->type;
    dst->numeric = 1;

    /* Perform the subtraction. */
    dst->data_int = fix_numeric_type(dst->type,src0->data_int - src1->data_int);
    return dst;
}


/** Computes the multiplication of two numeric values.
 *  @param src0 the first source value of the addition
 *  @param src1 the second source value of the addition
 *  @param dst the destination value
 *  @return dst */
static Value mul_value_numeric(Value src0, Value src1, Value dst) {
    // printf("mul_value_numeric with src0->data_int=%llx src1->data_int=%llx\n",src0->data_int, src1->data_int);
    /* Sets state of the destination using the first source. */
    dst->type = src0->type;
    dst->numeric = 1;

    /* Perform the multiplication. */
    dst->data_int = fix_numeric_type(dst->type, src0->data_int * src1->data_int);
    return dst;
}


/** Computes the division of two numeric values.
 *  @param src0 the first source value of the addition
 *  @param src1 the second source value of the addition
 *  @param dst the destination value
 *  @return dst */
static Value div_value_numeric(Value src0, Value src1, Value dst) {
    /* Sets state of the destination using the first source. */
    dst->type = src0->type;
    dst->numeric = 1;

    /* Perform the division. */
    dst->data_int = fix_numeric_type(dst->type, src0->data_int / src1->data_int);
    return dst;
}


/** Computes the modulo of two numeric values.
 *  @param src0 the first source value of the addition
 *  @param src1 the second source value of the addition
 *  @param dst the destination value
 *  @return dst */
static Value mod_value_numeric(Value src0, Value src1, Value dst) {
    /* Sets state of the destination using the first source. */
    dst->type = src0->type;
    dst->numeric = 1;

    /* Perform the division. */
    // printf("modulo numeric with src0=%lld src1=%lld, result=%lld\n",src0->data_int, src1->data_int,src0->data_int % src1->data_int);
    dst->data_int = fix_numeric_type(dst->type, src0->data_int % src1->data_int);
    return dst;
}


/** Computes the NOT of a numeric value.
 *  @param src the source value of the not
 *  @param dst the destination value
 *  @return the destination value */
static Value not_value_numeric(Value src, Value dst) {
    /* Sets state of the destination using the first source. */
    dst->type = src->type;
    dst->numeric = 1;

    /* Perform the not. */
    dst->data_int = fix_numeric_type(dst->type,!src->data_int);
    return dst;
}


/** Compute the or of the bits a numeric value.
 *  @param src the source value
 *  @param dst the destination value
 *  @return dst */
Value reduce_or_value_numeric(Value src, Value dst) {
    /* Sets state of the destination using the first source. */
    dst->type = src->type;
    dst->numeric = 1;

    /* Perform the reduce or. */
    dst->data_int = fix_numeric_type(dst->type, src->data_int != 0);
    return dst;
}


/** Computes the AND of two numeric values.
 *  @param src0 the first source value of the addition
 *  @param src1 the second source value of the addition
 *  @param dst the destination value
 *  @return dst */
static Value and_value_numeric(Value src0, Value src1, Value dst) {
    /* Sets state of the destination using the first source. */
    dst->type = src0->type;
    dst->numeric = 1;

    /* Perform the AND. */
    dst->data_int = src0->data_int & src1->data_int;
    return dst;
}


/** Computes the OR of two numeric values.
 *  @param src0 the first source value of the addition
 *  @param src1 the second source value of the addition
 *  @param dst the destination
 *  @return dst */
static Value or_value_numeric(Value src0, Value src1, Value dst) {
    /* Sets state of the destination using the first source. */
    dst->type = src0->type;
    dst->numeric = 1;

    /* Perform the OR. */
    dst->data_int = src0->data_int | src1->data_int;
    return dst;
}


/** Computes the XOR of two numeric values.
 *  @param src0 the first source value of the addition
 *  @param src1 the second source value of the addition
 *  @param dst the destination
 *  @return dst */
static Value xor_value_numeric(Value src0, Value src1, Value dst) {
    /* Sets state of the destination using the first source. */
    dst->type = src0->type;
    dst->numeric = 1;

    /* Perform the XOR. */
    dst->data_int = src0->data_int ^ src1->data_int;
    return dst;
}


/** Computes the left shift of two numeric values.
 *  @param src0 the first source value of the addition
 *  @param src1 the second source value of the addition
 *  @param dst the destination
 *  @return dst */
static Value shift_left_value_numeric(Value src0, Value src1, Value dst) {
    /* Sets state of the destination using the first source. */
    dst->type = src0->type;
    dst->numeric = 1;

    /* Perform the left shift. */
    dst->data_int = fix_numeric_type(dst->type,src0->data_int << src1->data_int);
    return dst;
}


/** Computes the right shift of two numeric values.
 *  @param src0 the first source value of the addition
 *  @param src1 the second source value of the addition
 *  @param dst the destination
 *  @return dst */
static Value shift_right_value_numeric(Value src0, Value src1, Value dst) {
    /* Sets state of the destination using the first source. */
    dst->type = src0->type;
    dst->numeric = 1;

    /* Perform the right shift. */
    dst->data_int = fix_numeric_type(dst->type,src0->data_int >> src1->data_int);
    return dst;
}


/** Computes the equal (!XOR) of two numeric values.
 *  @param src0 the first source value of the addition
 *  @param src1 the second source value of the addition
 *  @param dst the destination value
 *  @return the destination value */
static Value equal_value_numeric(Value src0, Value src1, Value dst) {
    /* Sets state of the destination using the first source. */
    dst->type = src0->type;
    dst->numeric = 1;

    /* Perform the !XOR. */
    dst->data_int = (src0->data_int == src1->data_int);
    return dst;
}


/** Computes the lesser comparision of two numeric values.
 *  @param src0 the first source value of the addition
 *  @param src1 the second source value of the addition
 *  @param dst the destination value
 *  @return the destination value */
static Value lesser_value_numeric(Value src0, Value src1, Value dst) {
    /* Sets state of the destination using the first source. */
    dst->type = src0->type;
    dst->numeric = 1;

    /* Perform the lesser. */
    dst->data_int = (src0->data_int < src1->data_int);
    return dst;
}

/** Computes the greater comparision of two numeric values.
 *  @param src0 the first source value of the addition
 *  @param src1 the second source value of the addition
 *  @param dst the destination value
 *  @return the destination value */
static Value greater_value_numeric(Value src0, Value src1, Value dst) {
    /* Sets state of the destination using the first source. */
    dst->type = src0->type;
    dst->numeric = 1;

    /* Perform the lesser. */
    dst->data_int = (src0->data_int > src1->data_int);
    return dst;
}


/** Selects a value depending on a numeric condition.
 *  @param cond   the condition to use for selecting a value
 *  @param dst    the destination value (used only if new value is created).
 *  @param num    the number of values for the selection
 *  @return the selected value */
static Value select_value_numeric(Value cond, Value dst, unsigned int num,
        va_list args) {
    unsigned int i;
    /* Select the value corresponding to the condition and copy it to
     * the destination. */
    for(i = 0; i<num;  ++i) {
        Value value = va_arg(args,Value);
        if (i == value2integer(cond)) {
            /* The right value is reached, copy it. */
            copy_value(value,dst);
            return dst;
        }
    }
    /* Should never be here. */
    return NULL;
}

/** Concat multiple numeric values to a single one.
 *  @param num the number of values to concat
 *  @param dir the direction of the concatenation.
 *  @param dst the destination value
 *  @return dst */
static Value concat_value_numeric_array(int num, int dir,
                                        Value dst, Value* args) {
    unsigned int i,pos;
    /* Compute the bit width of the destination. */
    unsigned int width = 0;
    // printf("concat_value_numeric with dir=%d and width=%llu\n",dir,type_width(args[0]->type));
    for(i=0; i<num; ++i) width += type_width(args[i]->type);

    /* Sets state of the destination using the bit width. */
    dst->type = make_type_vector(get_type_bit(),width);
    dst->numeric = 1;

    /* Perform the concatenation. */
    dst->data_int = 0;
    pos = 0;
    for(i=0; i<num; ++i) {
        /* The access index depend on the concatenation direction. */
        unsigned int idx = dir ? (num-i-1) : i;
        /* Compute the read mask. */
        unsigned long long arg_width = type_width(args[idx]->type);
        unsigned long long read_mask = ~((-1LL) << arg_width);
        /* Read from the value to concatenate. */
        unsigned long long arg_data = args[idx]->data_int & read_mask;
        /* Write it. */
        dst->data_int |= arg_data << pos;
        /* Update the write position. */
        pos += arg_width;
    }
    /* Return the destination. */
    // printf("Result is dst=%llx\n",dst->data_int);
    return dst;
}


/** Casts a numeric value to another type.
 *  @param src the source value
 *  @param type the type to cast to
 *  @param dst the destination value
 *  @return dst */
static Value cast_value_numeric(Value src, Type type, Value dst) {
    // printf("cast_value_numeric with src=%llx\n",src->data_int);
    /* Copy the source to the destination. */
    dst->data_int = src->data_int;
    /* Update the destination type to the cast. */
    dst->type = type;
    dst->numeric = 1;
    /* Return the destination. */
    return dst;
}


/** Testing if a numeric value is 0.
 *  @param value the value to check 
 *  @return 1 if 0 and 0 otherwize */
static int zero_value_numeric(Value value) {
    return value->data_int == 0;
}



/** Testing if two numeric values have the same content (the type is not checked).
 *  @param value0 the first value to compare
 *  @param value1 the second value to compare
 *  @return 1 if same content. */
static unsigned int same_content_value_numeric(Value value0, Value value1) {
    return value0->data_int == value1->data_int;
}


/** Testing if two numeric values have the same content in a given
 *  range (the type is not checked).
 *  @param value0 the first value to compare
 *  @param first the first index of the range
 *  @param last the last index of the range
 *  @param value1 the second value to compare
 *  @return 1 if same content. */
static int same_content_value_range_numeric(Value value0,
        unsigned long long first, unsigned long long last, Value value1) {
    /* Ensure first is the smaller index. */
    if (first>last) {
        unsigned long long tmp = first;
        first = last;
        last = tmp;
    }
    /* Compute the mask from the range. */
    unsigned long long mask = ((-1LL) << first) & ~((-1LL) << last);
    /* Compare using the mask. */
    return (value0->data_int & mask) == (value1->data_int & mask);
}


/** Reads a range from a numeric value. 
 *  @param value the value to read
 *  @param first the first index of the range
 *  @param last the last index of the range
 *  @param base the type of the elements
 *  @param dst the destination value
 *  @return dst */
Value read_range_numeric(Value value, long long first, long long last,
        Type base, Value dst) {
    /* printf("read_range_numeric with value=%llx and first=%llu and last=%llu\n",value->data_int,first,last); */
    /* Ensure first is the smaller. */
    if (first > last) {
        long long tmp = last;
        last = first;
        first = tmp;
    }
    /* Compute the number of elements to read. */
    long long length = last-first+1;
    /* Compute the elements size. */
    unsigned long long bw = type_width(base);
    /* Scale the range according to the base type. */
    first *= bw;
    last  *= bw;
    length *= bw;
    /* printf("first=%lld last=%lld bw=%llu length=%lld\n",first,last,bw,length); */

    /* Set the type and size of the destination from the type of the source.*/
    dst->type = make_type_vector(get_type_bit(),length);
    dst->numeric = 1;

    /* Compute the read mask. */
    // unsigned long long mask = ((-1LL) << first) & (~((-1LL) << (last+1)));
    /* NOTE: once again, << 64 does not work like expected. */
    unsigned long long mask = mask+bw < 64 ? (~((-1LL) << (last+bw))) : -1LL;
    /* Performs the read. */
    unsigned long long data = (value->data_int & mask) >> first;
    /* Write it to the destination. */
    dst->data_int = data;

    /* Return the destination. */
    return dst;
}

/** Writes to a range within a numeric value. 
 *  NOTE: the type of the destination is NOT changed!
 *  @param src the source value
 *  @param first the first index of the range
 *  @param last the last index of the range
 *  @param base the type of the elements
 *  @param dst the destination value
 *  @return dst */
Value write_range_numeric(Value src, long long first, long long last,
        Type base, Value dst) {
    // printf("write_range_numeric\n");
    /* Ensure first is the smaller. */
    if (first > last) {
        long long tmp = last;
        last = first;
        first = tmp;
    }
    /* Get the widths of the source and the desintation. */
    unsigned long long src_width = type_width(src->type);
    unsigned long long dst_width = type_width(dst->type);
    /* scale the range according to the base type of the destination. */
    // unsigned long long bw = dst->type->base;
    unsigned long long bw = type_width(base);
    // printf("src_width=%llu dst_wdith=%llu bw=%llu\n",src_width,dst_width,bw);
    first *= bw;
    last *= bw;
    /* If first is too large, end here. */
    if (first>dst_width) return dst;
    /* Adjust the last to fit the source and destination range. */
    if (last >= dst_width) last = dst_width-1;
    if (last-first >= src_width) last = src_width + first - 1;
    // printf("first=%lld last=%lld\n",first,last);
    /* Copy from the source. */
    unsigned long long src_data = src->data_int & ~((-1LL) << (last-first+1));
    /* Cleans the destination where to place the data. */
    unsigned long long mask = ~(((-1LL) << first) & ~((-1LL) << (last+1)));
    unsigned long long dst_data = dst->data_int & mask;
    // printf("src_data=%llx  mask=%llx dst_data=%llx\n",src_data,mask,dst_data);
    /* Write the data. */
    dst_data |= src_data << first;
    dst->data_int = dst_data;
    /* Return the destination. */
    return dst;
}


/* ############# End of the computation of numeric values. ################ */

/* ############# Start of the computation of general values. ################ */


/** Computes the neg of a general value.
 *  @param src the source value of the not
 *  @param dst the destination value
 *  @return dst */
Value neg_value(Value src, Value dst) {
    if (src->numeric) {
        /* The source is numeric. */
        return neg_value_numeric(src,dst);
    } else {
        /* The source cannot be numeric, compute bitsitrings. */
        return neg_value_bitstring(src,dst);
    }
}


/** Computes the addition of two general values.
 *  @param src0 the first source value of the addition
 *  @param src1 the second source value of the addition
 *  @param dst the destination value
 *  @return dst */
Value add_value(Value src0, Value src1, Value dst) {
    /* Might allocate a new value so save the current pool state. */
    unsigned int pos = get_value_pos();
    /* Do a numeric computation if possible, otherwise fallback to bitstring
     * computation. */
    if (src0->numeric) {
        if (src1->numeric) {
            /* Both sources are numeric. */
            return add_value_numeric(src0,src1,dst);
        } else {
            /* src1 is not numeric, convert src0 to bitstring. */
            src0 = set_bitstring_value(src0,get_value());
        }
    } else {
        /* src0 is not numeric, what about src1. */
        if (src1->numeric) {
            /* src1 is numeric, convert it to bitstring. */
            src1 = set_bitstring_value(src1,get_value());
        }
    }
    /* The sources cannot be numeric, compute bitsitrings. */
    dst = add_value_bitstring(src0,src1,dst);
    /* Restores the pool of values. */
    set_value_pos(pos);
    /* Return the destination. */
    return dst;
}


/** Computes the subtrasction of two general values.
 *  @param src0 the first source value of the addition
 *  @param src1 the second source value of the addition
 *  @param dst the destination value
 *  @return dst */
Value sub_value(Value src0, Value src1, Value dst) {
    /* Might allocate a new value so save the current pool state. */
    unsigned int pos = get_value_pos();
    /* Do a numeric computation if possible, otherwise fallback to bitstring
     * computation. */
    if (src0->numeric) {
        if (src1->numeric) {
            /* Both sources are numeric. */
            return sub_value_numeric(src0,src1,dst);
        } else {
            /* src1 is not numeric, convert src0 to bitstring. */
            src0 = set_bitstring_value(src0,get_value());
        }
    } else {
        /* src0 is not numeric, what about src1. */
        if (src1->numeric) {
            /* src1 is numeric, convert it to bitstring. */
            src1 = set_bitstring_value(src1,get_value());
        }
    }
    /* The sources cannot be numeric, compute bitsitrings. */
    dst = sub_value_bitstring(src0,src1,dst);
    /* Restores the pool of values. */
    set_value_pos(pos);
    /* Return the destination. */
    return dst;
}


/** Computes the multiplication of two general values.
 *  @param src0 the first source value of the addition
 *  @param src1 the second source value of the addition
 *  @param dst the destination value
 *  @return dst */
Value mul_value(Value src0, Value src1, Value dst) {
    /* Might allocate a new value so save the current pool state. */
    unsigned int pos = get_value_pos();
    /* Do a numeric computation if possible, otherwise fallback to bitstring
     * computation. */
    if (src0->numeric && src1->numeric) {
        /* Both sources are numeric. */
        return mul_value_numeric(src0,src1,dst);
    } else if (is_defined_value(src0) && is_defined_value(src1)) {
        /* Both sources can be converted to numeric values. */
        return mul_value_defined_bitstring(src0,src1,dst);
    } else {
        /* Cannot compute (for now), simply undefines the destination. */
        /* First ensure dst has the right shape. */
        copy_value(src0,dst);
        /* Then make it undefined. */
        set_undefined_bitstring(dst);
    }
    return dst;
}


/** Computes the division of two general values.
 *  @param src0 the first source value of the addition
 *  @param src1 the second source value of the addition
 *  @param dst the destination value
 *  @return dst */
Value div_value(Value src0, Value src1, Value dst) {
    /* Might allocate a new value so save the current pool state. */
    unsigned int pos = get_value_pos();
    /* Do a numeric computation if possible, otherwise fallback to bitstring
     * computation. */
    if (src0->numeric && src1->numeric) {
        /* Both sources are numeric. */
        return div_value_numeric(src0,src1,dst);
    } else if (is_defined_value(src0) && is_defined_value(src1)) {
        /* Both sources can be converted to numeric values. */
        return div_value_defined_bitstring(src0,src1,dst);
    } else {
        /* Cannot compute (for now), simply undefines the destination. */
        /* First ensure dst has the right shape. */
        copy_value(src0,dst);
        /* Then make it undefined. */
        set_undefined_bitstring(dst);
    }
    return dst;
}


/** Computes the modulo of two general values.
 *  @param src0 the first source value of the addition
 *  @param src1 the second source value of the addition
 *  @param dst the destination value
 *  @return dst */
Value mod_value(Value src0, Value src1, Value dst) {
    /* Might allocate a new value so save the current pool state. */
    unsigned int pos = get_value_pos();
    /* Do a numeric computation if possible, otherwise fallback to bitstring
     * computation. */
    if (src0->numeric && src1->numeric) {
        /* Both sources are numeric. */
        return mod_value_numeric(src0,src1,dst);
    } else if (is_defined_value(src0) && is_defined_value(src1)) {
        /* Both sources can be converted to numeric values. */
        return mod_value_defined_bitstring(src0,src1,dst);
    } else {
        /* Cannot compute (for now), simply undefines the destination. */
        /* First ensure dst has the right shape. */
        copy_value(src0,dst);
        /* Then make it undefined. */
        set_undefined_bitstring(dst);
    }
    return dst;
}


/** Computes the NOT of a general value.
 *  @param src the source value of the not
 *  @param dst the destination value
 *  @return the destination value */
Value not_value(Value src, Value dst) {
    if (src->numeric) {
        /* The source is numeric. */
        return not_value_numeric(src,dst);
    } else {
        /* The source cannot be numeric, compute bitsitrings. */
        return not_value_bitstring(src,dst);
    }
}


/** Compute the or of the bits a value.
 *  @param src the source value
 *  @param dst the destination value
 *  @return dst */
Value reduce_or_value(Value src, Value dst) {
    if (src->numeric) {
        /* The source is numeric. */
        return reduce_or_value_numeric(src,dst);
    } else {
        /* The source cannot be numeric, compute bitsitrings. */
        return reduce_or_value_bitstring(src,dst);
    }
}


/** Computes the AND of two general values. 
 *  @param src0 the first source value of the addition
 *  @param src1 the second source value of the addition
 *  @param dst the destination value
 *  @return dst */
Value and_value(Value src0, Value src1, Value dst) {
    /* Might allocate a new value so save the current pool state. */
    unsigned int pos = get_value_pos();
    /* Do a numeric computation if possible, otherwise fallback to bitstring
     * computation. */
    if (src0->numeric) {
        if (src1->numeric) {
            /* Both sources are numeric. */
            return and_value_numeric(src0,src1,dst);
        } else {
            /* src1 is not numeric, convert src0 to bitstring. */
            src0 = set_bitstring_value(src0,get_value());
        }
    } else {
        /* src0 is not numeric, what about src1. */
        if (src1->numeric) {
            /* src1 is numeric, convert it to bitstring. */
            src1 = set_bitstring_value(src1,get_value());
        }
    }
    /* The sources cannot be numeric, compute bitsitrings. */
    dst = and_value_bitstring(src0,src1,dst);
    /* Restores the pool of values. */
    set_value_pos(pos);
    /* Return the destination. */
    return dst;
}


/** Computes the OR of two general values.
 *  @param src0 the first source value of the addition
 *  @param src1 the second source value of the addition
 *  @param dst the destination
 *  @return dst */
Value or_value(Value src0, Value src1, Value dst) {
    /* Might allocate a new value so save the current pool state. */
    unsigned int pos = get_value_pos();
    /* Do a numeric computation if possible, otherwise fallback to bitstring
     * computation. */
    if (src0->numeric) {
        if (src1->numeric) {
            /* Both sources are numeric. */
            return or_value_numeric(src0,src1,dst);
        } else {
            /* src1 is not numeric, convert src0 to bitstring. */
            src0 = set_bitstring_value(src0,get_value());
        }
    } else {
        /* src0 is not numeric, what about src1. */
        if (src1->numeric) {
            /* src1 is numeric, convert it to bitstring. */
            src1 = set_bitstring_value(src1,get_value());
        }
    }
    /* The sources cannot be numeric, compute bitsitrings. */
    dst = or_value_bitstring(src0,src1,dst);
    /* Restores the pool of values. */
    set_value_pos(pos);
    /* Return the destination. */
    return dst;
}


/** Computes the XOR of two general values.
 *  @param src0 the first source value of the addition
 *  @param src1 the second source value of the addition
 *  @param dst the destination
 *  @return dst */
Value xor_value(Value src0, Value src1, Value dst) {
    /* Might allocate a new value so save the current pool state. */
    unsigned int pos = get_value_pos();
    /* Do a numeric computation if possible, otherwise fallback to bitstring
     * computation. */
    if (src0->numeric) {
        if (src1->numeric) {
            /* Both sources are numeric. */
            return xor_value_numeric(src0,src1,dst);
        } else {
            /* src1 is not numeric, convert src0 to bitstring. */
            src0 = set_bitstring_value(src0,get_value());
        }
    } else {
        /* src0 is not numeric, what about src1. */
        if (src1->numeric) {
            /* src1 is numeric, convert it to bitstring. */
            src1 = set_bitstring_value(src1,get_value());
        }
    }
    /* The sources cannot be numeric, compute bitsitrings. */
    dst = xor_value_bitstring(src0,src1,dst);
    /* Restores the pool of values. */
    set_value_pos(pos);
    /* Return the destination. */
    return dst;
}


/** Computes the left shift of two general values.
 *  @param src0 the first source value of the addition
 *  @param src1 the second source value of the addition
 *  @param dst the destination
 *  @return dst */
Value shift_left_value(Value src0, Value src1, Value dst) {
    /* Might allocate a new value so save the current pool state. */
    unsigned int pos = get_value_pos();
    /* Do a numeric computation if possible, otherwise fallback to bitstring
     * computation. */
    if (src0->numeric) {
        if (src1->numeric) {
            /* Both sources are numeric. */
            return shift_left_value_numeric(src0,src1,dst);
        } else {
            /* src0 is numeric, convert it to bitstring. */
            src0 = set_bitstring_value(src1,get_value());
        }
    } else {
        /* src0 is not numeric, what about src1. */
        if (src1->numeric) {
            /* src0 is not numeric, but src1. */
            return shift_left_value_bitstring_numeric(src0,src1,dst);
        }
    }
    /* The sources cannot be numeric, compute bitsitrings. */
    dst = shift_left_value_bitstring(src0,src1,dst);
    /* Restores the pool of values. */
    set_value_pos(pos);
    /* Return the destination. */
    return dst;
}


/** Computes the right shift of two general values.
 *  @param src0 the first source value of the addition
 *  @param src1 the second source value of the addition
 *  @param dst the destination
 *  @return dst */
Value shift_right_value(Value src0, Value src1, Value dst) {
    /* Might allocate a new value so save the current pool state. */
    unsigned int pos = get_value_pos();
    /* Do a numeric computation if possible, otherwise fallback to bitstring
     * computation. */
    if (src0->numeric) {
        if (src1->numeric) {
            /* Both sources are numeric. */
            return shift_right_value_numeric(src0,src1,dst);
        } else {
            /* src0 is numeric, convert it to bitstring. */
            src0 = set_bitstring_value(src1,get_value());
        }
    } else {
        /* src0 is not numeric, what about src1. */
        if (src1->numeric) {
            /* src0 is not numeric, but src1. */
            return shift_right_value_bitstring_numeric(src0,src1,dst);
        }
    }
    /* The sources cannot be numeric, compute bitsitrings. */
    dst = shift_right_value_bitstring(src0,src1,dst);
    /* Restores the pool of values. */
    set_value_pos(pos);
    /* Return the destination. */
    return dst;
}


/** Computes the equal (!XOR) of two general values.
 *  @param src0 the first source value of the addition
 *  @param src1 the second source value of the addition
 *  @param dst the destination value
 *  @return the destination value */
Value equal_value(Value src0, Value src1, Value dst) {
    /* Might allocate a new value so save the current pool state. */
    unsigned int pos = get_value_pos();
    /* Do a numeric computation if possible, otherwise fallback to bitstring
     * computation. */
    if (src0->numeric) {
        if (src1->numeric) {
            /* Both sources are numeric. */
            return equal_value_numeric(src0,src1,dst);
        } else {
            /* src1 is not numeric, convert src0 to bitstring. */
            src0 = set_bitstring_value(src0,get_value());
        }
    } else {
        /* src0 is not numeric, what about src1. */
        if (src1->numeric) {
            /* src1 is numeric, convert it to bitstring. */
            src1 = set_bitstring_value(src1,get_value());
        }
    }
    /* The sources cannot be numeric, compute bitsitrings. */
    dst = equal_value_bitstring(src0,src1,dst);
    /* Restores the pool of values. */
    set_value_pos(pos);
    /* Return the destination. */
    return dst;
}


/** Computes the lesser comparision of two general values.
 *  @param src0 the first source value of the addition
 *  @param src1 the second source value of the addition
 *  @param dst the destination value
 *  @return dst */
Value lesser_value(Value src0, Value src1, Value dst) {
    /* Might allocate a new value so save the current pool state. */
    unsigned int pos = get_value_pos();
    /* Do a numeric computation if possible, otherwise fallback to bitstring
     * computation. */
    if (src0->numeric && src1->numeric) {
        /* Both sources are numeric. */
        return lesser_value_numeric(src0,src1,dst);
    } else if (is_defined_value(src0) && is_defined_value(src1)) {
        /* Both sources can be converted to numeric values. */
        return lesser_value_defined_bitstring(src0,src1,dst);
    } else {
        /* Cannot compute (for now), simply undefines the destination. */
        /* First ensure dst has the right shape. */
        copy_value(src0,dst);
        /* Then make it undefined. */
        set_undefined_bitstring(dst);
    }
    return dst;
}


/** Computes the greater comparision of two general values.
 *  @param src0 the first source value of the addition
 *  @param src1 the second source value of the addition
 *  @param dst the destination value
 *  @return dst */
Value greater_value(Value src0, Value src1, Value dst) {
    /* Might allocate a new value so save the current pool state. */
    unsigned int pos = get_value_pos();
    /* Do a numeric computation if possible, otherwise fallback to bitstring
     * computation. */
    if (src0->numeric && src1->numeric) {
        /* Both sources are numeric. */
        return greater_value_numeric(src0,src1,dst);
    } else if (is_defined_value(src0) && is_defined_value(src1)) {
        /* Both sources can be converted to numeric values. */
        return greater_value_defined_bitstring(src0,src1,dst);
    } else {
        /* Cannot compute (for now), simply undefines the destination. */
        /* First ensure dst has the right shape. */
        copy_value(src0,dst);
        /* Then make it undefined. */
        set_undefined_bitstring(dst);
    }
    return dst;
}


/** Selects a value depending on a general condition.
 *  @param cond   the condition to use for selecting a value
 *  @param dst    the destination value (used only if new value is created).
 *  @param num    the number of values for the selection
 *  @return the selected value */
Value select_value(Value cond, Value dst, unsigned int num, ...) {
    va_list args;
    va_start(args,num);
    if (is_defined_value(cond)) {
        /* The condition can be made numeric. */
        dst = select_value_numeric(cond,dst,num,args);
    } else {
        /* The sources cannot be numeric, compute bitsitrings. */
        dst = select_value_bitstring(cond,dst,num,args);
    }
    va_end(args);
    return dst;
}

/** Concat multiple general values to a single one.
 *  @param dir the direction of the concatenation.
 *  @param num the number of values to concat
 *  @param dst the destination value
 *  @return dst */
Value concat_value(int num, int dir, Value dst, ...) {
    unsigned long long width = 0;
    int numeric = 1, i;
    va_list args;
    Value* values = alloca(num*sizeof(Value)); /* The values to concatenate. */
    va_start(args,dst);
    /* Copy the arguments to values for easier processing. */
    for(i=0; i<num; ++i) {
        values[i] = va_arg(args,Value);
    }
    /* check if all the sub values are numeric. */
    for(i=0; i<num; ++i) {
        if (!values[i]->numeric) {
            numeric = 0;
            break;
        }
    }
    /* Compute the resulting width to see if it first in a numeric. */
    if (numeric) {
        for(i = 0; i<num; ++i) {
            width += type_width(values[i]->type);
        }
        if (width > LONG_LONG_BIT) { numeric = 0; }
    }
    /* Reinitialize the access to the variadic arguments for further
     * accesses. */
    if (numeric) {
        /* The sub values are all numeric. */
        concat_value_numeric_array(num,dir,dst,values);
    } else {
        /* Cannot perfrom a numeric concatenation, do it for bitstrings. */
        /* First convert the numeric values to bitstrings. */
        for(i=0;i<num; ++i) {
            if (values[i]->numeric) {
                values[i] = set_bitstring_value(values[i],get_value());
            } 
        }

        /* The sub values are now all bitstrings. */
        concat_value_bitstring_array(num,dir,dst,values);
    }
    va_end(args);
    return dst;
}


/** Casts a value to another type.
 *  @param src the source value
 *  @param type the type to cast to
 *  @param dst the destination value
 *  @return dst */
Value cast_value(Value src, Type type, Value dst) {
    if (src->numeric) {
        /* The source is numeric. */
        return cast_value_numeric(src,type,dst);
    } else {
        /* The source cannot be numeric, compute bitsitrings. */
        return cast_value_bitstring(src,type,dst);
    }
}


/** Testing if a general value is 0.
 *  @param value the value to check 
 *  @return 1 if 0 and 0 otherwize */
int zero_value(Value value) {
    if (value->numeric) {
        /* The value is numeric. */
        return zero_value_numeric(value);
    } else {
        /* The value cannot be reduced to numeric: cannot be 0. */
        return 0;
    }
}


/** Testing if a value is defined or not.
 *  @param value the value to check
 *  @return 1 if defined and 0 otherwize */
int is_defined_value(Value value) {
    if (value->numeric) {
        /* Numeric values are defined by definition. */
        return 1;
    } else {
        /* Ensures the value contains only '0' and '1'. */
        unsigned long long width = type_width(value->type);
        unsigned long long i;
        char* data = value->data_str;
        for(i=0; i<width; ++i) {
            char bit = data[i];
            if ((bit != '0') && (bit != '1')) {
                /* Not defined. */
                return 0;
            }
        }
        /* Defined. */
        return 1;
    }
}


/** Testing if two general values have the same content (the type is not checked).
 *  @param value0 the first value to compare
 *  @param value1 the second value to compare
 *  @return 1 if same content. */
int same_content_value(Value value0, Value value1) {
    // printf("same_content_value with value0=%p value1=%p\n",value0,value1);
    // print_value(value0); printf(" "); print_value(value1); printf("\n");
    if (value0->numeric) {
        if (value1->numeric) {
            /* Both values are numeric. */
            return same_content_value_numeric(value0,value1);
        } else {
            /* One value is numeric, the othert is not, different. */
            return 0;
        }
    } else if (value1->numeric) {
        /* One value is numeric, the othert is not, different. */
        return 0;
    } else {
        /* Both values are bitstring. */
        return same_content_value_bitstring(value0,value1);
    }
}


/** Testing if two general values have the same content (the type is not checked).
 *  @param value0 the first value to compare
 *  @param first the first index of the range
 *  @param last the last index of the range
 *  @param value1 the second value to compare
 *  @return 1 if same content. */
int same_content_value_range(Value value0,
        unsigned long long first, unsigned long long last, Value value1) {
    if (value0->numeric) {
        if (value1->numeric) {
            /* Both values are numeric. */
            return same_content_value_range_numeric(value0,first,last,value1);
        } else {
            /* One value is numeric the other is not, different. */
            return 0;
        }
    } else if (value1->numeric) {
        /* One value is numeric, the other is not, different. */
        return 0;
    } else {
        /* Both values are bitstring. */
        return same_content_value_range_bitstring(value0,first,last,value1);
    }
}


/* ############# End of the computation of general values.   ################ */





/** Creates a reference to a range inside a signal.
 *  @param signal the signal to refer
 *  @param first the start index of the range
 *  @param last the end index of the range
 *  @return the resulting reference */
RefRangeS make_ref_rangeS(SignalI signal, unsigned long long first,
        unsigned long long last) {
    RefRangeS result = { signal, first, last };
    return result;
}






/* Access and conversion functions. */

// /** Read and convert to 8-bit a value.
//  *  @param value the value to read
//  *  @return the resulting 8-bit value */
// char read8(Value value) {
//     return value->data[0] & 0xFF;
// }
// 
// /** Read and convert to 16-bit a value.
//  *  @param value the value to read
//  *  @return the resulting 16-bit value */
// short read16(Value value) {
//     return value->data[0] & 0xFFFF;
// }
// 
// /** Read and convert to 32-bit a value.
//  *  @param value the value to read 
//  *  @return the resulting 32-bit value */
// int read32(Value value) {
//     return value->data[0] & 0xFFFFFFFF;
// }
// 
// /** Read and convert to 64-bit a value.
//  *  @param value the value to read 
//  *  @return the resulting 64-bit value */
// long long read64(Value value) {
//     return value->data[0];
// }

/** Converts a value to a long long int.
 *  @param value the value to convert
 *  @return the resulting int. */
unsigned long long value2integer(Value value) {
    unsigned long long width = type_width(value->type);
    /* If the value is numeric, just return its data as is. */
    if (value->numeric) {
        return value->data_int & ~((unsigned long long)(-1LL) << width);
    }
    /* Otherwise convert the bitstring to an integer if possible,
     * but return 0 in case of failure. */
    /* Gets the width of the value. */
    unsigned long long res = 0;
    unsigned long long i;
    char bit;
    /* Access the bitstring data. */
    char* data_str = value->data_str;
    // printf("value2integer with data_str=%s\n",data_str);
    /* Copy the bits. */
    for (i=0; i<width && i<LONG_LONG_BIT; ++i) {
        /* Get the bit. */
        bit = data_str[width-i-1]-'0';
        if ((bit != 0) && (bit != 1)) {
            /* Cannot convert, return 0. */
            return 0;
        }
        /* Write the bit. */
        res = (res << 1) | bit;
    }
    // printf("first res=%llx\n",res);
    unsigned long long bit0 = (data_str[width-1]-'0') << i;
    /* Perform the sign extension if required. */
    if (i>=width && value->type->flags.sign) {
        for(; i<LONG_LONG_BIT; ++i) {
            // res = (res << 1) | bit;
            res |= bit0;
            bit0 <<= 1;
        }
    }
    // printf("then res=%llx\n",res);
    return res;
}

/** Reads a range from a value. 
 *  @param value the value to read
 *  @param first the first index of the range
 *  @param last the last index of the range
 *  @param base the type of the elements
 *  @param dst the destination value
 *  @return dst */
Value read_range(Value value, long long first, long long last, Type base,
                Value dst) {
    /* Is the value numeric? */
    if (value->numeric) {
        /* Yes, do a numeric range read. */
        return read_range_numeric(value,first,last,base,dst);
    } else {
        /* No, do a bitstring range read. */
        return read_range_bitstring(value,first,last,base,dst);
    }
}


// /** Writes 8 bits to a value
//  *  @param data the data to write
//  *  @param value the target value */
// void write8(char data, Value value) {
//     /* Get the actual target value from: it should be the future value
//      * (f_value) is case it is a signal value. */
//     SignalI signal = value->signal;
//     if (signal) value = signal->f_value;
//     /* Sets the value. */
//     value->data[0] = (value->data[0] & 0xFFFFFFFFFFFFFF00ULL) | data;
//     /* Touch the corresponding signal (if any). */
//     if (signal) touch_signal(signal);
// }
// 
// /** Writes 16 bits to a value
//  *  @param data the data to write
//  *  @param value the target value */
// void write16(short data, Value value) {
//     /* Get the actual target value from: it should be the future value
//      * (f_value) is case it is a signal value. */
//     SignalI signal = value->signal;
//     if (signal) value = signal->f_value;
//     /* Sets the value. */
//     value->data[0] = (value->data[0] & 0xFFFFFFFFFFFF0000ULL) | data;
//     /* Touch the corresponding signal (if any). */
//     if (signal) touch_signal(signal);
// }
// 
// /** Writes 32 bits to a value
//  *  @param data the data to write
//  *  @param value the target value */
// void write32(int data, Value value) {
//     /* Get the actual target value from: it should be the future value
//      * (f_value) is case it is a signal value. */
//     SignalI signal = value->signal;
//     if (signal) value = signal->f_value;
//     /* Sets the value. */
//     value->data[0] = (value->data[0] & 0xFFFFFFFF00000000ULL) | data;
//     /* Touch the corresponding signal (if any). */
//     if (signal) touch_signal(signal);
// }
// 
// /** Writes 64 bits to a value
//  *  @param data the data to write
//  *  @param value the target value */
// void write64(long long data, Value value) {
//     /* Get the actual target value from: it should be the future value
//      * (f_value) is case it is a signal value. */
//     SignalI signal = value->signal;
//     if (signal) value = signal->f_value;
//     /* Sets the value. */
//     value->data[0] = data;
//     /* Touch the corresponding signal (if any). */
//     if (signal) touch_signal(signal);
// }

/** Writes to a range within a value. 
 *  NOTE: the type of the destination is NOT changed!
 *  @param src the source value
 *  @param first the first index of the range
 *  @param last the last index of the range
 *  @param base the type of the elements
 *  @param dst the destination value
 *  @return dst */
Value write_range(Value src, long long first, long long last, Type base,
        Value dst) {
    // printf("write_range\n");
    /* Is the value numeric? */
    if ((src->numeric) && (dst->numeric)) {
        /* Yes, do a numeric range read. */
        // return write_range_numeric(src,first,last,dst);
        return write_range_numeric(src,first,last,base,dst);
    } else {
        /* No, do a bitstring range read. */
        if (dst->numeric) {
            /* Need to convert the destination to a bitstring. */
            dst = set_bitstring_value(dst,get_value());
        } else if (src->numeric) {
            /* Need to convert the source to a bitstring. */
            src = set_bitstring_value(src,get_value());
        }
        // return write_range_bitstring(src,first,last,dst);
        return write_range_bitstring(src,first,last,base,dst);
    }
}

/** Writes to a range within a value without overwriting with Z. 
 *  NOTE: the type of the destination is NOT changed!
 *  @param src the source value
 *  @param first the first index of the range
 *  @param last the last index of the range
 *  @param base the type of the elements
 *  @param dst the destination value
 *  @return dst */
Value write_range_no_z(Value src, long long first, long long last, Type base,
        Value dst) {
    // printf("write_range_no_z\n");
    /* Is the value numeric? */
    if ((src->numeric) && (dst->numeric)) {
        /* Yes, do a numeric range read. */
        return write_range_numeric(src,first,last,base,dst);
    } else {
        /* No, do a bitstring range read. */
        if (dst->numeric) {
            /* Need to convert the destination to a bitstring. */
            dst = set_bitstring_value(dst,get_value());
        } else if (src->numeric) {
            /* Need to convert the source to a bitstring. */
            src = set_bitstring_value(src,get_value());
        }
        // return write_range_bitstring_no_z(src,first,last,dst);
        return write_range_bitstring_no_z(src,first,last,base,dst);
    }
}




#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <limits.h>
#include "hruby_sim.h"


/**
 *  The HDLRuby simulation calculation engine, to be used with C code
 *  generated by hruby_low2c. 
 **/


/* Helping macros. */

/* The number of bits in an int. */
#define INT_BIT (sizeof(int)*CHAR_BIT)

/** The min between two values. */
#define min2(a,b) \
   ({ __typeof__ (a) _a = (a); \
      __typeof__ (b) _b = (b); \
      _a <= _b ? _a : _b; })

/** The min between three values. */
#define min3(a,b,c) \
   ({ __typeof__ (a) _a = (a); \
      __typeof__ (b) _b = (b); \
      __typeof__ (c) _c = (c); \
      _a <= _b ? (_a <= _c ? _a : _c) : (_b <= _c ? _b : _c); })

/** Get the word used for extending a value in unsigned unsigned long long. */
#define word_extL(v) \
    ({ __typeof__ (v) _v = (v); \
       _v->type->flags.sign ? ULLONG_MAX : 0; })

/** Get the word used for extending a value in unsigned unsigned int. */
#define word_ext(v) \
    ({ __typeof__ (v) _v = (v); \
       _v->type->flags.sign ? UINT_MAX : 0; })

/* The type engine: each type is simplified to a vector of X elements
 * of Y bits. */




/* The interface to the type engine. */

/** Computes the width in bits of a type.
 *  @param type the type to compute the width
 *  @return the resulting width in bits */
unsigned long long type_width(Type type) {
    return type->size * type->base;
}

/** Gets the single bit type. */
Type get_type_bit() {
    static TypeS type_bit = { 1, 1, { 0 } };
    return &type_bit;
}

/** Gets the single signed bit type. */
Type get_type_signed() {
    static TypeS type_sign = { 1, 1, { 1 } };
    return &type_sign;
}

/** Creates a type from a HDLRuby TypeVector.
 *  @param base the base type
 *  @size the size of the vector in number of base elements */
Type make_type_vector(Type base, unsigned int size) {
    Type type = calloc(sizeof(TypeS),0);
    type->size = size;
    type->base = type_width(base);
    type->flags.sign = base->flags.sign;
    return type;
}



/* The calculation engine. */

/* The accumulator. */
ValueS accumulator_content = { NULL, 0, 0, 0, NULL };
Value accumulator = &accumulator_content;

/* Creating and fill values. */

/** Creates a new value.
 *  @param type the type of the value
 *  @return the resulting value */
Value make_value(Type type) {
    /* Compute the size in words of the data contained in the value. */
    unsigned long long width = type_width(type);
    unsigned long long size = width / INT_BIT;
    if (width % INT_BIT != 0) size += 1;

    /* Allocate the value. */
    Value res = calloc(sizeof(ValueS),1);
    /* Allocates the data of the value. */
    res->data = calloc(sizeof(int),size);

    /* Initialize it. */
    res->type = type;
    res->size = size;
    res->capacity = size;

    return res;
}

/** Make the size of a value able to store size ints.
 *  @note The content of the value is lost!
 *  @note do not change the type of the value, only its capacity.
 *  @praam value the value to change
 *  @param size the size to match */
void resize_value(Value value, int size) {
    if (value->capacity < size) {
        /* Resizing required, to limit frequent resize, double the
         * required new capacity. */
        /* Free the former data. */
        free(value->data);
        /* Reallocate it. */
        value->data = calloc(sizeof(int),size*2);
        /* Update the size. */
        value->capacity = size*2;
    }
}

/** Sets a value with data.
 *  @param value the value to fill
 *  @param numeral tell if the value is in numeral form or in bitstring form
 *  @param data the source data */
void set_value(Value value, int numeral, void* data) {
    value->numeral = numeral ? 1 : 0;
    memcpy(value->data,data,value->size*sizeof(int));
}

/** Makes and sets a value with data.
 *  @param type the type of the value
 *  @param numeral tell if the value is in numeral form or in bitstring form
 *  @param data the source data */
Value make_set_value(Type type, int numeral, void* data) {
    Value value = make_value(type);
    set_value(value,numeral,data);
    return value;
}




/* The interface to the value computation engine. */




/** Computes the neg of a value and put the result in the accumulator.
 *  @param src the source value of the not
 *  @return the accumulator */
Value neg_value(Value src) {
    /* Get the size of the result from the source. */
    unsigned long long size = src->size;

    /* Update the accumulator capacity if required. */
    resize_value(accumulator,size);
    /* set the type and size of the accumulator the the type of the source. */
    accumulator->type = src->type;
    accumulator->size = src->size;
    accumulator->numeral = src->numeral;

    /* Get access to the data of the source. */
    unsigned int *src_data = src->data;
    /* Get access to the data of the destination. */
    unsigned int *dst_data = accumulator->data;

    /* Perform the word-wise subtraction. */
    unsigned long long count;
    unsigned int carry = 0;
    for(count = 0; count < size; ++count) {
        /* Performs the subtraction, double size for the carry. */
        unsigned long long d = src_data[count];
        unsigned long long res = - d + (1-carry);
        /* Compute the next carry. */
        carry = res >> (INT_BIT);
        /* Set the data of the accumulator. */
        dst_data[count] = res;
    }
    /* Return the accumulator as result. */
    return accumulator;
}


/** Computes the addition of two values and put the result in the
 *  accumulator.
 *  @param src0 the first source value of the addition
 *  @param src1 the second source value of the addition
 *  @return the accumulator */
Value add_value(Value src0, Value src1) {
    /* Get the sizes of the sources. */
    unsigned long long src0_size = src0->size;
    unsigned long long src1_size = src1->size;

    /* Update the accumulator capacity if required. */
    resize_value(accumulator,src0_size);
    /* set the type and size of the accumulator to the type first source. */
    accumulator->type = src0->type;
    accumulator->size = src0_size;
    accumulator->numeral = src0->numeral;

    /* Get access to the data of each source. */
    unsigned int *src0_data = src0->data;
    unsigned int *src1_data = src1->data;
    /* Get access to the data of teh accumulator. */
    unsigned int *dst_data = accumulator->data;

    /* Perform the word-wise addition. */
    unsigned long long count;
    unsigned int carry = 0;
    unsigned long long ext = word_extL(src1);
    for(count = 0; count < src0_size; ++count) {
        /* Performs the addition, double size for the carry. */
        unsigned long long d0 = src0_data[count];
        unsigned long long d1 = count <= src1_size ? src1_data[count] : ext;
        unsigned long long res = d0 + d1 + carry;
        /* Compute the next carry. */
        carry = res >> (INT_BIT);
        /* Set the data of the destination. */
        dst_data[count] = res;
    }
    /* Return the accumulator. */
    return accumulator;
}


/** Computes the subtrasction of two values and put the result in the
 *  accumulator.
 *  @param src0 the first source value of the addition
 *  @param src1 the second source value of the addition
 *  @return the accumulator */
Value sub_value(Value src0, Value src1) {
    /* Get the sizes of the sources. */
    unsigned long long src0_size = src0->size;
    unsigned long long src1_size = src1->size;

    /* Update the accumulator capacity if required. */
    resize_value(accumulator,src0_size);
    /* set the type and size of the accumulator to the type first source. */
    accumulator->type = src0->type;
    accumulator->size = src0_size;
    accumulator->numeral = src0->numeral;

    /* Get access to the data of each source. */
    unsigned int *src0_data = src0->data;
    unsigned int *src1_data = src1->data;
    /* Get access to the data of teh accumulator. */
    unsigned int *dst_data = accumulator->data;

    /* Perform the word-wise subtraction. */
    unsigned long long count;
    unsigned int carry = 0;
    unsigned long long ext = word_extL(src1);
    for(count = 0; count < src0_size; ++count) {
        /* Performs the subtraction, double size for the carry. */
        unsigned long long d0 = src0_data[count];
        unsigned long long d1 = count <= src1_size ? src1_data[count] : ext;
        unsigned long long res = d0 - d1 + (1-carry);
        /* Compute the next carry. */
        carry = res >> (INT_BIT);
        /* Set the data of the destination. */
        dst_data[count] = res;
    }
    /* Return the accumulator. */
    return accumulator;
}


/** Computes the NOT of a value and put the result in the accumulator.
 *  @param src the source value of the not
 *  @return the accumulator */
Value not_value(Value src) {
    /* Get the size of the result from the source. */
    unsigned long long size = src->size;

    /* Update the accumulator capacity if required. */
    resize_value(accumulator,size);
    /* set the type and size of the accumulator the the type of the source. */
    accumulator->type = src->type;
    accumulator->size = src->size;
    accumulator->numeral = src->numeral;

    /* Get access to the data of the source. */
    unsigned int *src_data = src->data;
    /* Get access to the data of the destination. */
    unsigned int *dst_data = accumulator->data;

    /* Perform the word-wise NOT. */
    unsigned long long count;
    for(count = 0; count < size; ++count) {
        /* Performs the subtraction, double size for the carry. */
        unsigned long long d = src_data[count];
        unsigned long long res = ~d;
        /* Set the data of the accumulator. */
        dst_data[count] = res;
    }
    /* Return the accumulator as result. */
    return accumulator;
}


/** Computes the AND of two values and put the result in the
 *  accumulator.
 *  @param src0 the first source value of the addition
 *  @param src1 the second source value of the addition
 *  @return the accumulator */
Value and_value(Value src0, Value src1) {
    /* Get the sizes of the sources. */
    unsigned long long src0_size = src0->size;
    unsigned long long src1_size = src1->size;

    /* Update the accumulator capacity if required. */
    resize_value(accumulator,src0_size);
    /* set the type and size of the accumulator to the type first source. */
    accumulator->type = src0->type;
    accumulator->size = src0_size;
    accumulator->numeral = src0->numeral;

    /* Get access to the data of each source. */
    unsigned int *src0_data = src0->data;
    unsigned int *src1_data = src1->data;
    /* Get access to the data of teh accumulator. */
    unsigned int *dst_data = accumulator->data;

    /* Perform the word-wise AND. */
    unsigned long long count;
    unsigned int ext = word_ext(src1);
    for(count = 0; count < src0_size; ++count) {
        /* Performs the AND, double size for the carry. */
        unsigned int d0 = src0_data[count];
        unsigned int d1 = count <= src1_size ? src1_data[count] : ext;
        unsigned int res = d0 & d1;
        /* Set the data of the destination. */
        dst_data[count] = res;
    }
    /* Return the accumulator. */
    return accumulator;
}


/** Computes the OR of two values and put the result in the
 *  accumulator.
 *  @param src0 the first source value of the addition
 *  @param src1 the second source value of the addition
 *  @return the accumulator */
Value or_value(Value src0, Value src1) {
    /* Get the sizes of the sources. */
    unsigned long long src0_size = src0->size;
    unsigned long long src1_size = src1->size;

    /* Update the accumulator capacity if required. */
    resize_value(accumulator,src0_size);
    /* set the type and size of the accumulator to the type first source. */
    accumulator->type = src0->type;
    accumulator->size = src0_size;
    accumulator->numeral = src0->numeral;

    /* Get access to the data of each source. */
    unsigned int *src0_data = src0->data;
    unsigned int *src1_data = src1->data;
    /* Get access to the data of teh accumulator. */
    unsigned int *dst_data = accumulator->data;

    /* Perform the word-wise OR. */
    unsigned long long count;
    unsigned int ext = word_ext(src1);
    for(count = 0; count < src0_size; ++count) {
        /* Performs the OR, double size for the carry. */
        unsigned int d0 = src0_data[count];
        unsigned int d1 = count <= src1_size ? src1_data[count] : ext;
        unsigned int res = d0 | d1;
        /* Set the data of the destination. */
        dst_data[count] = res;
    }
    /* Return the accumulator. */
    return accumulator;
}


/** Computes the XOR of two values and put the result in the
 *  accumulator.
 *  @param src0 the first source value of the addition
 *  @param src1 the second source value of the addition
 *  @return the accumulator */
Value xor_value(Value src0, Value src1) {
    /* Get the sizes of the sources. */
    unsigned long long src0_size = src0->size;
    unsigned long long src1_size = src1->size;

    /* Update the accumulator capacity if required. */
    resize_value(accumulator,src0_size);
    /* set the type and size of the accumulator to the type first source. */
    accumulator->type = src0->type;
    accumulator->size = src0_size;
    accumulator->numeral = src0->numeral;

    /* Get access to the data of each source. */
    unsigned int *src0_data = src0->data;
    unsigned int *src1_data = src1->data;
    /* Get access to the data of teh accumulator. */
    unsigned int *dst_data = accumulator->data;

    /* Perform the word-wise XOR. */
    unsigned long long count;
    unsigned int ext = word_ext(src1);
    for(count = 0; count < src0_size; ++count) {
        /* Performs the OR, double size for the carry. */
        unsigned int d0 = src0_data[count];
        unsigned int d1 = count <= src1_size ? src1_data[count] : ext;
        unsigned int res = d0 ^ d1;
        /* Set the data of the destination. */
        dst_data[count] = res;
    }
    /* Return the accumulator. */
    return accumulator;
}


/** Copies a value to another, the type of the destination is preserved.
 *  @param src the source value
 *  @param dst the destination value */
void copy_value(Value src, Value dst) {
    /* compute the sallest size, it will be the limite of the word-wise
     * computation. */
    unsigned long long dst_size = dst->size;
    unsigned long long src_size = src->size;
    unsigned long long small = min2(src_size,dst_size);

    // printf("dst_size=%llu, src_size=%llu, small=%llu\n",dst_size,src_size,small);

    /* Update the kind of destination value: numeral or bitstring. */
    dst->numeral = src->numeral;

    /* Get access to the data of each value. */
    unsigned int *src_data = src->data;
    unsigned int *dst_data = dst->data;
    // printf("src_data=%p dst_data=%p\n",src_data,dst_data);

    /* Perform the word-wise subtraction. */
    unsigned long long count;
    for(count = 0; count < small; ++count) {
        /* Performs the subtraction, double size for the carry. */
        unsigned int d = src_data[count];
        /* Set the data of the destination. */
        dst_data[count] = d;
    }
    // printf("count=%llu\n",count);

    /* Performs the extra subtractions if required. */
    if (count == dst_size) return; /* End here. */
    else {
        /* Words of the source have been fully used. */
        /* Go on with the subraction using the sign extension of the
         * source. */
        unsigned int ext = word_ext(src);
        for(;count < dst_size; ++count) {
            /* Set the data of the destination. */
            dst_data[count] = ext;
        }
        /* End of the computation. */
        return;
    }
}


/** Testing if a value is 0.
 *  @param value the value to check 
 *  @return 1 if 0 and 0 otherwize */
int zero_value(Value value) {
    unsigned long long i;
    unsigned long long size = value->size;
    
    for(i=0; i<size; ++i) {
        if (value->data[i] != 0)
            /* The value is not 0. */
            return 0;
    }
    /* The value is 0. */
    return 1;
}


/** Testing if two values have the same content (the type is not checked).
 *  @param value0 the first value to compare
 *  @param value1 the second value to compare
 *  @return 1 if same content. */
int same_content_values(Value value0, Value value1) {
    unsigned long long i;
    unsigned long long size = value0->size;
    /* Compare the sizes. */
    if (value1->size != size) return 0;
    /* Compare the data. */
    unsigned int* data0 = value0->data;
    unsigned int* data1 = value1->data;
    for(i=0; i<size; ++i) {
        if (data0[i] != data1[i])
            /* The contents are different. */
            return 0;
    }
    /* The values have the same content. */
    return 1;
}


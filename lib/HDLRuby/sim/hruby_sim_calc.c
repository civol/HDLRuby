#include <stdio.h>
#include <stdarg.h>
#include <stdlib.h>
#include <string.h>
#include <limits.h>
#include "hruby_sim.h"


/**
 *  The HDLRuby simulation calculation engine, to be used with C code
 *  generated by hruby_low2c. 
 **/


/* Helping macros. */

/* The number of bits in an int. */
#define INT_BIT (sizeof(int)*CHAR_BIT)

/** The min between two values. */
#define min2(a,b) \
   ({ __typeof__ (a) _a = (a); \
      __typeof__ (b) _b = (b); \
      _a <= _b ? _a : _b; })

/** The min between three values. */
#define min3(a,b,c) \
   ({ __typeof__ (a) _a = (a); \
      __typeof__ (b) _b = (b); \
      __typeof__ (c) _c = (c); \
      _a <= _b ? (_a <= _c ? _a : _c) : (_b <= _c ? _b : _c); })

/** Get the word used for extending a value in unsigned unsigned long long. */
#define word_extL(v) \
    ({ __typeof__ (v) _v = (v); \
       _v->type->flags.sign ? ULLONG_MAX : 0; })

/** Get the word used for extending a value in unsigned unsigned int. */
#define word_ext(v) \
    ({ __typeof__ (v) _v = (v); \
       _v->type->flags.sign ? UINT_MAX : 0; })

/* The type engine: each type is simplified to a vector of X elements
 * of Y bits. */




/* The interface to the type engine. */


/* The hash table of existing types. */
#define HASH_TYPE_SIZE 1024
static List hash_type[HASH_TYPE_SIZE] = {};

/** Computes the hash value of a type.
 *  @param base the width of an element
 *  @param number the number of elements
 *  @param flags the flags of the type
 *  @return the resulting type. */
static int hash_value(unsigned long long base, unsigned long long number,
                      FlagsS flags) {
    return ((base+flags.all)^(number)) & 1023;
}

/** Adds a type to the hash of types.
 *  @param type the type to add */
static void add_hash_type(Type type) {
    /* Compute the hash value. */
    int hvalue = hash_value(type->base,type->number,type->flags);
    /* See if there is already an entry for this hash value. */
    List entry = hash_type[hvalue];
    if (!entry) {
        /* No entry, create a new one. */
        entry = malloc(sizeof(List));
        entry = build_list(entry);
    }
    /* Adds the type to the entry. */
    Elem elem = get_element(type);
    add_list(entry,elem);
}

/** Gets a type from the hash of types.
 *  @param base the type of an element
 *  @param number the number of elements
 *  @return the resulting type */
static Type get_hash_type(Type base, unsigned long long number) {
    /* Compute the width of the base. */
    unsigned long long bw = type_width(base);
    FlagsS flags = base->flags;
    /* Compute the hash value. */
    int hvalue = hash_value(bw,number,flags);
    /* See if there is already an entry for this hash value and look
     * for the type in it. */
    List entry = hash_type[hvalue];
    if (entry) {
        /* Look into the entry for the type. */
        Elem elem = entry->head;
        while(elem) {
            Type type = elem->data;
            if ((type->base == bw) && (type->number == number) &&
                (type->flags.all == flags.all)) {
                /* The type is found. */
                return type;
            }
            elem = elem->next;
        }
    }
    /* The element is not found. */
    return NULL;
}


/** Computes the width in bits of a type.
 *  @param type the type to compute the width
 *  @return the resulting width in bits */
unsigned long long type_width(Type type) {
    return type->base * type->number;
}

/** Gets the single bit type. */
Type get_type_bit() {
    static TypeS type_bit = { 1, 1, { 0 } };
    return &type_bit;
}

/** Gets the single signed bit type. */
Type get_type_signed() {
    static TypeS type_sign = { 1, 1, { 1 } };
    return &type_sign;
}

/** Creates a type by base type and number of elements.
 *  @param base the type of an element
 *  @number the number of elements */
Type make_type_vector(Type base, unsigned long long number) {
    /* Create the type. */
    Type type = calloc(sizeof(TypeS),0);
    type->base = type_width(base);
    type->number = number;
    type->flags = base->flags;
    /* Add it to the hash of types. */
    add_hash_type(type);
    /* Return the result. */
    return type;
}

/** Gets a vector type by base type and number of elements.
 *  @param base the type of an element
 *  @param number the number of elements */
Type get_type_vector(Type base, unsigned long long number) {
    Type type = get_hash_type(base,number);
    if (type == NULL)
        /* The type does not exist yet, create it. */
        return make_type_vector(base,number);
    else
        /* The type already exists, return it. */
        return type;
}

// /** Gets a vector type by width and number of elements.
//  *  @param base the width of an element
//  *  @param number the number of elements 
//  *  @param flags the flags of the type */
// static Type get_type_vector_flat(unsigned long long base, 
//                                  unsigned long long number
//                                  unsigned int flags){
//     Type type = get_hash_type(base,number);
//     if (type == NULL)
//         /* The type does not exist yet, create it. */
//         return make_type_vector_flat(base,number);
//     else
//         /* The type already exists, return it. */
//         return type;
// }



/* The calculation engine. */

// /* The accumulator. */
// ValueS accumulator_content = { NULL, 0, 0, 0, NULL };
// Value accumulator = &accumulator_content;

/* Creating and fill values. */

/** Creates a new value.
 *  @param type the type of the value
 *  @return the resulting value */
Value make_value(Type type) {
    /* Compute the size in words of the data contained in the value. */
    unsigned long long width = type_width(type);
    unsigned long long size = width / INT_BIT;
    if (width % INT_BIT != 0) size += 1;

    /* Allocate the value. */
    Value res = calloc(sizeof(ValueS),1);
    /* Allocates the data of the value. */
    res->data = calloc(sizeof(int),size);

    /* Initialize it. */
    res->type = type;
    res->size = size;
    res->capacity = size;

    return res;
}

/** Make the size of a value able to store size ints.
 *  @note The content of the value is lost!
 *  @note do not change the type of the value, only its capacity.
 *  @praam value the value to change
 *  @param size the size to match */
void resize_value(Value value, int size) {
    if (value->capacity < size) {
        /* Resizing required, to limit frequent resize, double the
         * required new capacity. */
        /* Free the former data. */
        free(value->data);
        /* Reallocate it. */
        value->data = calloc(sizeof(int),size*2);
        /* Update the size. */
        value->capacity = size*2;
    }
}

/** Sets a value with data.
 *  @param value the value to fill
 *  @param numeric tell if the value is in numeric form or in bitstring form
 *  @param data the source data */
void set_value(Value value, int numeric, void* data) {
    value->numeric = numeric ? 1 : 0;
    memcpy(value->data,data,value->size*sizeof(int));
}

/** Makes and sets a value with data.
 *  @param type the type of the value
 *  @param numeric tell if the value is in numeric form or in bitstring form
 *  @param data the source data */
Value make_set_value(Type type, int numeric, void* data) {
    Value value = make_value(type);
    set_value(value,numeric,data);
    return value;
}




/* The interface to the value computation engine. */

/* ################### Value-kind independant computations. ############## */

/** Set a value to numeric (numerical) state if possible.
 *  @param value the value to process
 *  @return 1 in case of success, 0 otherwise */
int set_numeric_value(Value value) {
    if (value->numeric) {
        /* The value is already numeric. */
        return 1;
    }
    /* Not even trying to convert! */
    return 0;
}

/** Copies a value to another, the type of the destination is preserved.
 *  @param src the source value
 *  @param dst the destination value */
void copy_value(Value src, Value dst) {
    /* compute the sallest size, it will be the limite of the word-wise
     * computation. */
    unsigned long long dst_size = dst->size;
    unsigned long long src_size = src->size;
    unsigned long long small = min2(src_size,dst_size);

    // printf("dst_size=%llu, src_size=%llu, small=%llu\n",dst_size,src_size,small);

    /* Update the kind of destination value: numeric or bitstring. */
    dst->numeric = src->numeric;

    /* Get access to the data of each value. */
    unsigned int *src_data = src->data;
    unsigned int *dst_data = dst->data;
    // printf("src_data=%p dst_data=%p\n",src_data,dst_data);

    /* Perform the word-wise copy. */
    unsigned long long count;
    for(count = 0; count < small; ++count) {
        /* Performs the copy, double size for the carry. */
        unsigned int d = src_data[count];
        /* Set the data of the destination. */
        dst_data[count] = d;
    }
    // printf("count=%llu\n",count);

    /* Performs the extra copies if required. */
    if (count == dst_size) return; /* End here. */
    else {
        /* Words of the source have been fully used. */
        /* Go on with the copy using the sign extension of the
         * source. */
        unsigned int ext = word_ext(src);
        for(;count < dst_size; ++count) {
            /* Set the data of the destination. */
            dst_data[count] = ext;
        }
        /* End of the computation. */
        return;
    }
}


/* ############# Start of the computation of bitstring values. ############ */

/** Creates a bitstring value from a numeric value.
 *  @param src the numeric source value
 *  @param dst the destination value
 *  @return dst. */
static Value set_bitstring_value(Value src, Value dst) {
    /* Compute the width in bits of the result. */
    unsigned long long width = type_width(src->type);
    unsigned long long i;
    /* Compute the size in int of the result. */
    unsigned long long size = width/INT_BIT;
    if (width % INT_BIT) size += 1;
    /* Resize dst to match the size. */
    resize_value(dst,size);
    /* set the type and size of the destination the the type of the source. */
    dst->type = src->type;
    dst->size = src->size;
    dst->numeric = src->numeric;

    /* Access the data of the source and the destination. */
    unsigned int* src_data = src->data;
    char* dst_data = (char*)(dst->data);

    /* Make the conversion. */
    for(i=0; i < width; ++i) {
        /* Get the bit from the source. */
        unsigned long long wp = i / size;
        unsigned int mask = 1 << (i % size);
        char bit = src_data[wp]&mask ? '1' : '0';
        /* And write it. */
        dst_data[i] = bit;
    }
    /* Return the destination. */
    return dst;
}


/** Computes the neg of a bitstring value.
 *  @param src the source value of the not
 *  @param dst the destination value
 *  @return dst */
static Value neg_value_bitstring(Value src, Value dst) {
    /* Get the size of the result from the sources. */
    unsigned long long size = src->size;
    /* Compute the width of the result in bits. */
    unsigned long long width = type_width(src->type);

    /* Update the destination capacity if required. */
    resize_value(dst,size);
    /* set the type and size of the destination the the type of the source. */
    dst->type = src->type;
    dst->size = src->size;
    dst->numeric = 0;

    /* Access the source and destination data. */
    char* src_data = (char*)(src->data);
    char* dst_data = (char*)(dst->data);

    /* Performs the negation. */
    unsigned long long count;
    char carry = 1;
    for(count = 0; count < width; ++count) {
        /* Performs the negation. */
        char d = ((char*)src_data)[count] - '0'; /* Get and convert to bit. */
        char res;
        if (d == (d&1)) { /* d is defined. */
            res = d ^ carry;
            carry = d & carry;
        } else {
            /* Undefined, end here. */
            break;
        }
        ((char*)dst_data)[count] = res;
    }
    /* The remaining bits are undefined. */
    for(;count < size*INT_BIT; ++count) {
        ((char*)dst_data)[count] = 'x';
    }
    /* Return the destination. */
    return dst;
}


/** Computes the addition of two bitstring values.
 *  @param src0 the first source value of the addition
 *  @param src1 the second source value of the addition
 *  @param dst the destination value
 *  @return dst */
static Value add_value_bitstring(Value src0, Value src1, Value dst) {
    /* Get the size of the result from the sources. */
    unsigned long long size0 = src0->size;
    /* Compute the width of sources in bits. */
    unsigned long long width0 = type_width(src0->type);
    unsigned long long width1 = type_width(src1->type);

    /* Update the destination capacity if required. */
    resize_value(dst,size0);
    /* set the type and size of the destination the the type of the source. */
    dst->type = src0->type;
    dst->size = src0->size;
    dst->numeric = 0;

    /* Get access to the data of the sources. */
    unsigned int *src0_data = src0->data;
    unsigned int *src1_data = src1->data;
    /* Get access to the data of the destination. */
    unsigned int *dst_data = dst->data;

    /* Get the sign extension character of source 1 and convert it to a bit.*/
    int ext = src1->type->flags.sign ?  src1_data[width1-1] - '0' : 0;
    /* Perform the addition. */
    unsigned long long count;
    char carry = 0;
    for(count = 0; count < width0; ++count) {
        /* Performs the addition. */
        char d0 = ((char*)src0_data)[count] - '0'; /* Get and convert to bit. */
        char res;
        if (count < width1) {
            char d1 = ((char*)src1_data)[count] - '0';/* Get and convert to bit. */
            if ((d0 == (d0&1)) && (d1 == (d1&1))) {
                /* d0 and d1 are defined. */
                res = d0 ^ d1 ^ carry;
                carry = (d0&d1) | (d0&carry) | (d1&carry);
            } else {
                /* Either input bit is undefined, end here. */
                break;
            }
        } else {
            /* All the bit of source 1 are used, go on using the sign
             * extension. */
            if (ext != (ext&1)) {
                /* The sign extension is undefined, end here. */
                break;
            }
            if (d0 == (d0&1)) {
                /* d0 is defined. */
                res = d0 ^ ext ^ carry;
                carry = (d0&ext) | (d0&carry) | (ext&carry);
            } else {
                /* d0 is undefined. */
                break;
            }
        }
        ((char*)dst_data)[count] = res + '0';
    }
    /* The remaining bits are undefined. */
    for(;count < width0; ++count) {
        ((char*)dst_data)[count] = 'x';
    }
    /* Return the destination. */
    return dst;
}


/** Computes the subtraction of two bitstring values.
 *  @param src0 the first source value of the subtraction
 *  @param src1 the second source value of the subtraction
 *  @param dst the destination value
 *  @return dst */
static Value sub_value_bitstring(Value src0, Value src1, Value dst) {
    /* Get the size of the result from the sources. */
    unsigned long long size0 = src0->size;
    /* Compute the width of sources in bits. */
    unsigned long long width0 = type_width(src0->type);
    unsigned long long width1 = type_width(src1->type);

    /* Update the destination capacity if required. */
    resize_value(dst,size0);
    /* set the type and size of the destination the the type of the source. */
    dst->type = src0->type;
    dst->size = src0->size;
    dst->numeric = 0;

    /* Get access to the data of the sources. */
    unsigned int *src0_data = src0->data;
    unsigned int *src1_data = src1->data;
    /* Get access to the data of the destination. */
    unsigned int *dst_data = dst->data;

    /* Get the sign extension character of source 1 and convert it to a bit.*/
    int ext = src1->type->flags.sign ?  src1_data[width1-1] - '0' : 0;
    ext = !ext; /* For the subtraction: a + ~b + 1 */
    /* Perform the subtraction. */
    unsigned long long count;
    char carry = 1; /* For the subtraction: a + ~b + 1 */
    for(count = 0; count < width0; ++count) {
        /* Performs the subtraction. */
        char d0 = ((char*)src0_data)[count] - '0'; /* Get and convert to bit. */
        char res;
        if (count < width1) {
            char d1 = ((char*)src1_data)[count] - '0';/* Get and convert to bit. */
            if ((d0 == (d0&1)) && (d1 == (d1&1))) {
                d1 = !d1; /* For the subtraction: a + ~b + 1 */
                /* d0 and d1 are defined. */
                res = d0 ^ (d1) ^ carry;
                carry = (d0&d1) | (d0&carry) | (d1&carry);
            } else {
                /* Either input bit is undefined, end here. */
                break;
            }
        } else {
            /* All the bit of source 1 are used, go on using the sign
             * extension. */
            if (ext != (ext&1)) {
                /* The sign extension is undefined, end here. */
                break;
            }
            if (d0 == (d0&1)) {
                /* d0 is defined. */
                res = d0 ^ ext ^ carry;
                carry = (d0&ext) | (d0&carry) | (ext&carry);
            } else {
                /* d0 is undefined. */
                break;
            }
        }
        ((char*)dst_data)[count] = res + '0';
    }
    /* The remaining bits are undefined. */
    for(;count < width0; ++count) {
        ((char*)dst_data)[count] = 'x';
    }
    /* Return the destination. */
    return dst;
}


/** Computes the NOT of a bitstring value.
 *  @param src the source value of the not
 *  @param dst the destination value
 *  @return the destination value */
static Value not_value_bitstring(Value src, Value dst) {
    /* Get the size of the result from the sources. */
    unsigned long long size = src->size;
    /* Compute the width of the result in bits. */
    unsigned long long width = type_width(src->type);

    /* Update the destination capacity if required. */
    resize_value(dst,size);
    /* set the type and size of the destination the the type of the source. */
    dst->type = src->type;
    dst->size = src->size;
    dst->numeric = 0;

    /* Get access to the source and destination data. */
    char* src_data = (char*)(src->data);
    char* dst_data = (char*)(dst->data);

    /* Performs the not. */
    unsigned long long count;
    for(count = 0; count < width; ++count) {
        /* Performs the not. */
        char d = ((char*)src_data)[count] - '0'; /* Get and convert to bit. */
        char res;
        if (d == (d&1)) { /* d is defined. */
            res = !d;
        } else {
            /* res is undefined. */
            res = 'x' - '0';
        }
        ((char*)dst_data)[count] = res + '0';
    }
    /* Return the destination. */
    return dst;
}


/** Computes the and of two bitstring values.
 *  @param src0 the first source value of the and
 *  @param src1 the second source value of the and
 *  @param dst the destination value
 *  @return dst */
static Value and_value_bitstring(Value src0, Value src1, Value dst) {
    /* Get the size of the result from the sources. */
    unsigned long long size0 = src0->size;
    /* Compute the width of sources in bits. */
    unsigned long long width0 = type_width(src0->type);
    unsigned long long width1 = type_width(src1->type);

    /* Update the destination capacity if required. */
    resize_value(dst,size0);
    /* set the type and size of the destination the the type of the source. */
    dst->type = src0->type;
    dst->size = src0->size;
    dst->numeric = 0;

    /* Get access to the data of the sources. */
    unsigned int *src0_data = src0->data;
    unsigned int *src1_data = src1->data;
    /* Get access to the data of the destination. */
    unsigned int *dst_data = dst->data;

    /* Get the sign extension character of source 1 and convert it to a bit.*/
    int ext = src1->type->flags.sign ?  src1_data[width1-1] - '0' : 0;

    /* Perform the and. */
    unsigned long long count;
    for(count = 0; count < width0; ++count) {
        /* Performs the and. */
        char d0 = ((char*)src0_data)[count] - '0'; /* Get and convert to bit. */
        char res;
        char d1;
        if (count < width1) {
            /* Still within source 1. */
            d1 = ((char*)src1_data)[count] - '0';/* Get and convert to bit. */
        } else {
            /* Outside source 1, use the sign extension. */
            d1 = ext;
        }
        if (d0 == (d0&1)) {
            /* d0 is defined. */
            if (d1 == (d1&1)) {
                /* d1 is also defined. */
                res = d0 & d1;
            } else if (d0 == 0) {
                /* d1 is not defined but d0 is 0. */
                res = 0;
            } else {
                /* res is undefined. */
                res = 'x'-'0';
            }
        } else {
            /* d0 is undefined. */
            if (d1 == 0) {
                /* But d1 is 0. */
                res = 0;
            } else {
                /* res is undefined. */
                res = 'x'-'0';
            }
        }
        ((char*)dst_data)[count] = res + '0';
    }
    /* Return the destination. */
    return dst;
}


/** Computes the or of two bitstring values.
 *  @param src0 the first source value of the and
 *  @param src1 the second source value of the and
 *  @param dst the destination value
 *  @return dst */
static Value or_value_bitstring(Value src0, Value src1, Value dst) {
    /* Get the size of the result from the sources. */
    unsigned long long size0 = src0->size;
    /* Compute the width of sources in bits. */
    unsigned long long width0 = type_width(src0->type);
    unsigned long long width1 = type_width(src1->type);

    /* Update the destination capacity if required. */
    resize_value(dst,size0);
    /* set the type and size of the destination the the type of the source. */
    dst->type = src0->type;
    dst->size = src0->size;
    dst->numeric = 0;

    /* Get access to the data of the sources. */
    unsigned int *src0_data = src0->data;
    unsigned int *src1_data = src1->data;
    /* Get access to the data of the destination. */
    unsigned int *dst_data = dst->data;

    /* Get the sign extension character of source 1 and convert it to a bit.*/
    int ext = src1->type->flags.sign ?  src1_data[width1-1] - '0' : 0;

    /* Perform the or. */
    unsigned long long count;
    for(count = 0; count < width0; ++count) {
        /* Performs the or. */
        char d0 = ((char*)src0_data)[count] - '0'; /* Get and convert to bit. */
        char res;
        char d1;
        if (count < width1) {
            /* Still within source 1. */
            d1 = ((char*)src1_data)[count] - '0';/* Get and convert to bit. */
        } else {
            /* Outside source 1, use the sign extension. */
            d1 = ext;
        }
        if (d0 == (d0&1)) {
            /* d0 is defined. */
            if (d1 == (d1&1)) {
                /* d1 is also defined. */
                res = d0 | d1;
            } else if (d0 == 1) {
                /* d1 is not defined but d0 is 1. */
                res = 1;
            } else {
                /* res is undefined. */
                res = 'x'-'0';
            }
        } else {
            /* d0 is undefined. */
            if (d1 == 1) {
                /* But d1 is 1. */
                res = 1;
            } else {
                /* res is undefined. */
                res = 'x'-'0';
            }
        }
        ((char*)dst_data)[count] = res + '0';
    }
    /* Return the destination. */
    return dst;
}


/** Computes the xor of two bitstring values.
 *  @param src0 the first source value of the and
 *  @param src1 the second source value of the and
 *  @param dst the destination value
 *  @return dst */
static Value xor_value_bitstring(Value src0, Value src1, Value dst) {
    /* Get the size of the result from the sources. */
    unsigned long long size0 = src0->size;
    /* Compute the width of sources in bits. */
    unsigned long long width0 = type_width(src0->type);
    unsigned long long width1 = type_width(src1->type);

    /* Update the destination capacity if required. */
    resize_value(dst,size0);
    /* set the type and size of the destination the the type of the source. */
    dst->type = src0->type;
    dst->size = src0->size;
    dst->numeric = 0;

    /* Get access to the data of the sources. */
    unsigned int *src0_data = src0->data;
    unsigned int *src1_data = src1->data;
    /* Get access to the data of the destination. */
    unsigned int *dst_data = dst->data;

    /* Get the sign extension character of source 1 and convert it to a bit.*/
    int ext = src1->type->flags.sign ?  src1_data[width1-1] - '0' : 0;

    /* Perform the xor. */
    unsigned long long count;
    for(count = 0; count < width0; ++count) {
        /* Performs the xor. */
        char d0 = ((char*)src0_data)[count] - '0'; /* Get and convert to bit. */
        char res;
        char d1;
        if (count < width1) {
            /* Still within source 1. */
            d1 = ((char*)src1_data)[count] - '0';/* Get and convert to bit. */
        } else {
            /* Outside source 1, use the sign extension. */
            d1 = ext;
        }
        if (d0 == (d0&1)) {
            /* d0 is defined. */
            if (d1 == (d1&1)) {
                /* d1 is also defined. */
                res = d0 ^ d1;
            } else  {
                /* res is undefined. */
                res = 'x'-'0';
            }
        } else {
            /* res is undefined. */
            res = 'x'-'0';
        }
        ((char*)dst_data)[count] = res + '0';
    }
    /* Return the destination. */
    return dst;
}


/** Computes the equal (NXOR) of two bitstring values.
 *  @param src0 the first source value of the and
 *  @param src1 the second source value of the and
 *  @param dst the destination value
 *  @return dst */
static Value equal_value_bitstring(Value src0, Value src1, Value dst) {
    /* Get the size of the result from the sources. */
    unsigned long long size0 = src0->size;
    /* Compute the width of sources in bits. */
    unsigned long long width0 = type_width(src0->type);
    unsigned long long width1 = type_width(src1->type);

    /* Update the destination capacity if required. */
    resize_value(dst,size0);
    /* set the type and size of the destination the the type of the source. */
    dst->type = src0->type;
    dst->size = src0->size;
    dst->numeric = 0;

    /* Get access to the data of the sources. */
    unsigned int *src0_data = src0->data;
    unsigned int *src1_data = src1->data;
    /* Get access to the data of the destination. */
    unsigned int *dst_data = dst->data;

    /* Get the sign extension character of source 1 and convert it to a bit.*/
    int ext = src1->type->flags.sign ?  src1_data[width1-1] - '0' : 0;

    /* Perform the nxor. */
    unsigned long long count;
    for(count = 0; count < width0; ++count) {
        /* Performs the nxor. */
        char d0 = ((char*)src0_data)[count] - '0'; /* Get and convert to bit. */
        char res;
        char d1;
        if (count < width1) {
            /* Still within source 1. */
            d1 = ((char*)src1_data)[count] - '0';/* Get and convert to bit. */
        } else {
            /* Outside source 1, use the sign extension. */
            d1 = ext;
        }
        if (d0 == (d0&1)) {
            /* d0 is defined. */
            if (d1 == (d1&1)) {
                /* d1 is also defined. */
                res = (d0 == d1);
            } else  {
                /* res is undefined. */
                res = 'x'-'0';
            }
        } else {
            /* res is undefined. */
            res = 'x'-'0';
        }
        ((char*)dst_data)[count] = res + '0';
    }
    /* Return the destination. */
    return dst;
}


/** Selects a value depending on a bitstring condition.
 *  @param cond   the condition to use for selecting a value
 *  @param dst    the destination value (used only if new value is created).
 *  @param num    the number of values for the selection
 *  @return the selected value */
static Value select_value_bitstring(Value cond, Value dst, unsigned int num,
        va_list args) 
{
    /* Get the first alternative for sizing the result. */
    Value src = va_arg(args,Value);
    /* Get the size of the result from the sources. */
    unsigned long long size = src->size;
    /* Compute the width of the result in bits. */
    unsigned long long width = type_width(src->type);

    /* Update the destination capacity if required. */
    resize_value(dst,size);
    /* set the type and size of the destination the the type of the source. */
    dst->type = src->type;
    dst->size = src->size;
    dst->numeric = 0;
    unsigned int *dst_data = dst->data;

    /* Sets the destination as undefined. */
    unsigned long long count;
    for(count = 0; count < width; ++count) {
        dst_data[count] = 'x';
    }
    /* Return the destination. */
    return dst;
}


/** Concat multiple bitstring values to a single one.
 *  @param num the number of values to concat
 *  @param dst the destination value
 *  @param args the values to concat
 *  @return dst */
static Value concat_value_bitstring_array(int num, Value dst, Value* args) {
    unsigned long long pos = 0;  /* Current position in the resulting value.*/
    unsigned long long i;

    /* Compute the size of the destination. */
    unsigned long long size = 0;
    for(i=0; i<num; ++i) {
        size += args[i]->size;
    }
    /* Resize the destination accordignly. */
    resize_value(dst,size);

    /* Access the data of the destination. */
    char* dst_data = (char*)(dst->data);

    /* Fills the destination with each value. */
    for(i=0; i<num; ++i) {
        Value value = args[i];
        unsigned long long cw = type_width(value->type);
        memcpy(dst_data+pos,value->data,cw);
        // write_range(value,pos,pos+cw,accumulator);
        write_range(value,pos,pos+cw,dst);
        pos += cw;
    }
    // /* Sets the type of the resulting value: it is necesserily an
    //  * unsigned bit string. */
    // accumulator->type = get_type_vector(get_type_bit(),width);
    /* Sets the type of the resulting value: it is necesserily an
     * unsigned bit string. */
    dst->type = get_type_vector(get_type_bit(),pos);
    // /* Return the accumulator as result. */
    // return accumulator;
    /* Return the destination value. */
    return dst;
}


/** Testing if two bitstring values have the same content (the type is not checked).
 *  @param value0 the first value to compare
 *  @param value1 the second value to compare
 *  @return 1 if same content. */
static unsigned int same_content_value_bitstring(Value value0, Value value1) {
    unsigned long long i;
    unsigned long long width = type_width(value0->type);
    /* Compare the sizes. */
    if (type_width(value1->type) != width) return 0;
    /* Compare the data. */
    char* data0 = (char*)(value0->data);
    char* data1 = (char*)(value1->data);
    for(i=0; i<width; ++i) {
        if (data0[i] != data1[i])
            /* The contents are different. */
            return 0;
    }
    /* The values have the same content. */
    return 1;
}


/** Testing if two bitstring values have the same content (the type is not checked).
 *  @param value0 the first value to compare
 *  @param first the first index of the range
 *  @param last the last index of the range
 *  @param value1 the second value to compare
 *  @return 1 if same content. */
static int same_content_value_range_bitstring(Value value0,
        unsigned long long first, unsigned long long last, Value value1) {
    unsigned long long i;
    unsigned long long width0 = type_width(value0->type);
    unsigned long long width1 = type_width(value1->type);
    /* Get access to the data of both values. */
    char* data0 = (char*)(value0->data);
    char* data1 = (char*)(value1->data);
    /* Compare within the range. */
    for(i=first; i<=last; ++i) {
        if (i>=width0) {
            if (i>=width1) {
                /* Both values are out of range. */
                return 1;
            } else {
                /* Only value 0 is out of range. */
                return 0;
            }
        } else if (i>width1) {
            /* Only value 1 is out of range. */
            return 0;
        } else {
            if (data0[i] != data1[i])  {
                /* Values are different within the range. */
                return 0;
            }
        }
    }
    /* Values are identical in the range. */
    return 1;
}



/* ############# End of the computation of bitstring values. ############## */

/* ############# Start of the computation of numeric values. ############## */


/** Computes the neg of a numeric value. // and put the result in the accumulator.
 *  @param src the source value of the not
// *  @return the accumulator 
 *  @param dst the destination value
 *  @return dst */
// Value neg_value(Value src) {
static Value neg_value_numeric(Value src, Value dst) {
    /* Get the size of the result from the source. */
    unsigned long long size = src->size;

    // /* Update the accumulator capacity if required. */
    // resize_value(accumulator,size);
    /* Update the destination capacity if required. */
    resize_value(dst,size);
    // /* set the type and size of the accumulator the the type of the source. */
    // accumulator->type = src->type;
    // accumulator->size = src->size;
    // accumulator->numeric = src->numeric;
    /* set the type and size of the destination the the type of the source. */
    dst->type = src->type;
    dst->size = src->size;
    dst->numeric = src->numeric;

    /* Get access to the data of the source. */
    unsigned int *src_data = src->data;
    /* Get access to the data of the destination. */
    // unsigned int *dst_data = accumulator->data;
    unsigned int *dst_data = dst->data;

    /* Perform the word-wise negation. */
    unsigned long long count;
    unsigned int carry = 0;
    for(count = 0; count < size; ++count) {
        /* Performs the negation, double size for the carry. */
        unsigned long long d = src_data[count];
        unsigned long long res = - d + (1-carry);
        /* Compute the next carry. */
        carry = res >> (INT_BIT);
        /* Set the data of the accumulator. */
        dst_data[count] = res;
    }
    // /* Return the accumulator as result. */
    // return accumulator;
    /* Return the destination. */
    return dst;
}


/** Computes the addition of two numeric values. // and put the result in the accumulator.
 *  @param src0 the first source value of the addition
 *  @param src1 the second source value of the addition
// *  @return the accumulator
 *  @param dst the destination value
 *  @return dst */
// Value add_value(Value src0, Value src1) {
static Value add_value_numeric(Value src0, Value src1, Value dst) {
    /* Get the sizes of the sources. */
    unsigned long long src0_size = src0->size;
    unsigned long long src1_size = src1->size;

    // /* Update the accumulator capacity if required. */
    // resize_value(accumulator,src0_size);
    /* Update the destination capacity if required. */
    resize_value(dst,src0_size);
    // /* set the type and size of the accumulator to the type first source. */
    // accumulator->type = src0->type;
    // accumulator->size = src0_size;
    // accumulator->numeric = src0->numeric;
    /* set the type and size of the destination to the type first source. */
    dst->type = src0->type;
    dst->size = src0_size;
    dst->numeric = src0->numeric;

    /* Get access to the data of each source. */
    unsigned int *src0_data = src0->data;
    unsigned int *src1_data = src1->data;
    // /* Get access to the data of the accumulator. */
    // unsigned int *dst_data = accumulator->data;
    /* Get access to the data of the destination. */
    unsigned int *dst_data = dst->data;

    /* Perform the word-wise addition. */
    unsigned long long count;
    unsigned int carry = 0;
    unsigned long long ext = word_extL(src1);
    for(count = 0; count < src0_size; ++count) {
        /* Performs the addition, double size for the carry. */
        unsigned long long d0 = src0_data[count];
        unsigned long long d1 = count <= src1_size ? src1_data[count] : ext;
        unsigned long long res = d0 + d1 + carry;
        /* Compute the next carry. */
        carry = res >> (INT_BIT);
        /* Set the data of the destination. */
        dst_data[count] = res;
    }
    // /* Return the accumulator. */
    // return accumulator;
    /* Return the destination value. */
    return dst;
}


/** Computes the subtrasction of two numeric values.// and put the result in the accumulator.
 *  @param src0 the first source value of the addition
 *  @param src1 the second source value of the addition
 // *  @return the accumulator
 *  @param dst the destination value
 *  @return dst */
// Value sub_value(Value src0, Value src1) {
static Value sub_value_numeric(Value src0, Value src1, Value dst) {
    /* Get the sizes of the sources. */
    unsigned long long src0_size = src0->size;
    unsigned long long src1_size = src1->size;

    // /* Update the accumulator capacity if required. */
    // resize_value(accumulator,src0_size);
    /* Update the destination capacity if required. */
    resize_value(dst,src0_size);
    // /* set the type and size of the accumulator to the type first source. */
    // accumulator->type = src0->type;
    // accumulator->size = src0_size;
    // accumulator->numeric = src0->numeric;
    /* set the type and size of the accumulator to the type first source. */
    dst->type = src0->type;
    dst->size = src0_size;
    dst->numeric = src0->numeric;

    /* Get access to the data of each source. */
    unsigned int *src0_data = src0->data;
    unsigned int *src1_data = src1->data;
    // /* Get access to the data of the accumulator. */
    // unsigned int *dst_data = accumulator->data;
    /* Get access to the data of the accumulator. */
    unsigned int *dst_data = dst->data;

    /* Perform the word-wise subtraction. */
    unsigned long long count;
    unsigned int carry = 0;
    unsigned long long ext = word_extL(src1);
    for(count = 0; count < src0_size; ++count) {
        /* Performs the subtraction, double size for the carry. */
        unsigned long long d0 = src0_data[count];
        unsigned long long d1 = count <= src1_size ? src1_data[count] : ext;
        unsigned long long res = d0 - d1 + (1-carry);
        /* Compute the next carry. */
        carry = res >> (INT_BIT);
        /* Set the data of the destination. */
        dst_data[count] = res;
    }
    // /* Return the accumulator. */
    // return accumulator;
    /* Return the destination value. */
    return dst;
}


/** Computes the NOT of a numeric value.// and put the result in the accumulator.
 *  @param src the source value of the not
 // *  @return the accumulator
 *  @param dst the destination value
 *  @return the destination value */
// Value not_value(Value src) {
static Value not_value_numeric(Value src, Value dst) {
    /* Get the size of the result from the source. */
    unsigned long long size = src->size;

    // /* Update the accumulator capacity if required. */
    // resize_value(accumulator,size);
    /* Update the destination capacity if required. */
    resize_value(dst,size);
    // /* set the type and size of the accumulator the the type of the source. */
    // accumulator->type = src->type;
    // accumulator->size = src->size;
    // accumulator->numeric = src->numeric;
    /* set the type and size of the destination the the type of the source. */
    dst->type = src->type;
    dst->size = src->size;
    dst->numeric = src->numeric;

    /* Get access to the data of the source. */
    unsigned int *src_data = src->data;
    // /* Get access to the data of the destination. */
    // unsigned int *dst_data = accumulator->data;
    /* Get access to the data of the destination. */
    unsigned int *dst_data = dst->data;

    /* Perform the word-wise NOT. */
    unsigned long long count;
    for(count = 0; count < size; ++count) {
        /* Performs the subtraction, double size for the carry. */
        unsigned long long d = src_data[count];
        unsigned long long res = ~d;
        /* Set the data of the accumulator. */
        dst_data[count] = res;
    }
    // /* Return the accumulator as result. */
    // return accumulator;
    /* Return the destination value. */
    return dst;
}


/** Computes the AND of two numeric values.// and put the result in the accumulator.
 *  @param src0 the first source value of the addition
 *  @param src1 the second source value of the addition
 // *  @return the accumulator
 *  @param dst the destination value
 *  @return dst */
// Value and_value(Value src0, Value src1) {
static Value and_value_numeric(Value src0, Value src1, Value dst) {
    /* Get the sizes of the sources. */
    unsigned long long src0_size = src0->size;
    unsigned long long src1_size = src1->size;

    // /* Update the accumulator capacity if required. */
    // resize_value(accumulator,src0_size);
    /* Update the destination capacity if required. */
    resize_value(dst,src0_size);
    // /* set the type and size of the accumulator to the type first source. */
    // accumulator->type = src0->type;
    // accumulator->size = src0_size;
    // accumulator->numeric = src0->numeric;
    /* set the type and size of the destination to the type first source. */
    dst->type = src0->type;
    dst->size = src0_size;
    dst->numeric = src0->numeric;

    /* Get access to the data of each source. */
    unsigned int *src0_data = src0->data;
    unsigned int *src1_data = src1->data;
    // /* Get access to the data of the accumulator. */
    // unsigned int *dst_data = accumulator->data;
    /* Get access to the data of the destination. */
    unsigned int *dst_data = dst->data;

    /* Perform the word-wise AND. */
    unsigned long long count;
    unsigned int ext = word_ext(src1);
    for(count = 0; count < src0_size; ++count) {
        /* Performs the AND, double size for the carry. */
        unsigned int d0 = src0_data[count];
        unsigned int d1 = count <= src1_size ? src1_data[count] : ext;
        unsigned int res = d0 & d1;
        /* Set the data of the destination. */
        dst_data[count] = res;
    }
    // /* Return the accumulator. */
    // return accumulator;
    /* Return the destination value. */
    return dst;
}


/** Computes the OR of two numeric values.// and put the result in the accumulator.
 *  @param src0 the first source value of the addition
 *  @param src1 the second source value of the addition
 // *  @return the accumulator
 *  @param dst the destination
 *  @return dst */
// Value or_value(Value src0, Value src1) {
static Value or_value_numeric(Value src0, Value src1, Value dst) {
    /* Get the sizes of the sources. */
    unsigned long long src0_size = src0->size;
    unsigned long long src1_size = src1->size;

    // /* Update the accumulator capacity if required. */
    // resize_value(accumulator,src0_size);
    /* Update the destination capacity if required. */
    resize_value(dst,src0_size);
    // /* set the type and size of the accumulator to the type first source. */
    // accumulator->type = src0->type;
    // accumulator->size = src0_size;
    // accumulator->numeric = src0->numeric;
    /* set the type and size of the destination to the type first source. */
    dst->type = src0->type;
    dst->size = src0_size;
    dst->numeric = src0->numeric;

    /* Get access to the data of each source. */
    unsigned int *src0_data = src0->data;
    unsigned int *src1_data = src1->data;
    // /* Get access to the data of the accumulator. */
    // unsigned int *dst_data = accumulator->data;
    /* Get access to the data of the destination. */
    unsigned int *dst_data = dst->data;

    /* Perform the word-wise OR. */
    unsigned long long count;
    unsigned int ext = word_ext(src1);
    for(count = 0; count < src0_size; ++count) {
        /* Performs the OR, double size for the carry. */
        unsigned int d0 = src0_data[count];
        unsigned int d1 = count <= src1_size ? src1_data[count] : ext;
        unsigned int res = d0 | d1;
        /* Set the data of the destination. */
        dst_data[count] = res;
    }
    // /* Return the accumulator. */
    // return accumulator;
    /* Return the destination value. */
    return dst;
}


/** Computes the XOR of two numeric values.// and put the result in the accumulator.
 *  @param src0 the first source value of the addition
 *  @param src1 the second source value of the addition
 // *  @return the accumulator
 *  @param dst the destination
 *  @return dst */
// Value xor_value(Value src0, Value src1) {
static Value xor_value_numeric(Value src0, Value src1, Value dst) {
    /* Get the sizes of the sources. */
    unsigned long long src0_size = src0->size;
    unsigned long long src1_size = src1->size;

    // /* Update the accumulator capacity if required. */
    // resize_value(accumulator,src0_size);
    /* Update the destination capacity if required. */
    resize_value(dst,src0_size);
    // /* set the type and size of the accumulator to the type first source. */
    // accumulator->type = src0->type;
    // accumulator->size = src0_size;
    // accumulator->numeric = src0->numeric;
    /* set the type and size of the destination to the type first source. */
    dst->type = src0->type;
    dst->size = src0_size;
    dst->numeric = src0->numeric;

    /* Get access to the data of each source. */
    unsigned int *src0_data = src0->data;
    unsigned int *src1_data = src1->data;
    // /* Get access to the data of the accumulator. */
    // unsigned int *dst_data = accumulator->data;
    /* Get access to the data of the destination. */
    unsigned int *dst_data = dst->data;

    /* Perform the word-wise XOR. */
    unsigned long long count;
    unsigned int ext = word_ext(src1);
    for(count = 0; count < src0_size; ++count) {
        /* Performs the OR, double size for the carry. */
        unsigned int d0 = src0_data[count];
        unsigned int d1 = count <= src1_size ? src1_data[count] : ext;
        unsigned int res = d0 ^ d1;
        /* Set the data of the destination. */
        dst_data[count] = res;
    }
    // /* Return the accumulator. */
    // return accumulator;
    /* Return the destination value. */
    return dst;
}


/** Computes the equal (NXOR) of two numeric values.// and put the result in the  accumulator.
 *  @param src0 the first source value of the addition
 *  @param src1 the second source value of the addition
 // *  @return the accumulator
 *  @param dst the destination value
 *  @return the destination value */
// Value equal_value(Value src0, Value src1) {
static Value equal_value_numeric(Value src0, Value src1, Value dst) {
    /* Get the sizes of the sources. */
    unsigned long long src0_size = src0->size;
    unsigned long long src1_size = src1->size;

    // /* Update the accumulator capacity if required. */
    // resize_value(accumulator,src0_size);
    /* Update the destination capacity if required. */
    resize_value(dst,src0_size);
    // /* set the type and size of the accumulator to the type first source. */
    // accumulator->type = src0->type;
    // accumulator->size = src0_size;
    // accumulator->numeric = src0->numeric;
    /* set the type and size of the destination to the type first source. */
    dst->type = src0->type;
    dst->size = src0_size;
    dst->numeric = src0->numeric;

    /* Get access to the data of each source. */
    unsigned int *src0_data = src0->data;
    unsigned int *src1_data = src1->data;
    // /* Get access to the data of the accumulator. */
    // unsigned int *dst_data = accumulator->data;
    /* Get access to the data of the destination. */
    unsigned int *dst_data = dst->data;

    /* Perform the word-wise XOR. */
    unsigned long long count;
    unsigned int ext = word_ext(src1);
    for(count = 0; count < src0_size; ++count) {
        /* Performs the OR, double size for the carry. */
        unsigned int d0 = src0_data[count];
        unsigned int d1 = count <= src1_size ? src1_data[count] : ext;
        unsigned int res = ~(d0 ^ d1);
        /* Set the data of the destination. */
        dst_data[count] = res;
    }
    // /* Return the accumulator. */
    // return accumulator;
    /* Return the destination value. */
    return dst;
}


/** Selects a value depending on a numeric condition.
 *  @param cond   the condition to use for selecting a value
 *  @param dst    the destination value (used only if new value is created).
 *  @param num    the number of values for the selection
 *  @return the selected value */
static Value select_value_numeric(Value cond, Value dst, unsigned int num, va_list args) {
    int cond_i = read32(cond);
    int i;
    Value selected;

    for(i=0;i <= cond_i; ++i) {
        selected = va_arg(args,Value);
    }
    return selected;
}

/** Concat multiple numeric values to a single one.// in the accumulator.
 *  @param num the number of values to concat
 // *  @return the accumulator.
 *  @param dst the destination value
 *  @return dst */
// Value concat_value(int num, ...) {
static Value concat_value_numeric(int num, Value dst, va_list args) {
    unsigned long long pos = 0;  /* Current position in the resulting value.*/
    unsigned long long i;
    // va_list args;
    /* Compute the size of the destination. */
    unsigned long long size = 0;
    va_list args0;
    va_copy(args0,args);
    for(i=0; i<num; ++i) {
        size += va_arg(args0,Value)->size;
    }
    /* Resize the destination accordignly. */
    resize_value(dst,size);

    /* Fills the destination with each value. */
    for(i=0; i<num; ++i) {
        Value value = va_arg(args,Value);
        unsigned long long cw = type_width(value->type);
        // write_range(value,pos,pos+cw,accumulator);
        write_range(value,pos,pos+cw,dst);
        pos += cw;
    }
    // /* Sets the type of the resulting value: it is necesserily an
    //  * unsigned bit string. */
    // accumulator->type = get_type_vector(get_type_bit(),width);
    /* Sets the type of the resulting value: it is necesserily an
     * unsigned bit string. */
    dst->type = get_type_vector(get_type_bit(),pos);
    // /* Return the accumulator as result. */
    // return accumulator;
    /* Return the destination value. */
    return dst;
}


/** Testing if a numeric value is 0.
 *  @param value the value to check 
 *  @return 1 if 0 and 0 otherwize */
static int zero_value_numeric(Value value) {
    unsigned long long i;
    unsigned long long size = value->size;
    
    for(i=0; i<size; ++i) {
        if (value->data[i] != 0)
            /* The value is not 0. */
            return 0;
    }
    /* The value is 0. */
    return 1;
}


/** Testing if two numeric values have the same content (the type is not checked).
 *  @param value0 the first value to compare
 *  @param value1 the second value to compare
 *  @return 1 if same content. */
static unsigned int same_content_value_numeric(Value value0, Value value1) {
    unsigned long long i;
    unsigned long long size = value0->size;
    /* Compare the sizes. */
    if (value1->size != size) return 0;
    /* Compare the data. */
    unsigned int* data0 = value0->data;
    unsigned int* data1 = value1->data;
    for(i=0; i<size; ++i) {
        if (data0[i] != data1[i])
            /* The contents are different. */
            return 0;
    }
    /* The values have the same content. */
    return 1;
}


/** Testing if two numeric values have the same content (the type is not checked).
 *  @param value0 the first value to compare
 *  @param first the first index of the range
 *  @param last the last index of the range
 *  @param value1 the second value to compare
 *  @return 1 if same content. */
static int same_content_value_range_numeric(Value value0,
        unsigned long long first, unsigned long long last, Value value1) {
    unsigned long long i;
    /* Get the types. */
    Type typ0 = value0->type;
    Type typ1 = value1->type;
    /* Get the base width. */
    unsigned long long bw = typ0->base;
    /* Compute the word shift. */
    // unsigned int ws = (first*bw) / INT_BIT;
    /* Compute the bit shift. */
    // unsigned int bs = (first*bw) % INT_BIT;
    /* Compute the higher bits clearing mask for the destination. */
    // unsigned int dst_mask_high = ~((1UL << bs) - 1UL);
    /* Compute the lower bits clearing mask for the destination. */
    // unsigned int dst_mask_low = ~dst_mask_high;
    // /* Compute the lower bits selection mask for the source. */
    // unsigned int src_mask_low = dst_mask_high;
    /* Compute the higher bits selection mask for the source. */
    // unsigned int src_mask_high = dst_mask_low;
    /* Get the number of elements. */
    unsigned long long num0 = typ0->number;
    unsigned long long num1 = typ1->number;
    /* Check if the elements are compatible. */
    if (value1->type->base != bw) {
        /* Not compatible. */
        return 0;
    }
    /* Check if the range is valid. */
    if (last >= num0 || last >= num1) {
        /* Invalid range. */
        return 0;
    }

    /* Access the data. */
    unsigned int* data0 = value0->data;
    /* Access the data. */
    unsigned int* data1 = value1->data;

    /* Perform the comparison. */
    for(i=first; i<last; ++i) {
        /* Access the elements to compare. */
        unsigned long long idx_low = i/INT_BIT;
        unsigned long long idx_high = (i+bw)/INT_BIT;
        unsigned int mask_low = ~((1 << (i%INT_BIT)) - 1);
        unsigned int mask_high = ((1 << ((i+bw)%INT_BIT)) -1);
        if (idx_low == idx_high) {
            /* Inside a data. */
            unsigned int mask = mask_low & mask_high;
            /* Compare. */
            if ((data0[idx_low] & mask) != (data1[idx_low] & mask)) {
                /* Different. */
                return 0;
            }
        } else {
            /* Between two data. */
            /* Compare. */
            if ((data0[idx_low] & mask_low) != (data1[idx_low] & mask_low)) {
                /* Different. */
                return 0;
            }
            if ((data0[idx_high] & mask_high) != (data1[idx_high] & mask_high)) {
                /* Different. */
                return 0;
            }
        }
    }
    /* Identical. */
    return 1;
}

/* ############# End of the computation of numeric values. ################ */

/* ############# Start of the computation of general values. ################ */


/** Computes the neg of a general value.
 *  @param src the source value of the not
 *  @param dst the destination value
 *  @return dst */
Value neg_value(Value src, Value dst) {
    if (src->numeric) {
        /* The source is numeric. */
        return neg_value_numeric(src,dst);
    } else {
        /* The source cannot be numeric, compute bitsitrings. */
        return neg_value_bitstring(src,dst);
    }
}


/** Computes the addition of two general values.
 *  @param src0 the first source value of the addition
 *  @param src1 the second source value of the addition
 *  @param dst the destination value
 *  @return dst */
Value add_value(Value src0, Value src1, Value dst) {
    /* Might allocate a new value so save the current pool state. */
    unsigned int pos = get_value_pos();
    /* Do a numeric computation if possible, otherwise fallback to bitstring
     * computation. */
    if (src0->numeric) {
        if (src1->numeric) {
            /* Both sources are numeric. */
            return add_value_numeric(src0,src1,dst);
        } else {
            /* src1 is not numeric, convert src0 to bitstring. */
            src0 = set_bitstring_value(src0,get_value());
        }
    } else {
        /* src0 is not numeric, what about src1. */
        if (src1->numeric) {
            /* src0 is numeric, convert it to bitstring. */
            src1 = set_bitstring_value(src1,get_value());
        }
    }
    /* The sources cannot be numeric, compute bitsitrings. */
    dst = add_value_bitstring(src0,src1,dst);
    /* Restores the pool of values. */
    set_value_pos(pos);
    /* Return the destination. */
    return dst;
}


/** Computes the subtrasction of two general values.
 *  @param src0 the first source value of the addition
 *  @param src1 the second source value of the addition
 *  @param dst the destination value
 *  @return dst */
Value sub_value(Value src0, Value src1, Value dst) {
    /* Might allocate a new value so save the current pool state. */
    unsigned int pos = get_value_pos();
    /* Do a numeric computation if possible, otherwise fallback to bitstring
     * computation. */
    if (src0->numeric) {
        if (src1->numeric) {
            /* Both sources are numeric. */
            return sub_value_numeric(src0,src1,dst);
        } else {
            /* src1 is not numeric, convert src0 to bitstring. */
            src0 = set_bitstring_value(src0,get_value());
        }
    } else {
        /* src0 is not numeric, what about src1. */
        if (src1->numeric) {
            /* src0 is numeric, convert it to bitstring. */
            src1 = set_bitstring_value(src1,get_value());
        }
    }
    /* The sources cannot be numeric, compute bitsitrings. */
    dst = sub_value_bitstring(src0,src1,dst);
    /* Restores the pool of values. */
    set_value_pos(pos);
    /* Return the destination. */
    return dst;
}


/** Computes the NOT of a general value.
 *  @param src the source value of the not
 *  @param dst the destination value
 *  @return the destination value */
Value not_value(Value src, Value dst) {
    if (src->numeric) {
        /* The source is numeric. */
        return not_value_numeric(src,dst);
    } else {
        /* The source cannot be numeric, compute bitsitrings. */
        return not_value_bitstring(src,dst);
    }
}


/** Computes the AND of two general values. 
 *  @param src0 the first source value of the addition
 *  @param src1 the second source value of the addition
 *  @param dst the destination value
 *  @return dst */
Value and_value(Value src0, Value src1, Value dst) {
    /* Might allocate a new value so save the current pool state. */
    unsigned int pos = get_value_pos();
    /* Do a numeric computation if possible, otherwise fallback to bitstring
     * computation. */
    if (src0->numeric) {
        if (src1->numeric) {
            /* Both sources are numeric. */
            return and_value_numeric(src0,src1,dst);
        } else {
            /* src1 is not numeric, convert src0 to bitstring. */
            src0 = set_bitstring_value(src0,get_value());
        }
    } else {
        /* src0 is not numeric, what about src1. */
        if (src1->numeric) {
            /* src0 is numeric, convert it to bitstring. */
            src1 = set_bitstring_value(src1,get_value());
        }
    }
    /* The sources cannot be numeric, compute bitsitrings. */
    dst = and_value_bitstring(src0,src1,dst);
    /* Restores the pool of values. */
    set_value_pos(pos);
    /* Return the destination. */
    return dst;
}


/** Computes the OR of two general values.
 *  @param src0 the first source value of the addition
 *  @param src1 the second source value of the addition
 *  @param dst the destination
 *  @return dst */
Value or_value(Value src0, Value src1, Value dst) {
    /* Might allocate a new value so save the current pool state. */
    unsigned int pos = get_value_pos();
    /* Do a numeric computation if possible, otherwise fallback to bitstring
     * computation. */
    if (src0->numeric) {
        if (src1->numeric) {
            /* Both sources are numeric. */
            return or_value_numeric(src0,src1,dst);
        } else {
            /* src1 is not numeric, convert src0 to bitstring. */
            src0 = set_bitstring_value(src0,get_value());
        }
    } else {
        /* src0 is not numeric, what about src1. */
        if (src1->numeric) {
            /* src0 is numeric, convert it to bitstring. */
            src1 = set_bitstring_value(src1,get_value());
        }
    }
    /* The sources cannot be numeric, compute bitsitrings. */
    dst = or_value_bitstring(src0,src1,dst);
    /* Restores the pool of values. */
    set_value_pos(pos);
    /* Return the destination. */
    return dst;
}


/** Computes the XOR of two general values.
 *  @param src0 the first source value of the addition
 *  @param src1 the second source value of the addition
 *  @param dst the destination
 *  @return dst */
Value xor_value(Value src0, Value src1, Value dst) {
    /* Might allocate a new value so save the current pool state. */
    unsigned int pos = get_value_pos();
    /* Do a numeric computation if possible, otherwise fallback to bitstring
     * computation. */
    if (src0->numeric) {
        if (src1->numeric) {
            /* Both sources are numeric. */
            return xor_value_numeric(src0,src1,dst);
        } else {
            /* src1 is not numeric, convert src0 to bitstring. */
            src0 = set_bitstring_value(src0,get_value());
        }
    } else {
        /* src0 is not numeric, what about src1. */
        if (src1->numeric) {
            /* src0 is numeric, convert it to bitstring. */
            src1 = set_bitstring_value(src1,get_value());
        }
    }
    /* The sources cannot be numeric, compute bitsitrings. */
    dst = xor_value_bitstring(src0,src1,dst);
    /* Restores the pool of values. */
    set_value_pos(pos);
    /* Return the destination. */
    return dst;
}


/** Computes the equal (NXOR) of two general values.
 *  @param src0 the first source value of the addition
 *  @param src1 the second source value of the addition
 *  @param dst the destination value
 *  @return the destination value */
Value equal_value(Value src0, Value src1, Value dst) {
    /* Might allocate a new value so save the current pool state. */
    unsigned int pos = get_value_pos();
    /* Do a numeric computation if possible, otherwise fallback to bitstring
     * computation. */
    if (src0->numeric) {
        if (src1->numeric) {
            /* Both sources are numeric. */
            return equal_value_numeric(src0,src1,dst);
        } else {
            /* src1 is not numeric, convert src0 to bitstring. */
            src0 = set_bitstring_value(src0,get_value());
        }
    } else {
        /* src0 is not numeric, what about src1. */
        if (src1->numeric) {
            /* src0 is numeric, convert it to bitstring. */
            src1 = set_bitstring_value(src1,get_value());
        }
    }
    /* The sources cannot be numeric, compute bitsitrings. */
    dst = equal_value_bitstring(src0,src1,dst);
    /* Restores the pool of values. */
    set_value_pos(pos);
    /* Return the destination. */
    return dst;
}


/** Selects a value depending on a general condition.
 *  @param cond   the condition to use for selecting a value
 *  @param dst    the destination value (used only if new value is created).
 *  @param num    the number of values for the selection
 *  @return the selected value */
Value select_value(Value cond, Value dst, unsigned int num, ...) {
    va_list args;
    va_start(args,num);
    if (set_numeric_value(cond)) {
        /* The condition is now numeric. */
        dst = select_value_numeric(cond,dst,num,args);
    } else {
        /* The sources cannot be numeric, compute bitsitrings. */
        dst = select_value_bitstring(cond,dst,num,args);
    }
    va_end(args);
    return dst;
}

/** Concat multiple general values to a single one.
 *  @param num the number of values to concat
 *  @param dst the destination value
 *  @return dst */
Value concat_value(int num, Value dst, ...) {
    /* Might allocate new values so save the state of the value pool. */
    int numeric = 1, i;
    va_list args;
    va_list args1;
    Value* bvalues = NULL; /* The values converted to bitstring if required. */
    va_start(args,dst);
    va_copy(args1,args);
    /* check if all the sub values are numeric. */
    for(i=0; i<num; ++i) {
        if (!va_arg(args,Value)->numeric) {
            numeric = 0;
            break;
        }
    }
    /* Reinitialize the access to the variadic arguments for further
     * accesses. */
    if (numeric) {
        /* The sub values are all numeric. */
        concat_value_numeric(num,dst,args1);
    } else {
        /* Some sub values are not numeric, convert the numeric ones to
         * bitstring and perform a bitstring concatenation. */
        bvalues = alloca(sizeof(Value)*num);
        va_copy(args1,args);
        for(i=0;i<num; ++i) {
            Value value = va_arg(args1,Value);
            if (value->numeric) {
                bvalues[i] = set_bitstring_value(value,get_value());
            } else {
                bvalues[i] = value;
            }
        }

        /* The sub values are now all bitstrings. */
        concat_value_bitstring_array(num,dst,bvalues);
    }
    va_end(args);
    return dst;
}


/** Testing if a general value is 0.
 *  @param value the value to check 
 *  @return 1 if 0 and 0 otherwize */
int zero_value(Value value) {
    if (value->numeric) {
        /* The value is numeric. */
        return zero_value_numeric(value);
    } else {
        /* The value cannot be reduced to numeric: cannot be 0. */
        return 0;
    }
}


/** Testing if two general values have the same content (the type is not checked).
 *  @param value0 the first value to compare
 *  @param value1 the second value to compare
 *  @return 1 if same content. */
int same_content_value(Value value0, Value value1) {
    if (value0->numeric) {
        if (value1->numeric) {
            /* Both values are numeric. */
            return same_content_value_numeric(value0,value1);
        } else {
            /* One value is numeric, the othert is not, different. */
            return 0;
        }
    } else if (value1->numeric) {
        /* One value is numeric, the othert is not, different. */
        return 0;
    } else {
        /* Both values are bitstring. */
        return same_content_value_bitstring(value0,value1);
    }
}


/** Testing if two general values have the same content (the type is not checked).
 *  @param value0 the first value to compare
 *  @param first the first index of the range
 *  @param last the last index of the range
 *  @param value1 the second value to compare
 *  @return 1 if same content. */
int same_content_value_range(Value value0,
        unsigned long long first, unsigned long long last, Value value1) {
    if (value0->numeric) {
        if (value1->numeric) {
            /* Both values are numeric. */
            return same_content_value_range_numeric(value0,first,last,value1);
        } else {
            /* One value is numeric the other is not, different. */
            return 0;
        }
    } else if (value1->numeric) {
        /* One value is numeric, the other is not, different. */
        return 0;
    } else {
        /* Both values are bitstring. */
        return same_content_value_range_bitstring(value0,first,last,value1);
    }
}


/* ############# End of the computation of general values.   ################ */





/** Creates a reference to a range inside a signal.
 *  @param signal the signal to refer
 *  @param first the start index of the range
 *  @param last the end index of the range
 *  @return the resulting reference */
RefRangeS make_ref_rangeS(SignalI signal, unsigned long long first,
        unsigned long long last) {
    RefRangeS result = { signal, first, last };
    return result;
}






/* Access and conversion functions. */

/** Read and convert to 8-bit a value.
 *  @param value the value to read
 *  @return the resulting 8-bit value */
char read8(Value value) {
    return value->data[0] & 0xFF;
}

/** Read and convert to 16-bit a value.
 *  @param value the value to read
 *  @return the resulting 16-bit value */
short read16(Value value) {
    return value->data[0] & 0xFFFF;
}

/** Read and convert to 32-bit a value.
 *  @param value the value to read 
 *  @return the resulting 32-bit value */
int read32(Value value) {
    return value->data[0] & 0xFFFFFFFF;
}

/** Read and convert to 64-bit a value.
 *  @param value the value to read 
 *  @return the resulting 64-bit value */
long long read64(Value value) {
    return value->data[0];
}

/** Converts a value to an int.
 *  @param value the value to convert
 *  @return the resulting int. */
int value2int(Value value) {
    /* Gets the width of the value. */
    unsigned long long width = type_width(value->type);
    /* Compute the mask for removing the extra bits. */
    unsigned int mask = width < 32 ? (1UL << width)-1 : 0xFFFFFFFF;
    /* Gets the sign of the value. */
    unsigned int sign = value->type->flags.sign;
    /* Extract 32 bits from the value. */
    int result = read32(value) & mask;
    /* Extends the sign if required. */
    if (sign && (result >> width)) result |= ~mask;
    return result;
}

/** Converts a value to a long long.
 *  @param value the value to convert
 *  @return the resulting int. */
long long value2longlong(Value value) {
    /* Gets the width of the value. */
    unsigned long long width = type_width(value->type);
    /* Compute the mask for removing the extra bits. */
    unsigned long long mask = width < 64 ? (1UL << width)-1 : 0xFFFFFFFFFFFFFFFF;
    /* Gets the sign of the value. */
    unsigned int sign = value->type->flags.sign;
    /* Extract 64 bits from the value. */
    int result = read64(value) & mask;
    /* Extends the sign if required. */
    if (sign && (result >> width)) result |= ~mask;
    return result;
}

/** Reads a range from a value. 
 *  @param value the value to read
 *  @param first the first index of the range
 *  @param last the last index of the range
 *  @param base the type of the elements
 // *  @return the accumulator
 *  @param dst the destination value */
// Value read_range(Value value, long long first, long long last, Type base) {
void read_range(Value value, long long first, long long last, Type base,
                Value dst) {
    unsigned long long i;
    /* Compute the word shift. */
    unsigned int bw = type_width(base);
    unsigned int ws = (first*bw) / INT_BIT;
    /* Compute the bit shift. */
    unsigned int bs = (first*bw) % INT_BIT;
    /* Compute the higher bits clearing mask for the destination. */
    unsigned int dst_mask_high = ~((1UL << bs) - 1UL);
    /* Compute the lower bits clearing mask for the destination. */
    unsigned int dst_mask_low = ~dst_mask_high;
    // /* Compute the lower bits selection mask for the source. */
    // unsigned int src_mask_low = dst_mask_high;
    /* Compute the higher bits selection mask for the source. */
    unsigned int src_mask_high = dst_mask_low;

    /* Access the source data. */
    unsigned int* src_data = value->data;
    // /* Access the destination data. */
    //  unsigned int* dst_data = accumulator->data;
    /* Access the destination data. */
    unsigned int* dst_data = dst->data;

    /* Compute the size of the result in long long. */
    unsigned long long number = last-first+1;
    unsigned long long size = (number*bw) / INT_BIT;
    if ((number*bw) % INT_BIT != 0) size += 1;

    // /* Update the accumulator capacity if required. */
    // resize_value(accumulator,size);
    /* Update the destination capacity if required. */
    resize_value(dst,size);
    // /* set the type and size of the accumulator to the type first source. */
    // accumulator->type = get_type_vector(base,number);
    // accumulator->size = size;
    // accumulator->numeric = value->numeric;
    /* set the type and size of the destination to the type first source. */
    dst->type = get_type_vector(base,number);
    dst->size = size;
    dst->numeric = value->numeric;

    /* Perform the copy. */
    for(i=0; i<size; ++i) {
        /* Copy the lower bits. */
        dst_data[i] &= dst_mask_low;
        dst_data[i] |= src_data[i+ws] >> bs;
        /* Copy the higher bits. */
        dst_data[i] &= dst_mask_high;
        dst_data[i] |= (src_data[i+ws] & src_mask_high) << (INT_BIT-bs);
    }

    // /* Return the accumulator. */
    // return accumulator;
}

/** Writes 8 bits to a value
 *  @param data the data to write
 *  @param value the target value */
void write8(char data, Value value) {
    /* Get the actual target value from: it should be the future value
     * (f_value) is case it is a signal value. */
    SignalI signal = value->signal;
    if (signal) value = signal->f_value;
    /* Sets the value. */
    value->data[0] = (value->data[0] & 0xFFFFFFFFFFFFFF00ULL) | data;
    /* Touch the corresponding signal (if any). */
    if (signal) touch_signal(signal);
}

/** Writes 16 bits to a value
 *  @param data the data to write
 *  @param value the target value */
void write16(short data, Value value) {
    /* Get the actual target value from: it should be the future value
     * (f_value) is case it is a signal value. */
    SignalI signal = value->signal;
    if (signal) value = signal->f_value;
    /* Sets the value. */
    value->data[0] = (value->data[0] & 0xFFFFFFFFFFFF0000ULL) | data;
    /* Touch the corresponding signal (if any). */
    if (signal) touch_signal(signal);
}

/** Writes 32 bits to a value
 *  @param data the data to write
 *  @param value the target value */
void write32(int data, Value value) {
    /* Get the actual target value from: it should be the future value
     * (f_value) is case it is a signal value. */
    SignalI signal = value->signal;
    if (signal) value = signal->f_value;
    /* Sets the value. */
    value->data[0] = (value->data[0] & 0xFFFFFFFF00000000ULL) | data;
    /* Touch the corresponding signal (if any). */
    if (signal) touch_signal(signal);
}

/** Writes 64 bits to a value
 *  @param data the data to write
 *  @param value the target value */
void write64(long long data, Value value) {
    /* Get the actual target value from: it should be the future value
     * (f_value) is case it is a signal value. */
    SignalI signal = value->signal;
    if (signal) value = signal->f_value;
    /* Sets the value. */
    value->data[0] = data;
    /* Touch the corresponding signal (if any). */
    if (signal) touch_signal(signal);
}

/** Writes to a range within a value. 
 *  @param src the source value
 *  @param first the first index of the range
 *  @param last the last index of the range
 *  @param dst the destination value */
void write_range(Value src, long long first, long long last, Value dst) {
    unsigned long long i;
    /* Compute the word shift. */
    unsigned int dw = type_width(dst->type);
    unsigned int ws = (first*dw) / INT_BIT;
    /* Compute the bit shift. */
    unsigned int bs = (first*dw) % INT_BIT;
    /* Compute the higher bits clearing mask for the destination. */
    unsigned int dst_mask_high = ~((1UL << (INT_BIT-bs)) - 1UL);
    /* Compute the lower bits clearing mask for the destination. */
    unsigned int dst_mask_low = ~dst_mask_high;
    // /* Compute the lower bits selection mask for the source. */
    // unsigned int src_mask_low = dst_mask_high;
    /* Compute the higher bits selection mask for the source. */
    unsigned int src_mask_high = dst_mask_low;

    /* Access the source data. */
    unsigned int* src_data = src->data;
    /* Access the destination data. */
    unsigned int* dst_data = dst->data;

    /* Compute the size of the result in long long. */
    unsigned long long bw = src->type->base;
    unsigned long long number = last-first+1;
    unsigned long long size = (number*bw) / INT_BIT;
    if ((number*dw) % INT_BIT != 0) size += 1;

    /* Perform the copy. */
    for(i=0; i<size; ++i) {
        /* Copy the lower bits. */
        dst_data[i] &= dst_mask_low;
        dst_data[i] |= src_data[i+ws] >> bs;
        /* Copy the higher bits. */
        dst_data[i] &= dst_mask_high;
        dst_data[i] |= (src_data[i+ws] & src_mask_high) << (INT_BIT-bs);
    }
}

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <limits.h>
#include <pthread.h>

#include "hruby_sim.h"


/**
 *  The HDLRuby simulation core, to be used with C code generated by
 *  hruby_low2c. 
 *  */

/** The list of touched signals. */
static ListS touched_signals_content = { NULL, NULL };
static List touched_signals = &touched_signals_content;

/** The list of activating signals. */
static ListS activate_signals_content = { NULL, NULL }; 
static List activate_signals = &activate_signals_content;

/** The number of timed behaviors. */
static int num_timed_behaviors = 0;
/** The capacity of the timed behaviors. */
static int cap_timed_behaviors = 0;
/** The timed behaviors. */
static Behavior* timed_behaviors = NULL;

/** The number of running behaviors. */
static int num_run_behaviors = 0;
/** The number of activated behaviors. */
static int num_active_behaviors = 0;

/** Flag saying the behaviors can run. */
static int behaviors_can_run = 0;

/** The current simulation time. */
static unsigned long long hruby_sim_time = 0;

/** The mutex for accessing the simulator ressources. */
static pthread_mutex_t hruby_sim_mutex = PTHREAD_MUTEX_INITIALIZER;

/** The condition the behaviors wait on. */
static pthread_cond_t hruby_beh_cond = PTHREAD_COND_INITIALIZER;
/** The condition the simulator waits on. */
static pthread_cond_t hruby_sim_cond = PTHREAD_COND_INITIALIZER;

/** Flags for the simulation. */
static int sim_end_flag = 0;

/** Adds a timed behavior for processing. 
 *  @param the timed behavior to add */
void register_timed_behavior(Behavior behavior) {
    if (num_timed_behaviors == cap_timed_behaviors) {
        if (cap_timed_behaviors == 0) {
            /* Need to create the array containing the timed behaviors. */
            cap_timed_behaviors = 5;
            timed_behaviors = calloc(sizeof(Behavior),cap_timed_behaviors);
        } else {
            /* Need to increase the capacity. */
            Behavior* behaviors = calloc(sizeof(Behavior),cap_timed_behaviors*2);
            memcpy(timed_behaviors,behaviors,sizeof(Behavior)*cap_timed_behaviors);
            cap_timed_behaviors *= 2;
        }
    }
    /* Add the behavior. */
    timed_behaviors[num_timed_behaviors++] = behavior;
}


/** Recursively update the signals until no (untimed) behavior are
 *  activated. */
void hruby_sim_update_signals() {
    // printf("hruby_sim_update_signals...\n");
    /* As long as the list of touched signals is not empty go on computing. */
    while(!empty_list(touched_signals)) {
        // printf("## Checking touched signals.\n");
        /* Sets the new signals values and mark the signals as activating. */
        while(!empty_list(touched_signals)) {
            Elem e = remove_list(touched_signals);
            SignalI sig = e->data;
            // printf("Touched signal: %p\n",sig);
            /* Update the current value of the signal. */
            copy_value(sig->f_value,sig->c_value);
            /* Mark the signal as activated. */
            add_list(activate_signals,e);
        }
        // printf("## Checking activate signals.\n");
        /* Execute the behaviors activated by the signals. */
        while(!empty_list(activate_signals)) {
            Elem e = remove_list(activate_signals);
            SignalI sig = e->data;
            delete_element(e);
            /* Any edge activation. */
            int i;
            for(i=0; i<sig->num_any; ++i) {
                Object obj = sig->any[i];
                if (obj->kind == BEHAVIOR) {
                    /* Behavior case. */
                    Behavior beh = (Behavior)obj;
                    // printf("Signal: %p Behavior: %p\n",sig,beh);
                    beh->block->function();
                } else {
                    /* Other code case. */
                    Code cod = (Code)obj;
                    cod->function();
                }
            }
            /* Positive edge activation. */
            if (!zero_value(sig->c_value)) {
                for(i=0; i<sig->num_pos; ++i) {
                    Object obj = sig->pos[i];
                    if (obj->kind == BEHAVIOR) {
                        /* Behavior case. */
                        Behavior beh = (Behavior)obj;
                        // printf("Signal: %p Behavior: %p\n",sig,beh);
                        beh->block->function();
                    } else {
                        /* Other code case. */
                        Code cod = (Code)obj;
                        cod->function();
                    }
                }
            }
            /* Negative edge activation. */
            if (zero_value(sig->c_value)) {
                for(i=0; i<sig->num_neg; ++i) {
                    Object obj = sig->neg[i];
                    if (obj->kind == BEHAVIOR) {
                        /* Behavior case. */
                        Behavior beh = (Behavior)obj;
                        // printf("Signal: %p Behavior: %p\n",sig,beh);
                        beh->block->function();
                    } else {
                        /* Other code case. */
                        Code cod = (Code)obj;
                        cod->function();
                    }
                }
            }
        }
    }
}


/** Advance time to the next time step. */
void hruby_sim_advance_time() {
    /* Collects the activation time of all the timed behaviors and find
     * the shortest one. */
    unsigned long long next_time = ULLONG_MAX;
    int i;
    for(i=0; i<num_timed_behaviors; ++i) {
        unsigned long long beh_time = timed_behaviors[i]->active_time;
        if (beh_time < next_time) next_time = beh_time;
    }
    /* Sets the new activation time. */
    hruby_sim_time = next_time;
    println_time(hruby_sim_time);
}


/** Activates a behavior.
 *  @param behavior the behavior to activate. */
void activate_behavior(Behavior behavior) {

}


/** Activates the timed behavior that have to be activated at this
  * time. */
void hruby_sim_activate_behaviors_on_time() {
    int i;
    // printf("$1\n");
    pthread_mutex_lock(&hruby_sim_mutex); 
    /* Count the number of behaviors that will be activated. */
    for(i=0; i<num_timed_behaviors; ++i) {
        Behavior beh = timed_behaviors[i];
        if (beh->active_time == hruby_sim_time) {
            /* Increase the number of timed behavior to wait for. */
            num_active_behaviors ++;
            // printf("num_active_behaviors = %d\n",num_active_behaviors);
        }
    }
    /* Activate the behaviors .*/
    behaviors_can_run = 1;
    // pthread_cond_signal(&compute_cond); /* No behaviors. */
    pthread_cond_signal(&hruby_beh_cond); 
    pthread_mutex_unlock(&hruby_sim_mutex);
    // printf("$2\n");
}


/** Wait for the active timed behaviors to advance. */
void hruby_sim_wait_behaviors() {
    // printf("$3\n");
    pthread_mutex_lock(&hruby_sim_mutex);
    while(num_active_behaviors > 0) {
        // printf("num_active_behaviors = %d\n",num_active_behaviors);
        // pthread_cond_wait(&active_behaviors_cond, &hruby_sim_mutex);
        pthread_cond_wait(&hruby_sim_cond, &hruby_sim_mutex);
    }
    behaviors_can_run = 0;
    pthread_mutex_unlock(&hruby_sim_mutex);
    // printf("$4\n");
}


/** The code for starting a behavior.
 *  @param arg the behavior to execute. */
void* behavior_run(void* arg) {
    Behavior behavior = (Behavior)arg;
    /* First lock the behavior until the simulation engine starts. */
    // printf("#1\n");
    pthread_mutex_lock(&hruby_sim_mutex);
    num_active_behaviors -= 1;
    while(!behaviors_can_run) {
        // pthread_cond_wait(&compute_cond, &hruby_sim_mutex);
        pthread_cond_wait(&hruby_beh_cond, &hruby_sim_mutex);
    }
    pthread_mutex_unlock(&hruby_sim_mutex);
    // printf("#2\n");
    /* Now can start the execution of the behavior. */
    behavior->block->function();
    /* Stops the behavior. */
    pthread_mutex_lock(&hruby_sim_mutex);
    num_active_behaviors -= 1;
    num_run_behaviors -= 1;
    pthread_cond_signal(&hruby_sim_cond);
    pthread_mutex_unlock(&hruby_sim_mutex);
    /* End the thread. */
    pthread_exit(NULL);
}


/** Starts the timed behaviors.
 *  @note create a thread per timed behavior. */
void hruby_sim_start_timed_behaviors() {
    int i;
    /* Sets the end flags to 0. */
    sim_end_flag = 0;
    /* Create and start the threads. */
    for(i=0; i<num_timed_behaviors; ++i) {
        num_run_behaviors += 1;
        // ++num_active_behaviors;
        // printf("0 num_active_behaviors = %d\n",num_active_behaviors);
        pthread_create(&timed_behaviors[i]->thread,NULL,
                       &behavior_run,timed_behaviors[i]);
    }
}

/** Ends waiting all the threads properly terminates. */
void hruby_sim_end_timed_behaviors() {
    int i;
    /* Sets the end flag to 1. */
    sim_end_flag = 1;
    /* Wait for the threads to terminate. */
    for(i=0; i<num_timed_behaviors; ++i) {
        pthread_join(timed_behaviors[i]->thread,NULL);
    }
}




/** The simulation core function.
 *  @param limit the time limit in fs. */
void hruby_sim_core(unsigned long long limit) {
    /* Initialize the time to 0. */
    hruby_sim_time = 0;

    /* Start all the timed behaviors. */
    hruby_sim_start_timed_behaviors();
    // /* Activate the timed behavior that are on time. */
    // hruby_sim_activate_behaviors_on_time();

    /* Run while there are active behaviors and the time limit is not 
     * reached */
    while(hruby_sim_time<limit) {
        // printf("num_active_behaviors = %d\n",num_active_behaviors);
        /* Wait for the active timed behaviors to perform their computations. */
        hruby_sim_wait_behaviors();
        /* Update the signal values (recursively executing blocks locked
         * on the signals). */
        hruby_sim_update_signals(); 
        if (num_run_behaviors <= 0) break;
        /* Advance time to next timestep. */
        hruby_sim_advance_time();
        /* Activate the timed behavior that are on time. */
        hruby_sim_activate_behaviors_on_time();
    }
}




/* ##################################################################### */
/* ##                The interface for the HW description.            ## */
/* ##################################################################### */




/** Makes the behavior wait for a given time.
 *  @param delay the delay to wait in fs.
 *  @param behavior the current behavior. */
void hw_wait(unsigned long long delay, Behavior behavior) {
    // printf("!1\n");
    /* Maybe the thread is to end immediatly. */
    if (sim_end_flag)
        pthread_exit(NULL);
    /* No go on with the wait procedure. */
    pthread_mutex_lock(&hruby_sim_mutex);
    /* Indicate the behavior finished current execution. */
    num_active_behaviors -= 1;
    pthread_cond_signal(&hruby_sim_cond);
    /* Update the behavior's time. */
    behavior->active_time += delay;
    pthread_mutex_unlock(&hruby_sim_mutex);
    /* Wait for being reactivated. */
    while(behavior->active_time > hruby_sim_time) {
        pthread_mutex_lock(&hruby_sim_mutex);
        while(!behaviors_can_run) {
            // pthread_cond_wait(&compute_cond, &hruby_sim_mutex);
            pthread_cond_wait(&hruby_beh_cond, &hruby_sim_mutex);
        }
        pthread_mutex_unlock(&hruby_sim_mutex);
    }
}


/** Touch a signal. 
 *  @param signal the signal to touch  */
void touch_signal(SignalI signal) {
    // printf("touching signal: %p\n",signal);
    add_list(touched_signals,get_element(signal));
    println_signal(signal);
}


/** Transmit a value to a signal.
 *  @param value the value to transmit
 *  @param signal the signal to transmit the value to. */
void transmit_to_signal(Value value, SignalI signal) {
    /* Only transmit if the value and the signal f_value contents are
     * different. */
    if (!same_content_values(value,signal->f_value)) {
        /* Can transmit, copy the content. */
        copy_value(value,signal->f_value);
        /* And touch the signal. */
        touch_signal(signal);
    }
}


/** Creates an event.
 *  @param edge the edge of the event
 *  @param signal the signal of the event */
Event make_event(Edge edge, SignalI signal) {
    Event event = malloc(sizeof(EventS));
    event->edge = edge;
    event->signal = signal;

    return event;
}


/** Creates a delay.
 *  Actually generates an unsigned long long giving the corresponding
 *  delay in the base unit of the simulator. 
 *  @param value the value of the delay
 *  @param unit the used unit
 *  @return the result delay in the base unit of the simulator (ns) */
unsigned long long make_delay(int value, Unit unit) {
    switch(unit) {
        case  S: return value * 1000000000ULL;
        case MS: return value * 1000000ULL;
        case US: return value * 1000ULL;
        case NS: return value * 1ULL;
        default: 
                 perror("Invalid unit for a delay."); 
    }
    return -1;
}


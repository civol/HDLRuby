require "hruby_types.rb"

# Note: Fiber in C: https://github.com/higan-emu/libco

module RubyHDL
end

module RubyHDL::High

  ##
  # SW implementation of the Standard HDLRuby::High library:
  # sequencer generator.
  # The idea is to be able to write sw-like sequential code.
  # 
  ########################################################################




  @@absoluteCounter = -1 # The absolute name counter.

  @@uniq_names = Set.new(Symbol.all_symbols.map {|sym| sym.to_s})

  # Generates an absolute uniq name.
  def self.uniq_name(base = "")
    @@absoluteCounter += 1
    name = base.to_s + ":#{@@absoluteCounter}"
    if @@uniq_names.include?(name) then
      # The symbol exists, try again.
      return self.uniq_name
    else
      @@uniq_names.add(name)
      return name.to_sym
    end
  end



  # Describes a SW implementation of the top block.
  # It cannot contain any statement, but can register objects.
  class SblockTop
    using RubyHDL::High

    # Create a new top block.
    def initialize
      # Initialize the table of callable procs from outside.
      @callables = { }
      # Initialize the list of signals declared in this block.
      @signals = []
    end

    # The sequencer of the block: none since top Sblock for globals.
    def sequencer
      nil
    end

    # Generate input signals with type +type+ and names from +names+ list.
    def make_inputs(type,*names)
      # puts "make_inputs with names=#{names.join(",")}"
      type = type.to_type
      last_sig = nil
      names.each do |name|
        name = name.to_sym
        # Create and add the signal.
        sig = SignalI.new(name,type,:input)
        @signals << sig
        # Register it.
        # self.register(name) { puts("sig=",sig.inspect); sig }
        self.register(name) { sig }
        last_sig = sig
      end
      return last_sig
    end

    # Generate output signals with type +type+ and names from +names+ list.
    def make_outputs(type,*names)
      # puts "make_outputs with names=#{names.join(",")}"
      type = type.to_type
      last_sig = nil
      names.each do |name|
        name = name.to_sym
        # Create and add the signal.
        sig = SignalI.new(name,type,:output)
        @signals << sig
        # Register it.
        # self.register(name) { puts("sig=",sig.inspect); sig }
        self.register(name) { sig }
        last_sig = sig
      end
      return last_sig
    end

    # Generate inner signals with type +type+ and names from +names+ list.
    def make_inners(type,*names)
      # puts "make_inners with names=#{names.join(",")}"
      type = type.to_type
      last_sig = nil
      names.each do |name|
        name = name.to_sym
        # Create and add the signal.
        sig = SignalI.new(name,type,:inner)
        @signals << sig
        # Register it.
        # self.register(name) { puts("sig=",sig.inspect); sig }
        self.register(name) { sig }
        last_sig = sig
      end
      return last_sig
    end

    # Register a new object named +name+ generated by +ruby_block+.
    def register(name,&ruby_block)
      # Add a way to call it from the stack of SW blocks.
      ::Object.define_method(name) do |*args|
        RubyHDL::High.call_sblock(name,*args)
      end
      # Add a method for accessing the object.
      # self.define_singleton_method(name,&ruby_block)
      # res = ruby_block.call
      @callables[name] = ruby_block
    end

    # Tell if a method is callable from there.
    def callable?(m)
      return @callables.key?(m)
    end

    # Call a method from there.
    def callable(m,*args,&ruby_block)
      return @callables[m].call(*args,&ruby_block)
    end

    # Iterate on the signal declared in the block.
    def each_signal(&ruby_block)
      return to_enum(:each_signal) unless ruby_block
      @signals.each(&ruby_block)
    end
  end


  # The stack of SW blocks.
  SBLOCK_STACK = [ SblockTop.new ]

  def self.global_sblock
    SBLOCK_STACK[0]
  end

  def self.top_sblock
    SBLOCK_STACK[-1]
  end

  def self.push_sblock(sblock)
    SBLOCK_STACK << sblock
  end

  def self.pop_sblock
    SBLOCK_STACK.pop
  end

  # Calling a method from the stack.
  def self.call_sblock(m,*args,&ruby_block)
      SBLOCK_STACK.reverse_each do |sblock|
        if sblock.callable?(m) then
          # return sblock.callable(m,*args,&ruby_block)
          res = sblock.callable(m,*args,&ruby_block)
          return res
        end
      end
      # Method not found.
      method_missing(m,*args,&ruby_block)
  end

  # # Handling of new names.
  # class ::Object
  #   alias_method :old_method_missing, :method_missing

  #   def method_missing(m, *args, &ruby_block)
  #     # print "method_missing in class=#{self.class} with m=#{m}\n"
  #     # Not a value, but maybe it is in the stack of SW blocks
  #     SBLOCK_STACK.reverse_each do |sblock|
  #       if sblock.respond_to?(m) then
  #         return sblock.send(m,*args,&ruby_block)
  #       end
  #     end
  #     # puts "here: #{m}"
  #     # No, true error
  #     self.old_method_missing(m,*args,&ruby_block)
  #   end
  # end


  # RUBY_OPERATOR = {
  #   # Unary operators.
  #   :"-@" => "-(%s)", :"+@" => "+(%s)", :"~" => "~(%s)",
  #   :abs => "(%s).abs",
  #   :boolean => "%s", :bit => "%s", 
  #   :signed => "%s", :unsigned => "(%s) & 0xFFFFFFFFFFFFFFFF",

  #   # Binary operators.
  #   :"+" => "(%s)+(%s)", :"-" => "(%s)-(%s)",  :"*" => "(%s)*(%s)",
  #   :"/" => "(%s)/(%s)", :"%" => "(%s)%%(%s)", :"**" => "(%s)**(%s)",
  #   :"&" => "(%s)&(%s)", :"|" => "(%s)|(%s)",  :"^" => "(%s)^(%s)",
  #   :"<<" => "(%s)<<(%s)", :">>" => "(%s)>>(%s)",
  #   :"==" => "(%s)==(%s)", :"!=" => "(%s)!=(%s)",
  #   :"<" => "(%s)<(%s)", :">" => "(%s)>(%s)", 
  #   :"<=" => "(%s)<=(%s)",:">=" => "(%s)>=(%s)"
  # }

  # The translation of operators into Ruby code.
  RUBY_OPERATOR = {
    # Unary operators.
    :"-@" => "-(%{l})", :"+@" => "+(%{l})", :"~" => "~(%{l})",
    :abs => "(%{l}).abs",
    :boolean => "%{l}", :bit => "%{l}", 
    :signed => "%{l}", :unsigned => "(%{l}) & 0xFFFFFFFFFFFFFFFF",

    # Binary operators.
    :"+" => "(%{l})+(%{r})", :"-" => "(%{l})-(%{r})", 
    :"*" => "(%{l})*(%{r})", :"/" => "(%{l})/(%{r})", 
    :"%" => "(%{l})%%(%{r})", :"**" => "(%{l})**(%{r})",
    :"&" => "(%{l})&(%{r})", :"|" => "(%{l})|(%{r})", 
    :"^" => "(%{l})^(%{r})",
    :"<<" => "(%{l})<<(%{r})", :">>" => "(%{l})>>(%{r})",
    :"==" => "((%{l}) & %{m}==(%{r}) & %{m}) ? 1:0", 
    :"!=" => "((%{l}) & %{m}!=(%{r}) %{m}) ? 1:0",
    :"<" => "((%{l}) & %{m}%{s} < (%{r}) & %{m}%{s}) ? 1:0", 
    :">" => "((%{l}) & %{m}%{s} > (%{r}) & %{m}%{s}) ? 1:0", 
    :"<=" => "((%{l}) & %{m}%{s} <=(%{r}) & %{m}%{s}) ? 1:0",
    :">=" => "((%{l}) & %{m}%{s} >=(%{r}) & %{m}%{s}) ? 1:0"
  }

  # The translation of operators into C code.
  C_OPERATOR = {
    # Unary operators.
    :"-@" => "-(%s)", :"+@" => "+(%s)", :"~" => "~(%s)",
    :abs => "(%s).abs",
    :boolean => "%s", :bit => "%s", 
    :signed => "%s", :unsigned => "(%s) & 0xFFFFFFFFFFFFFFFF",

    # Binary operators.
    :"+" => "(%s)+(%s)", :"-" => "(%s)-(%s)",  :"*" => "(%s)*(%s)",
    :"/" => "(%s)/(%s)", :"%" => "(%s)%%(%s)", :"**" => "pow((%s),(%s))",
    :"&" => "(%s)&(%s)", :"|" => "(%s)|(%s)",  :"^" => "(%s)^(%s)",
    :"<<" => "(%s)<<(%s)", :">>" => "(%s)>>(%s)",
    :"==" => "(%s)==(%s)", :"!=" => "(%s)!=(%s)",
    :"<" => "(%s)<(%s)", :">" => "(%s)>(%s)", 
    :"<=" => "(%s)<=(%s)",:">=" => "(%s)>=(%s)"
  }



  # Module adding functionalities to object including the +seach+ method.
  module SEnumerable

    # Iterator on each of the elements in range +rng+.
    # *NOTE*: 
    #   - Stop iteration when the end of the range is reached or when there
    #     are no elements left
    #   - This is not a method from Ruby but one specific for hardware where
    #     creating a array is very expensive.
    def seach_range(rng,&ruby_block)
      self.seach.seach_range(rng,&ruby_block)
    end

    # Tell if all the elements respect a given criterion given either
    # as +arg+ or as block.
    def sall?(arg = nil,&ruby_block)
      self.seach.sall?(arg,&ruby_block)
    end

    # Tell if any of the elements respects a given criterion given either
    # as +arg+ or as block.
    def sany?(arg = nil,&ruby_block)
      self.seach.sany?(arg,&ruby_block)
    end

    # Returns an SEnumerator generated from current enumerable and +arg+
    def schain(arg)
      self.seach.schain(arg)
    end

    # HW implementation of the Ruby chunk.
    # NOTE: to do, or may be not.
    def schunk(*args,&ruby_block)
      raise "schunk is not supported yet."
    end

    # HW implementation of the Ruby chunk_while.
    # NOTE: to do, or may be not.
    def schunk_while(*args,&ruby_block)
      raise "schunk_while is not supported yet."
    end

    # Returns a vector containing the execution result of the given block 
    # on each element. If no block is given, return an SEnumerator.
    # NOTE: be carful that the resulting vector can become huge if there
    # are many element.
    def smap(&ruby_block)
      self.seach.smap(&ruby_block)
    end

    # HW implementation of the Ruby flat_map.
    # NOTE: actually due to the way HDLRuby handles vectors, should work
    #       like smap
    def sflat_map(&ruby_block)
      self.seach.sflat_map(&ruby_block)
    end

    # HW implementation of the Ruby compact, but remove 0 values instead
    # on nil (since nil that does not have any meaning in HW).
    def scompact
      self.seach.scompact(&ruby_block)
    end


    # WH implementation of the Ruby count.
    def scount(obj = nil, &ruby_block)
      self.seach.scount(obj,&ruby_block)
    end

    # HW implementation of the Ruby cycle.
    def scycle(n = nil,&ruby_block)
      self.seach.scycle(n,&ruby_block)
    end

    # HW implementation of the Ruby find.
    # NOTE: contrary to Ruby, if_none_proc is mandatory since there is no
    #       nil in HW. Moreover, the argument can also be a value.
    def sfind(if_none_proc, &ruby_block)
      self.seach.sfind(if_non_proc,&ruby_block)
    end

    # HW implementation of the Ruby drop.
    def sdrop(n)
      self.seach.sdrop(n)
    end

    # HW implementation of the Ruby drop_while.
    def sdrop_while(&ruby_block)
      self.seach.sdrop_while(n)
    end

    # HW implementation of the Ruby each_cons
    def seach_cons(n,&ruby_block)
      self.seach.seach_cons(n,&ruby_block)
    end

    # HW implementation of the Ruby each_entry.
    # NOTE: to do, or may be not.
    def seach_entry(*args,&ruby_block)
      raise "seach_entry is not supported yet."
    end

    # HW implementation of the Ruby each_slice
    def seach_slice(n,&ruby_block)
      self.seach.seach_slice(n,&ruby_block)
    end

    # HW implementation of the Ruby each_with_index.
    def seach_with_index(*args,&ruby_block)
      self.seach.swith_index(*args,&ruby_block)
    end

    # HW implementation of the Ruby each_with_object.
    def seach_with_object(obj,&ruby_block)
      self.seach.swith_object(obj,&ruby_block)
    end

    # HW implementation of the Ruby to_a.
    def sto_a
      self.seach.sto_a
    end

    # HW implementation of the Ruby select.
    def sselect(&ruby_block)
      self.seach.sselect(&ruby_block)
    end

    # HW implementation of the Ruby find_index.
    def sfind_index(obj = nil, &ruby_block)
      self.seach.sfind_index(obj,&ruby_block)
    end

    # HW implementation of the Ruby first.
    def sfirst(n=1)
      self.seach.sfirst(n)
    end

    # HW implementation of the Ruby grep.
    # NOTE: to do, or may be not.
    def sgrep(*args,&ruby_block)
      raise "sgrep is not supported yet."
    end

    # HW implementation of the Ruby grep_v.
    # NOTE: to do, or may be not.
    def sgrep_v(*args,&ruby_block)
      raise "sgrep_v is not supported yet."
    end

    # HW implementation of the Ruby group_by.
    # NOTE: to do, or may be not.
    def sgroup_by(*args,&ruby_block)
      raise "sgroup_by is not supported yet."
    end

    # HW implementation of the Ruby include?
    def sinclude?(obj)
      return self.seach.sinclude?(obj)
    end

    # HW implementation of the Ruby inject.
    def sinject(*args,&ruby_block)
      return self.seach.sinject(*args,&ruby_block)
    end

    # HW implementation of the Ruby reduce.
    def sreduce(*args,&ruby_block)
      return self.seach.sreduce(*args,&ruby_block)
    end

    # HW implementation of the Ruby lazy.
    # NOTE: to do, or may be not.
    def slazy(*args,&ruby_block)
      raise "slazy is not supported yet."
    end

    # HW implementation of the Ruby max.
    def smax(n = nil, &ruby_block)
      return self.seach.smax(n,&ruby_block)
    end

    # HW implementation of the Ruby max_by.
    def smax_by(n = nil, &ruby_block)
      return self.seach.smax_by(n,&ruby_block)
    end

    # HW implementation of the Ruby min.
    def smin(n = nil, &ruby_block)
      return self.seach.smin(n,&ruby_block)
    end

    # HW implementation of the Ruby min_by.
    def smin_by(n = nil, &ruby_block)
      return self.seach.smin_by(n,&ruby_block)
    end

    # HW implementation of the Ruby minmax.
    def sminmax(&ruby_block)
      return self.seach.sminmax(&ruby_block)
    end

    # HW implementation of the Ruby minmax_by.
    def sminmax_by(&ruby_block)
      return self.seach.sminmax_by(&ruby_block)
    end

    # Tell if none of the elements respects a given criterion given either
    # as +arg+ or as block.
    def snone?(arg = nil,&ruby_block)
      return self.seach.snone?(arg,&ruby_block)
    end

    # Tell if one and only one of the elements respects a given criterion
    # given either as +arg+ or as block.
    def sone?(arg = nil,&ruby_block)
      return self.seach.sone?(arg,&ruby_block)
    end

    # HW implementation of the Ruby partition.
    # NOTE: to do, or may be not.
    def spartition(*args,&ruby_block)
      raise "spartition is not supported yet."
    end

    # HW implementatiob of the Ruby reject.
    def sreject(&ruby_block)
      return self.seach.sreject(&ruby_block)
    end

    # HW implementatiob of the Ruby reverse_each.
    def sreverse_each(*args,&ruby_block)
      return self.seach.sreverse_each(*args,&ruby_block)
    end

    # HW implementation of the Ruby slice_after.
    # NOTE: to do, or may be not.
    def sslice_after(pattern = nil,&ruby_block)
      raise "sslice_after is not supported yet."
    end

    # HW implementation of the Ruby slice_before.
    # NOTE: to do, or may be not.
    def sslice_before(*args,&ruby_block)
      raise "sslice_before is not supported yet."
    end

    # HW implementation of the Ruby slice_when.
    # NOTE: to do, or may be not.
    def sslice_when(*args,&ruby_block)
      raise "sslice_before is not supported yet."
    end

    # Merge two arrays in order, for ssort only.
    def ssort_merge(arI, arO, first, middle, last, &ruby_block)
      return self.seach.ssort_merge(arI,arO,first,middle,last,&ruby_block)
    end

    # HW implementation of the Ruby sort.
    def ssort(&ruby_block)
      return self.seach.ssort(&ruby_block)
    end

    # HW implementation of the Ruby sort.
    def ssort_by(&ruby_block)
      return self.seach.ssort_by(&ruby_block)
    end

    # HW implementation of the Ruby sum.
    def ssum(initial_value = nil,&ruby_block)
      return self.seach.ssum(initial_value,&ruby_block)
    end

    # The HW implementation of the Ruby take.
    def stake(n)
      return self.seach.stake(n)
    end

    # The HW implementation of the Ruby take_while.
    def stake_while(&ruby_block)
      return self.seach.stake_while(&ruby_block)
    end

    # HW implementation of the Ruby tally.
    # NOTE: to do, or may be not.
    def stally(h = nil)
      raise "stally is not supported yet."
    end

    # HW implementation of the Ruby to_h.
    # NOTE: to do, or may be not.
    def sto_h(h = nil)
      raise "sto_h is not supported yet."
    end

    # HW implementation of the Ruby uniq.
    def suniq(&ruby_block)
      return self.seach.suniq(&ruby_block)
    end

    # HW implementation of the Ruby zip.
    # NOTE: for now szip is deactivated untile tuples are properly
    #       handled by HDLRuby.
    def szip(obj,&ruby_block)
      return self.seach.szip(obj,&ruby_block)
    end

    # Iterator on the +num+ next elements.
    # *NOTE*:
    #   - Stop iteration when the end of the range is reached or when there
    #     are no elements left
    #   - This is not a method from Ruby but one specific for hardware where
    #     creating a array is very expensive.
    def seach_nexts(num,&ruby_block)
      return self.seach.snexts(num,&ruby_block)
    end

  end


  # Modify String to act as Ruby code generator.
  refine ::String do
    # Convert to Ruby code.
    def to_ruby
      self
    end

    # Convert to C code.
    alias_method :to_c, :to_ruby
  end


  # Modify Integer to act as value.
  refine ::Integer do
    def to_value
      return Value.new(signed[32],self)
    end
    alias_method :to_expr, :to_value

    def to_ruby
      return self
    end

    def to_c
      return self.to_s
    end

    # Enhance the Integer class with sequencer iterations.

    # HW times iteration.
    def stimes(&ruby_block)
      self.to_value.stimes(&ruby_block)
    end

    # HW upto iteration.
    def supto(val,&ruby_block)
      self.to_value.supto(&ruby_block)
    end

    # HW downto iteration.
    def sdownto(val,&ruby_block)
      self.to_value.sdownto(&ruby_block)
    end
  end

  # Modify Float to act as value.
  refine ::Float do
    def to_value
      return Value.new(float[64],self)
    end
    alias_method :to_expr, :to_value
  end

  # Modify Range to act as RubyHDL object.
  refine ::Range do
    def to_ruby
      return "(#{self})"
    end
  end

  # Modify Range to support HW iterators.
  refine ::Enumerable do
    import_methods SEnumerable
    # HW iteration on each element.
    def seach(&ruby_block)
       return Siter.new(RubyHDL::High.top_sblock.sequencer,self,"each",&ruby_block)
    end
  end




  # Modify Array to build types.
  refine ::Array do

    # Convert to a type.
    def to_type
      # Compute the base type.
      if self[0].is_a?(::Array) then
        # Recurse build the base.
        base = self[0].to_type
      else
        base = unsigned
      end
      # Generate the resulting type vector.
      return TypeVector.new(:"",base,self[0])
    end

    # Generate input signals from +names+.
    def input(*names)
      # Generate the type.
      type = self.to_type
      # Generate the resulting signals.
      return type.input(*names)
    end

    # Generate output signals from +names+.
    def output(*names)
      # Generate the type.
      type = self.to_type
      # Generate the resulting signals.
      return type.output(*names)
    end

    # Generate inner signals from +names+.
    def inner(*names)
      # Generate the type.
      type = self.to_type
      # Generate the resulting signals.
      return type.inner(*names)
    end
  end



  # Describes a SW implementation of types.

  ##
  # Describes a high-level data type.
  #
  # NOTE: by default a type is not specified.
  class Type
    using RubyHDL::High
    include HDLRuby::Tprocess

    attr_reader :name

    # Type creation.

    # Creates a new type named +name+.
    def initialize(name = nil)
      if name then
        @name = name.to_sym 
        # Registers the name.
        self.register(name)
      end
    end

    # Type access

    # Comparison for hash: structural comparison.
    def eql?(obj)
      return false unless obj.is_a?(Type)
      return false unless @name.eql?(obj.name)
      return true
    end

    # Hash function.
    def hash
      return [@name].hash
    end

    # Tells if the type signed.
    def signed?
      return false
    end

    # Tells if the type is unsigned.
    def unsigned?
      return false
    end

    # Tells if the type is fixed point.
    def fixed?
      return false
    end

    # Tells if the type is floating point.
    def float?
      return false
    end

    # Tells if the type is a leaf.
    def leaf?
      return false
    end

    # Tells if the type of of vector kind.
    def vector?
      return false
    end

    # Gets the bitwidth of the type, by default 0.
    # Bit, signed, unsigned and Float base have a width of 1.
    def width
      if [:bit, :signed, :unsigned, :float ].include?(@name) then
        return 1
      else
        return 0
      end
    end

    # Gets the type max value if any.
    # Default: not defined.
    def max
      raise "No max value for type #{self} (#{self.name})"
    end

    # Gets the type min value if any.
    # Default: not defined.
    def min
      raise "No min value for type #{self} (#{self.name})"
    end

    # Get the direction of the type, little or big endian.
    def direction
      # By default, little endian.
      return :little
    end

    # Tells if the type has a range.
    def range?
      return false
    end

    # Gets the range of the type, by default range is not defined.
    def range
      raise "No range for type #{self} (#{self.name})"
    end

    # Tells if the type has a base.
    def base?
      return false
    end

    # Gets the base type, by default base type is not defined.
    def base
      raise "No base type for type #{self} (#{self.name})"
    end

    # Tells if the type has sub types.
    def types?
      return false
    end

    # Tells if the type is regular (applies for tuples).
    def regular?
      return false
    end

    # Tells if the type has named sub types.
    def struct?
      return false
    end

    # Tells if the type is hierarchical.
    def hierarchical?
      return self.base? || self.types?
    end

    # Tell if +type+ is equivalent to current type.
    #
    # NOTE: type can be compatible while not being equivalent, please
    #       refer to `hruby_types.rb` for type compatibility.
    def equivalent?(type)
      # By default, types are equivalent iff they have the same name.
      return (type.is_a?(Type) and self.name == type.name)
    end

    # Iterates over the types deeply if any.
    def each_type_deep(&ruby_block)
      # No ruby block? Return an enumerator.
      return to_enum(:each_type_deep) unless ruby_block
      # A ruby block? First apply it to current.
      ruby_block.call(self)
      # And that's all by default.
    end
    alias_method :each_deep, :each_type_deep

    # Converts to a bit vector.
    def to_vector
      return TypeVector.new(:"", Bit, self.width-1..0)
    end

    # Tells htype has been included.
    def htype?
      return true
    end

    # Converts to a type.
    # Returns self since it is already a type.
    def to_type
      return self
    end

    # Sets the +name+.
    #
    # NOTE: can only be done if the name is not already set.
    def name=(name)
      unless @name.empty? then
        raise "Name of type already set to: #{@name}."
      end
      # Checks and sets the name.
      name = name.to_sym
      if name.empty? then
        raise "Cannot set an empty name."
      end
      @name = name
      # Registers the name.
      self.register(name)
    end

    # Register the +name+ of the type.
    def register(name)
      # Sets the hdl-like access to the type.
      obj = self # For using the right self within the proc
      RubyHDL::High.top_sblock.register(name) { obj }
    end

    # Gets the type as left value.
    #
    # NOTE: used for asymetric types like TypeSystemI.
    def left
      # By default self.
      self
    end

    # Gets the type as right value.
    #
    # NOTE: used for asymetric types like TypeSystemI.
    def right
      # By default self.
      self
    end

    # Type creation.

    # Declares a new type definition with +name+ equivalent to current one.
    def typedef(name)
      # Create the new type.
      typ = TypeDef.new(name,self)
      # Register it.
      High.top_sblock.register(name) { typ }
      # Return it.
      return typ
    end

    # Creates a new vector type of range +rng+ and with current type as
    # base.
    def [](rng)
      return TypeVector.new(:"",self,rng)
    end

    # SignalI creation through the type.

    # Declares high-level input signals named +names+ of the current type.
    def input(*names)
      RubyHDL::High.top_sblock.make_inputs(self,*names)
    end

    # Declares high-level untyped output signals named +names+ of the
    # current type.
    def output(*names)
      # High.top_user.make_outputs(self.instantiate,*names)
      RubyHDL::High.top_sblock.make_outputs(self,*names)
    end

    # # Declares high-level untyped inout signals named +names+ of the
    # # current type.
    # def inout(*names)
    #   # High.top_user.make_inouts(self.instantiate,*names)
    #   High.top_sblock.make_inouts(self,*names)
    # end

    # Declares high-level untyped inner signals named +names+ of the
    # current type.
    def inner(*names)
      RubyHDL::High.top_sblock.make_inners(self,*names)
    end

    # Declares high-level untyped constant signals by name and
    # value given by +hsh+ of the current type.
    def constant(hsh)
      RubyHDL::High.top_sblock.make_constants(self,hsh)
    end

    # Computations of expressions

    # Gets the computation method for +operator+.
    def comp_operator(op)
      return (op.to_s + ":C").to_sym
    end

    # Performs unary operation +operator+ on expression +expr+.
    def unary(operator,expr)
      # Look for a specific computation method.
      comp = comp_operator(operator)
      if self.respond_to?(comp) then
        # Found, use it.
        self.send(comp,expr)
      else
        # Not found, back to default computation.
        expr.to_value.send(operator)
      end
    end

    # Performs binary operation +operator+ on expressions +expr0+
    # and +expr1+.
    def binary(operator, expr0, expr1)
      # Look for a specific computation method.
      comp = comp_operator(operator)
      if self.respond_to?(comp) then
        # Found, use it.
        self.send(comp,expr0,expr1)
      else
        # Not found, back to default computation.
        expr0.to_value.send(operator,expr1)
      end
    end

    # Redefinition of +operator+.
    def define_operator(operator,&ruby_block)
      # Ensure there is a block.
      ruby_block = proc {} unless block_given?
      # Register the operator as overloaded.
      @overloads ||= {}
      @overloads[operator] = ruby_block
      # Set the new method for the operator.
      self.define_singleton_method(comp_operator(operator)) do |*args|
        # puts "Top user=#{HDLRuby::High.top_user}"
        RubyHDL::High.top_sblock.sub(RubyHDL.uniq_name) do
          ruby_block.call(*args)
        end
      end
    end

    # Redefinition of +operator+ when requiring the context to be passed
    # as argument (normally only used internally).
    def define_operator_with_context(operator,&ruby_block)
      # Ensure there is a block.
      ruby_block = proc {} unless block_given?
      # Register the operator as overloaded.
      @overloads ||= {}
      @overloads[operator] = ruby_block
      # Set the new method for the operator.
      self.define_singleton_method(comp_operator(operator)) do |*args|
        # puts "Top user=#{HDLRuby::High.top_user}"
        RubyHDL::High.top_sblock.sub(RubyHDL.uniq_name) do
          # It is assumed that the first argument of the ruby_block
          # is the context in which it must be executed.
          ruby_block.call(self,*args)
        end
      end
    end

    # Interates over the overloaded operators.
    def each_overload(&ruby_block)
      # No ruby block? Return an enumerator.
      return to_enum(:each_overload) unless ruby_block
      # A block? Apply it on each overload if any.
      @overloads.each(&ruby_block) if @overloads
    end

    # Convert to C code.
    def to_c
      case @name
      when :void
        return "void"
      when :bit, :unsigned
        return "unsigned"
      when :signed
        return "signed"
      when :float
        return "double"
      when :string
        return "char*"
      else
        return @name.to_s
      end
    end

    # Convert to C initialization code.
    def to_c_init
      # By default: 0
      return "0"
    end
  end


  # Defines a basic type +name+.
  def self.define_type(name)
    name = name.to_sym
    type = Type.new(name)
    self.send(:define_method,name) { type }
    return type
  end

  # The void type
  Void = define_type(:void)

  # The bit type.
  Bit = define_type(:bit)

  # The signed bit type.
  Signed = define_type(:signed)
  class << Signed
    # Tells if the type signed.
    def signed?
      return true
    end
  end

  # The unsigned bit type.
  Unsigned = define_type(:unsigned)
  class << Unsigned
    # Tells if the type unsigned.
    def unsigned?
      return true
    end
  end

  # The float bit type
  Float = define_type(:float)
  class << Float
    # Tells if the type signed.
    def signed?
      return true
    end
  end

  # The string type
  StringT = define_type(:string)


  ##
  # Describes a high-level type definition.
  #
  # NOTE: type definition are actually type with a name refering to another
  #       type (and equivalent to it).
  class TypeDef < Type
    # Type creation.

    # Creates a new type definition named +name+ refering +type+.
    def initialize(name,type)
      # Initialize the type structure.
      super(name)
      # Set the referenced type.
      @type = type.to_type
    end
  end

  ##
  # Describes a high-level generic type definition.
  #
  # NOTE: this type does not correspond to any low-level type
  class TypeGen < Type
    # Type creation.

    # Creates a new generic type definition producing a new type by
    # executing +ruby_block+.
    def initialize(name,&ruby_block)
      # Initialize the type structure.
      super(name)
      # Sets the block to execute when instantiating the type.
      @instance_proc = ruby_block
    end

    # Generates the type with +args+ generic parameters.
    def generate(*args)
      # Generate the resulting type.
      gtype = RubyHDL::High.top_sblock.instance_exec(*args,&@instance_proc)
      # Ensures a type has been produced.
      gtype = gtype.to_type if gtype.respond_to?(:to_type)
      unless gtype.is_a?(Type) then
        raise "Generic type #{self.name} did not produce a valid type: #{gtype.class}"
      end
      # Create a new type definition from it.
      gtype = TypeDef.new(self.name.to_s + "_#{args.join(':')}",
                          gtype)
      # Adds the possible overloaded operators.
      self.each_overload do |op,ruby_block|
        gtype.define_operator_with_context(op,&(RubyHDL::High.curry_with_context(*args,&ruby_block)))
      end
      # Returns the resulting type
      return gtype
    end
  end


  ##
  # Describes a vector type.
  class TypeVector < Type
    # The base type of the vector
    attr_reader :base

    # Tells if the type of of vector kind.
    def vector?
      return true
    end

    # Tells if the type has a base.
    def base?
      return true
    end

    # The range of the vector.
    attr_reader :range

    # Creates a new vector type named +name+ from +base+ type and with
    # +range+.
    # NOTE: if +range+ is a positive integer it is converted to
    # (range-1)..0, if it is a negative integer it is converted to
    # 0..(-range-1)
    def initialize(name,base,range)
      # Initialize the type.
      super(name)

      # Check and set the base
      unless base.is_a?(Type)
        raise "Invalid class for VectorType base: #{base.class}."
      end
      @base = base

      # Check and set the range.
      if range.respond_to?(:to_i) then
        # Integer case: convert to 0..(range-1).
        range = range > 0 ? (range-1)..0 : 0..(-range-1)
      elsif
        # Other cases: assume there is a first and a last to create
        # the range.
        range = range.first..range.last
      end
      @range = range
    end

    # Comparison for hash: structural comparison.
    def eql?(obj)
      # # General type comparison.
      # return false unless super(obj)
      # Specific comparison.
      return false unless obj.is_a?(TypeVector)
      return false unless @base.eql?(obj.base)
      return false unless @range.eql?(obj.range)
      return true
    end

    # Hash function.
    def hash
      return [super,@base,@range].hash
    end

    # Gets the size of the type in number of base elements.
    def size
      return (@range.first.to_i - @range.last.to_i).abs + 1
    end

    # Gets the bitwidth of the type, nil for undefined.
    #
    # NOTE: must be redefined for specific types.
    def width
      first = @range.first.to_i
      last  = @range.last.to_i
      return @base.width * ((first-last).abs + 1)
    end

    # Gets the type max value if any.
    def max
      if (self.signed?) then
        return (2**(self.width-1))-1
      else
        return (2**(self.width))-1
      end
    end

    # Gets the type min value if any.
    # Default: not defined.
    def min
      if (self.signed?) then
        return -(2**(self.width-1))
      else
        return 0
      end
    end

    # Get the direction of the type, little or big endian.
    def direction
      return @range.first < @range.last ? :big : :little
    end

    # Gets the direction of the range.
    def dir
      return (@range.last - @range.first)
    end

    # Tells if the type signed.
    def signed?
      return @base.signed?
    end

    # Tells if the type is unsigned.
    def unsigned?
      return @base.unsigned?
    end

    # Tells if the type is fixed point.
    def fixed?
      return @base.signed?
    end

    # Tells if the type is floating point.
    def float?
      return @base.float?
    end

    # Tell if +type+ is equivalent to current type.
    #
    # NOTE: type can be compatible while not being equivalent, please
    #       refer to `hruby_types.rb` for type compatibility.
    def equivalent?(type)
      return (type.is_a?(TypeVector) and
              @range == type.range
      @base.equivalent?(type.base) )
    end

    # Should not exists since it identifies types with multiple sub types.
    #
    # # Iterates over the sub types.
    # def each_type(&ruby_block)
    #     # No ruby block? Return an enumerator.
    #     return to_enum(:each_type) unless ruby_block
    #     # A ruby block? Apply it on the base.
    #     ruby_block.call(@base)
    # end

    # Iterates over the types deeply if any.
    def each_type_deep(&ruby_block)
      # No ruby block? Return an enumerator.
      return to_enum(:each_type_deep) unless ruby_block
      # A ruby block? First apply it to current.
      ruby_block.call(self)
      # And recurse on the base.
      @base.each_type_deep(&ruby_block)
    end

    alias_method :each_deep, :each_type_deep

    # Convert to C code.
    def to_c
      if @base.is_a?(TypeVector) then
        # Array type case.
        return @base.to_c + "[#{self.size.to_i}]"
      else
        # Simple vector type case.
        if float? then
          return @base.to_c
        else
          return @base + " long long"
        end
      end
    end

    # Convert to C initialization code.
    def to_c_init
      if @base.is_a?(TypeVector) then
        # Array type case.
        base_init = @base.to_c_init
        return "[" + ([base_init] * self.size.to_i).join(",") + "]"
      else
        return "0"
      end
    end
  end


  ##
  # Describes a signed integer data type.
  class TypeSigned < TypeVector

    # Creates a new vector type named +name+ from +base+ type and with
    # +range+.
    #
    # NOTE:
    # * The default range is 32-bit.
    def initialize(name,range = 31..0)
      # Initialize the type.
      super(name,Signed,range)
    end
  end

  ##
  # Describes an unsigned integer data type.
  class TypeUnsigned < TypeVector

    # Creates a new vector type named +name+ from +base+ type and with
    # +range+.
    #
    # NOTE:
    # * The default range is 32-bit.
    def initialize(name,range = 31..0)
      # Initialize the type.
      super(name,Unsigned,range)
    end
  end

  ##
  # Describes a float data type.
  class TypeFloat < TypeVector

    # Creates a new vector type named +name+ from +base+ type and with
    # +range+.
    #
    # NOTE:
    # * The bits of negative range stands for the exponent
    # * The default range is for 64-bit IEEE 754 double precision standart
    def initialize(name,range = 52..-11)
      # Initialize the type.
      super(name,Float,range)
    end
  end

  ##
  # Describes a tuple type.
  class TypeTuple < Type
    # Creates a new tuple type named +name+ width +direction+ and whose
    # sub types are given by +content+.
    def initialize(name,direction,*content)
      # Initialize the type.
      super(name)

      # Set the direction.
      @direction = direction.to_sym
      unless [:little, :big].include?(@direction)
        raise "Invalid direction for a type: #{direction}"
      end

      # Check and set the content.
      content.each do |sub|
        unless sub.is_a?(Type) then
          raise "Invalid class for a type: #{sub.class}"
        end
      end
      @types = content
    end

    # Comparison for hash: structural comparison.
    def eql?(obj)
      # # General type comparison.
      # return false unless super(obj)
      return false unless obj.is_a?(TypeTuple)
      # Specific comparison.
      idx = 0
      obj.each_type do |type|
        return false unless @types[idx].eql?(type)
        idx += 1
      end
      return false unless idx == @types.size
      return true
    end

    # Hash function.
    def hash
      return [super,@types].hash
    end

    # Tells if the type has sub types.
    def types?
      return true
    end

    # Gets an array containing all the syb types.
    def get_all_types
      return @types.clone
    end

    # Gets a sub type by +index+.
    def get_type(index)
      return @types[index.to_i]
    end

    # Adds a sub +type+.
    def add_type(type)
      unless type.is_a?(Type) then
        raise "Invalid class for a type: #{type.class} (#{type})"
      end
      @types << type
    end

    # Iterates over the sub name/type pair.
    #
    # Returns an enumerator if no ruby block is given.
    def each(&ruby_block)
      # No ruby block? Return an enumerator.
      return to_enum(:each) unless ruby_block
      # A ruby block? Apply it on each sub name/type pair.
      @types.each(&ruby_block)
    end

    # Iterates over the sub types.
    #
    # Returns an enumerator if no ruby block is given.
    def each_type(&ruby_block)
      # No ruby block? Return an enumerator.
      return to_enum(:each_type) unless ruby_block
      # A ruby block? Apply it on each sub type.
      @types.each(&ruby_block)
    end

    # Iterates over the types deeply if any.
    def each_type_deep(&ruby_block)
      # No ruby block? Return an enumerator.
      return to_enum(:each_type_deep) unless ruby_block
      # A ruby block? First apply it to current.
      ruby_block.call(self)
      # And recurse on the sub types.
      @types.each { |type| type.each_type_deep(&ruby_block) }
    end

    alias_method :each_deep, :each_type_deep

    # Tell if the tuple is regular, i.e., all its sub types are equivalent.
    #
    # NOTE: empty tuples are assumed not to be regular.
    def regular?
      return false if @types.empty?
      t0 = @types[0]
      @types[1..-1].each do |type|
        return false unless t0.equivalent?(type)
      end
      return true
    end

    # Gets the bitwidth.
    def width
      return @types.reduce(0) { |sum,type| sum + type.width }
    end

    # Get the direction of the type, little or big endian.
    def direction
      return @direction
    end

    # Gets the range of the type.
    #
    # NOTE: only valid if the tuple is regular (i.e., all its sub types 
    #       are identical)
    def range
      if regular? then
        # Regular tuple, return its range as if it was an array.
        return 0..@types.size-1
      else
        raise "No range for type #{self}"
      end
    end

    # Tells if the type has a base.
    #
    # NOTE: only if the tuple is regular (i.e., all its sub types
    #       are identical)
    def base?
      return regular?
    end

    # Gets the base type.
    #
    # NOTE: only valid if the tuple is regular (i.e., all its sub types 
    #       are identical)
    def base
      if regular? then
        # Regular tuple, return the type of its first element.
        return @types[0]
      else
        raise "No base type for type #{self}"
      end
    end

    # Tell if +type+ is equivalent to current type.
    #
    # NOTE: type can be compatible while not being equivalent, please
    #       refer to `hruby_types.rb` for type compatibility.
    def equivalent?(type)
      return (type.is_a?(TypeTuple) and
              !@types.zip(type.types).index {|t0,t1| !t0.equivalent?(t1) })
    end
  end

  ##
  # Describes a struct type.
  class TypeStruct < Type
    attr_reader :direction

    # Creates a new structure type named +name+ with direction +dir+ and 
    # whose hierachy is given by +content+.
    def initialize(name,dir,content)
      # Initialize the type.
      super(name)

      # Set the direction.
      @direction = dir.to_sym
      unless [:little, :big].include?(@direction)
        raise "Invalid direction for a type: #{dir}"
      end

      # Check and set the content.
      content = Hash[content]
      @types = content.map do |k,v|
        unless v.is_a?(Type) then
          raise "Invalid class for a type: #{v.class}"
        end
        [ k.to_sym, v ]
      end.to_h
    end

    # Comparison for hash: structural comparison.
    def eql?(obj)
      # General type comparison.
      # return false unless super(obj)
      return false unless obj.is_a?(TypeStruct)
      # Specific comparison.
      idx = 0
      obj.each_key do |name|
        return false unless @types[name].eql?(obj.get_type(name))
        idx += 1
      end
      return false unless idx == @types.size
      return true
    end

    # Hash function.
    def hash
      return [super,@types].hash
    end

    # Tells if the type has named sub types.
    def struct?
      return true
    end

    # Tells if the type has sub types.
    def types?
      return true
    end

    # Gets an array containing all the syb types.
    def get_all_types
      return @types.values
    end

    # Gets a sub type by +name+.
    # NOTE: +name+ can also be an index.
    def get_type(name)
      if name.respond_to?(:to_sym) then
        return @types[name.to_sym]
      else
        return @types.values[name.to_i]
      end
    end

    # Iterates over the sub name/type pair.
    #
    # Returns an enumerator if no ruby block is given.
    def each(&ruby_block)
      # No ruby block? Return an enumerator.
      return to_enum(:each) unless ruby_block
      # A ruby block? Apply it on each sub name/type pair.
      @types.each(&ruby_block)
    end

    # Iterates over the sub types.
    #
    # Returns an enumerator if no ruby block is given.
    def each_type(&ruby_block)
      # No ruby block? Return an enumerator.
      return to_enum(:each_type) unless ruby_block
      # A ruby block? Apply it on each sub type.
      @types.each_value(&ruby_block)
    end

    # Iterates over the keys.
    #
    # Returns an enumerator if no ruby block is given.
    def each_key(&ruby_block)
      # No ruby block? Return an enumerator.
      return to_enum(:each_key) unless ruby_block
      # A ruby block? Apply it on each key.
      @types.each_key(&ruby_block)
    end

    # Iterates over the sub type names.
    #
    # Returns an enumerator if no ruby block is given.
    def each_name(&ruby_block)
      # No ruby block? Return an enumerator.
      return to_enum(:each_name) unless ruby_block
      # A ruby block? Apply it on each name.
      @types.each_key(&ruby_block)
    end

    # Iterates over the types deeply if any.
    def each_type_deep(&ruby_block)
      # No ruby block? Return an enumerator.
      return to_enum(:each_type_deep) unless ruby_block
      # A ruby block? First apply it to current.
      ruby_block.call(self)
      # And recurse on the sub types.
      @types.each_value { |type| type.each_type_deep(&ruby_block) }
    end

    alias_method :each_deep, :each_type_deep

    # Gets the bitwidth of the type, nil for undefined.
    #
    # NOTE: must be redefined for specific types.
    def width
      if @types.is_a?(Array) then
        return @types.reduce(0) {|sum,type| sum + type.width }
      else
        return @types.each_value.reduce(0) {|sum,type| sum + type.width }
      end
    end

    # Tell if +type+ is equivalent to current type.
    #
    # NOTE: type can be compatible while not being equivalent, please
    #       refer to `hruby_types.rb` for type compatibility.
    def equivalent?(type)
      return (type.is_a?(TypeStruct) and
              !@types.to_a.zip(type.types.to_a).index do |t0,t1|
                t0[0] != t1[0] or !t0[1].equivalent?(t1[1])
              end)
    end
  end

  # The type constructors.

  # Creates an unnamed structure type from a +content+.
  def struct(content)
    return TypeStruct.new(:"",:little,content)
  end

  # Methods for declaring types

  # Declares a high-level generic type named +name+, and using +ruby_block+
  # for construction.
  def typedef(name, &ruby_block)
    # Ensure there is a block.
    ruby_block = proc {} unless block_given?
    type = TypeGen.new(name,&ruby_block)
    define_singleton_method(name.to_sym) do |*args|
      if (args.size < ruby_block.arity) then
        # Not enough arguments get generic type as is.
        type
      else
        # There are arguments, specialize the type.
        gtype = type.generate(*args)
        # And add it as a local type of the system.
        RubyHDL::High.top_sblock.add_type(gtype)
        gtype
      end
    end
  end



  ## Describes the software implementation of an expression.
  class Expression
    using RubyHDL::High

    attr_reader :type
    # Create a new expression with +type+ data type.
    def initialize(type)
      @type = type.to_type
    end

    # Converts to an expression.
    def to_expr
      self
    end

    alias_method :to_ref, :to_expr

    # Compute the expression (convert it to a value).
    def to_value
      raise "to_value not defined here."
    end

    # Convert to Ruby code.
    def to_ruby
      raise "to_ruby not defined for class: #{self.class}."
    end

    # Convert to C code.
    def to_c
      raise "to_c not defined for class: #{self.class}."
    end

    # Convert to ruby code for left value.
    # By default: the same as to_ruby
    alias_method :to_ruby_left, :to_ruby

    # The implementation of the expressions generation.
     
    # The unary operations generation.
    [:"-@",:"+@",:"~", :abs,
     :boolean, :bit, :signed, :unsigned].each do |operator|
       self.define_method(operator) do
         return Unary.new(self.type,operator,self.to_expr)
       end
     end

    # The binary operations generation.
    [:"+",:"-",:"*",:"/",:"%",:"**",
     :"&",:"|",:"^",
     :"<<",:">>",# :ls,:rs,:lr,:rr, # ls, rs lr and rr are treated separately
     :"==",:"!=",:"<",:">",:">="].each do |operator|
       # :"<=" is processed appart for transmit.
       self.define_method(operator) do |right|
         return Binary.new(self.type,operator,self.to_expr,right.to_expr)
       end
     end

     # The <= operator which can be either a transmit or a comparison.
     # By default set to transmit, and converted to comparison if
     # child of operator or condition of sif/swhile statements.
     def <=(right)
       return Transmit.new(self.to_expr,right.to_expr)
     end

     # TO DO?
     # # The <=> operator is also supported but is transformed into a sub
     # # with a signed result.
     # def <=>(right)
     #   return (self.as(self.type.base[self.type.width+1])-right).to_signed
     # end

     # Creates an access to elements of range +rng+ of the signal,
     # and set the type of elements as +typ+ if given.
     #
     # NOTE: +rng+ can be a single expression in which case it is an index.
     def [](typ,rng=nil)
       # Treat the number of arguments
       rng, typ = typ, nil unless rng
       # Process the range.
       if rng.is_a?(::Range) then
         first = rng.first
         if (first.is_a?(::Integer)) then
           first = self.type.size+first if first < 0
         end
         last = rng.last
         if (last.is_a?(::Integer)) then
           last = self.type.size+last if last < 0
         end
         rng = first..last
       end
       if rng.is_a?(::Integer) && rng < 0 then
         rng = self.type.size+rng
       end
       if rng.respond_to?(:to_expr) then
         # Number range: convert it to an expression.
         rng = rng.to_expr
       end 
       if rng.is_a?(Expression) then
         # Index case
         if typ then
           return RefIndex.new(typ,self.to_expr,rng)
         else
           return RefIndex.new(self.type.base,self.to_expr,rng)
         end
       else
         # Range case, ensure it is made among expression.
         first = rng.first.to_expr
         last = rng.last.to_expr
         # And create the reference.
         if typ then
           return RefRange.new(typ,
                               self.to_expr,first..last)
         else
           return RefRange.new(self.type.slice(first..last),
                               self.to_expr,first..last)
         end
       end
     end

     # Converts to a select operator using current expression as
     # condition for one of the +choices+.
     #
     # NOTE: +choices+ can either be a list of arguments or an array.
     # If +choices+ has only two entries
     # (and it is not a hash), +value+ will be converted to a boolean.
     def mux(*choices)
       # Process the choices.
       choices = choices.flatten(1) if choices.size == 1
       choices.map! { |choice| choice.to_expr }
       # Generate the select expression.
       return Select.new(choices[0].type,self.to_expr,*choices)
     end

     # The implementation of the interators.

     # HW iteration on each element.
     def seach(&ruby_block)
       RubyHDL::High.top_sblock << 
       Siter.new(RubyHDL::High.top_sblock.sequencer,self,"each",&ruby_block)
     end

    # HW times iteration.
    def stimes(&ruby_block)
      RubyHDL::High.top_sblock << 
      Siter.new(RubyHDL::High.top_sblock.sequencer,self,"times",&ruby_block)
    end

    # HW upto iteration.
    def supto(val,&ruby_block)
      RubyHDL::High.top_sblock <<
      Siter.new(RubyHDL::High.top_sblock.sequencer,self,"upto",&ruby_block)
    end

    # HW downto iteration.
    def sdownto(val,&ruby_block)
      RubyHDL::High.top_sblock << 
      Siter.new(RubyHDL::High.top_sblock.sequencer,self,"downto",&ruby_block)
    end
  end


  ##
  # Describes the software implementation of a value.
  class Value < Expression

    attr_reader :content

    # Create a new value with +type+ data type and content +content+.
    def initialize(type,content)
      super(type)
      @content = content
    end

    # Compute the expression (convert it to a value).
    def to_value
      return self
    end

    # Convert to Ruby code.
    def to_ruby
      return @content.to_s
    end

    # Convert to C code.
    alias_method :to_c, :to_ruby
  end

  
  # Describes the software implementation of an unary operation.
  class Unary < Expression
    # Create a new unary operation with +type+ data type,
    # operator +operator+ and operand +child+
    def initialize(type,operator,child)
      super(type)
      @operator = operator.to_sym
      @child = child.to_expr
      @mask = (2 ** @type.width)-1
    end

    # Convert to Ruby code.
    def to_ruby
      # return RUBY_OPERATOR[@operator] % @child.to_ruby
      return RUBY_OPERATOR[@operator] % { l: @child.to_ruby }
    end

    # Convert to C code.
    def to_c
      return C_OPERATOR[@operator] % @child.to_c
    end
  end
  
  # Describes the software implementation of an binary operation.
  class Binary < Expression
    # Create a new binary operation with +type+ data type,
    # operator +operator+ and operands +left+ and +right+.
    def initialize(type,operator,left,right)
      super(type)
      @operator = operator.to_sym
      @left = left.to_expr
      @right = right.to_expr
      # Compute the mask for fixing the bit width.
      @mask = (2 ** @type.width)-1
      # puts "@type=#{@type} name=#{@type.name} @type.width=#{@type.width} @mask=#{@mask}"
      # Compute xor mask for handling the sign.
      # Make it as a string so that no addition computation is required
      # if no sign is required.
      @sign_fix = ""
      if type.signed? then
        @sign_fix = " ^ #{2**(@type.width-1)}"
      end
    end

    # Convert to Ruby code.
    def to_ruby
      # return RUBY_OPERATOR[@operator] % [ @left.to_ruby, @right.to_ruby ]
      return RUBY_OPERATOR[@operator] % 
        { l: @left.to_ruby, r: @right.to_ruby, m: @mask, s: @sign_fix }
    end

    # Convert to C code.
    def to_c
      return C_OPERATOR[@operator] % [ @left.to_c, @right.to_c ]
    end
  end
  
  # Describes the software implementation of an select operation.
  class Select < Expression
    # Create a new select operation with +type+ data type,
    # selection operand +sel+ and possible choices +choices+.
    def initialize(type,operator,sel,*choices)
      super(type)
      @sel = sel.to_expr
      @choices = choices.map(&:to_expr)
    end

    # Convert to Ruby code.
    def to_ruby
      return "case(#{@sel.to_}) ; " +
        @choices.map.with_index do |choice,i|
          "when #{i} ; #{choice.to_ruby} ; "
        end.join + "end"
    end

    # Convert to C code.
    def to_c
      return "switch(#{@sel.to_c}) {\n" +
        @choices.map.with_index do |choice,i|
          "case #{i}:\n#{choice.to_c}\nbreak;"
        end.join("\n") + "\n}"
    end
  end

  # Describes a SW implementation of a reference.
  class Ref < Expression
    def to_ref
      return self
    end

    # Get the final base: by default self.
    def final_base
      return self
    end

    # # Get the final first index of the range, by default: 0
    # def final_first
    #   return 0
    # end

    # # Get the final range, by default: @type.width-1..0
    # def final_range
    #   (@type.width-1)..0
    # end
  end

  # Describes a SW implementation of a reference by name.
  class RefName < Ref
    # Create a new named reference with +type+ data type and +name+ name.
    def initialize(type,name)
      super(type)
      @name = name.to_sym
    end

    # Convert to Ruby code.
    def to_ruby
      return @name.to_s
    end

    # Convert to C code.
    alias_method :to_c, :to_ruby
  end

  # Describes a SW implementation of an index reference.
  class RefIndex < Ref
    attr_reader :base

    # Create a new index reference with +type+ data type +base+ base
    # reference and +idx+ index.
    def initialize(type,base,idx)
      super(type)
      @base = base.to_expr
      @idx = idx.to_expr
    end

    # Get the final base object of the binary if it is an [] operator.
    def final_base
      if @base.is_a?(Ref) then
        return @base.final_base
      else
        return @base
      end
    end

    # # Get the final first index.
    # def final_first
    #   btyp = @base.type.base
    #   idx = @base.type.dir <= 0 ? @idx : -@idx
    #   # Compute the current access range.
    #   first = idx*btyp.width
    #   # Position it if there are upper ref access.
    #   if @base.is_a?(Ref) then
    #     first += @base.final_first
    #   end
    #   return first
    # end

    # # Get the final access range.
    # def final_range
    #   btyp = @base.type.base
    #   idx = @base.type.dir <= 0 ? @idx : -@idx
    #   # Compute the current access range.
    #   rng = ((idx+1)*btyp.width-1)..(idx*btyp.width)
    #   # Position it if there are upper ref access.
    #   if @base.is_a?(Ref) then
    #     rng.first += @base.final_first
    #     rng.last  += @base.final_first
    #   end
    #   return rng
    # end
    
    # Get the access range.
    def range
      return @idx..@idx
    end

    # Convert to Ruby code.
    def to_ruby
      return "#{@base.to_ruby}[#{@idx.to_ruby}]"
    end

    # Convert to C code.
    def to_c
      return "#{@base.to_c}[#{@idx.to_c}]"
    end
  end

  # Describes a SW implementation of an range reference.
  class RefRange < Ref
    attr_reader :base

    # Create a new index reference with +type+ data type +base+ base
    # reference and +rng+ range.
    def initialize(type,base,rng)
      super(type)
      @base = base.to_ref
      @rng = (rng.first.to_expr)..(rng.last.to_expr)
    end

    # Get the access range.
    def range
      return @rng.first..@rng.last
    end

    # Get the final base object of the binary if it is an [] operator.
    def final_base
      if @base.is_a?(Ref) then
        return @base.final_base
      else
        return @base
      end
    end

    # # Get the final first index.
    # def final_first
    #   btyp = @base.type.base
    #   idx = @base.type.dir <= 0 ? @rng.first : @rng.last
    #   # Compute the current access range.
    #   first = idx*btyp.width
    #   # Position it if there are upper ref access.
    #   if @base.is_a?(Ref) then
    #     first += @base.final_first
    #   end
    #   return first
    # end

    # # Get the final access range.
    # def final_range
    #   btyp = @base.type.base
    #   rng = @base.type.dir <= 0 ? @rng : @rng.last..@rng.first
    #   # Compute the current access range.
    #   rng = ((rng.first+1)*btyp.width-1)..(rng.last*btyp.width)
    #   # Position it if there are upper ref access.
    #   if @base.is_a?(Ref) then
    #     rng.first += @base.final_first
    #     rng.last  += @base.final_first
    #   end
    #   return rng
    # end

    # Convert to Ruby code.
    def to_ruby
      return "#{@base.to_ruby}[#{@rng.first.to_ruby}..#{@rng.last.to_ruby}]"
    end

    # Convert to C code.
    def to_c
      if @base.type.base.is_a?(TypeVector) then
        raise "Range access not supported yet for arrays."
      else
        # Compute the writing and clearing masks
        smask = (1.to_value<<(@rng.first+1-@rng.last))-1
        cmask = ~(smask << @rng.last)
        # Get the final base.
        base = @base.final_base.to_c
        # Generate the ruby code.
        return "(#{base} & #{cmask.to_c}) >> (#{@rng.last.to_c})"
      end
    end
  end

 
  # Describes a SW implementation of a statement.
  class Statement

    # Iterate on the statements.
    def each_statement(&ruby_block)
      return to_enum(:each_statement) unless ruby_block
      # By default nothing to do.
    end

    # Iterate deeply on the statements.
    def each_statement_deep(&ruby_block)
      return to_enum(:each_statement_deep) unless ruby_block
      # Just apply ruby_block on self.
      ruby_block.call(self)
    end
  end


  # Describes a SW implementation of a transmit statement.
  class Transmit < Statement
    using RubyHDL::High

    attr_reader :left, :right

    # Create a new transmit statement with left value +left+ and
    # right value +right+.
    def initialize(left,right)
      @left = left.to_expr
      @right = right.to_expr
      # Add the transmit to the top SW block.
      # (It will be removed after if it was actually a comparison).
      RubyHDL::High.top_sblock << self
    end

    # Convert to expression: transforms the transmit to a comparison.
    def to_expr
      # Remove the transmit from the top SW block.
      RubyHDL::High.top_sblock.delete(self)
      # And convert it to a comparison.
      return Binary.new(@left.type,@left,@right)
    end

    # Convert to Ruby code.
    def to_ruby
      if (@left.is_a?(RefIndex) or @left.is_a?(RefRange)) then
        if @left.base.type.base.is_a?(TypeVector) then
          # Assign inside array.
          base = @left.final_base.to_ruby
          return "#{base} ||= []; #{@left.to_ruby} = #{@right.to_ruby}"
        else
          # Get the access range.
          rng = @left.range
          # Compute the writing and clearing masks
          smask = (1.to_value<<(rng.first+1-rng.last))-1
          cmask = ~(smask << rng.last)
          # Get the final base.
          base = left.final_base.to_ruby
          # Generate the ruby code.
          return "#{base} &= #{cmask.to_ruby}; " +
            "#{base} |= (((#{@right.to_ruby} & #{smask.to_ruby}) << (#{rng.last.to_ruby})))"
        end
      else
        return "#{@left.to_ruby} = #{@right.to_ruby}"
      end
    end

    # Convert to C code.
    def to_c
      if (@left.is_a?(RefIndex) or @left.is_a?(RefRange)) then
        if @left.base.type.base.is_a?(TypeVector) then
          return "#{@left.to_c} = #{@right.to_c}"
        else
          # Get the access range.
          rng = @left.range
          # Compute the writing and clearing masks
          smask = (1.to_value<<(rng.first+1-rng.last))-1
          cmask = ~(smask << rng.last)
          # Get the final base.
          base = left.final_base.to_c
          # Generate the ruby code.
          return "#{base} &= #{cmask.to_c}; " +
            "#{base} |= (((#{@right.to_c} & #{smask.to_c}) << (#{rng.last.to_c})))"
        end
      else
        return "#{@left.to_c} = #{@right.to_c};"
      end
    end  
  end

  # Describes a SW implementation of a if statement.
  class Sif < Statement
    # Create a new if statement in sequencer +sequencer+ 
    # with +cond+ condition and +ruby_block+
    # for generating the block that is taken if the condition is met.
    def initialize(sequencer,cond, &ruby_block)
      @sequencer = sequencer
      @condition = cond.to_expr
      @yes_blk = Sblock.new(@sequencer,&ruby_block)
      @elsifs = []
      @else_blk = nil
    end

    # Add a selsif case.
    def selsif(cond,&ruby_block)
      @elsifs << [cond,Sblock.new(@sequencer,&ruby_block)]
    end

    # Sets the else block.
    def selse(&ruby_block)
      @else_blk = Sblock.new(@sequencer,&ruby_block)
    end

    # Iterate on the statements.
    def each_statement(&ruby_block)
      return to_enum(:each_statement) unless ruby_block
      # Apply ruby_block on the yes block.
      ruby_block.call(@yes_blk)
      # On the elsifs.
      @elsifs.each { |cond,statement| ruby_block.call(statement) }
      # On the else if any.
      ruby_block.call(@else_blk) if @else_blk
    end

    # Iterate deeply on the statements.
    def each_statement_deep(&ruby_block)
      return to_enum(:each_statement_deep) unless ruby_block
      # Recurse on the yes block.
      @yes_blk.each_statement_deep
      # On the elsifs.
      @elsifs.each { |cond,statement| statement.each_statement_deep }
      # On the else if any.
      @else_blk.each_statement_deep if @else_blk
      # And apply ruby_block on self.
      ruby_block.call(self)
    end

    # Convert to Ruby code.
    def to_ruby
      res = @sequencer.clk_up + "\nif(#{@condition.to_ruby} != 0)\n#{@yes_blk.to_ruby}\n"
      @elsifs.each do |(cond,blk)|
        res << "elsif(#{cond.to_ruby})\n#{blk.to_ruby}\n"
      end
      if @else_blk then
        res << "else\n#{@else_blk.to_ruby}\n"
      end
      return res + "end\n" + @sequencer.clk_up
    end

    # Convert to C code.
    def to_c
      res = @sequencer.clk_up + "\nif(#{@condition.to_c}) {\n#{@yes_blk.to_c}\n}"
      @elsifs.each do |(cond,blk)|
        res << "\nelse if(#{cond.to_c}) {\n#{blk.to_c}\n}"
      end
      if @else_blk then
        res << "\nelse {\n#{@else_blk.to_c}\n}"
      end
      return res + @sequencer.clk_up_c
    end
  end

  # Describes a SW implementation of a loop statement.
  class Sloop < Statement
    # Create a new infinite loop statement in sequencer +sequencer+ 
    # with +ruby_block+ for generating the block that is taken.
    def initialize(sequencer, &ruby_block)
      @sequencer = sequencer
      @blk = Sblock.new(sequencer,&ruby_block)
    end

    # Iterate on the statements.
    def each_statement(&ruby_block)
      return to_enum(:each_statement) unless ruby_block
      # Apply ruby_block on the block.
      ruby_block.call(@blk)
    end

    # Iterate deeply on the statements.
    def each_statement_deep(&ruby_block)
      return to_enum(:each_statement_deep) unless ruby_block
      # Recurse on the block.
      @blk.each_statement_deep
      # And apply ruby_block on self.
      ruby_block.call(self)
    end

    # Convert to Ruby code.
    def to_ruby
      return "loop do\n#{@blk.to_ruby}\n#{@sequencer.clk_up}\nend"
    end

    # Convert to C code.
    def to_c
      return "for(;;){\n#{@blk.to_ruby}\n#{@sequencer.clk_up_c}\n}"
    end
  end

  # Describes a SW implementation of a while statement.
  class Swhile < Statement
    # Create a new while statement in sequencer +sequencer+ 
    # with +cond+ condition and +ruby_block+
    # for generating the block that is taken while the condition is met.
    def initialize(sequencer,cond, &ruby_block)
      @sequencer = sequencer
      @condition = cond.to_expr
      @yes_blk = Sblock.new(sequencer,&ruby_block)
    end

    # Iterate on the statements.
    def each_statement(&ruby_block)
      return to_enum(:each_statement) unless ruby_block
      # Apply ruby_block on the block.
      ruby_block.call(@yes_blk)
    end

    # Iterate deeply on the statements.
    def each_statement_deep(&ruby_block)
      return to_enum(:each_statement_deep) unless ruby_block
      # Recurse on the yes block.
      @yes_blk.each_statement_deep
      # And apply ruby_block on self.
      ruby_block.call(self)
    end

    # Convert to Ruby code.
    def to_ruby
      return @sequencer.clk_up + 
        "\nwhile(#{@condition.to_ruby}) do\n#{@yes_blk.to_ruby}\n#{@sequencer.clk_up}\nend"
    end

    # Convert to C code.
    def to_c
        "\nwhile(#{@condition.to_c}) {\n#{@yes_blk.to_c}\n#{@sequencer.clk_up_c}\n}"
    end
  end

  # Describes a SW implementation of a step statement.
  class Step < Statement
    # Create a new step statement in sequencer +sequencer+.
    def initialize(sequencer)
      @sequencer = sequencer
    end

    # Convert to Ruby code.
    def to_ruby
      return @sequencer.clk_up
    end

    # Convert to C code.
    def to_c
      return @sequencer.clk_up_c
    end
  end

  # Describes a SW implementation of a break statement.
  class Sbreak < Statement
    # Create a new break statement in sequencer +sequencer+.
    def initialize(sequencer)
      @sequencer = sequencer
    end

    # Convert to Ruby code.
    def to_ruby
      return @sequencer.clk_up + "\nbreak"
    end

    # Convert to C code.
    def to_c
      return @sequencer.clk_up_c + "\nbreak;"
    end
  end

  # Describes a SW implementation of a continue statement.
  class Scontinue < Statement
    # Create a new break statement in sequencer +sequencer+.
    def initialize
      @sequencer = sequencer
    end

    # Convert to Ruby code.
    def to_ruby
      return @sequencer.clk_up + "\ncontinue"
    end

    # Convert to Ruby code.
    def to_c
      return @sequencer.clk_up_c + "\ncontinue;"
    end
  end

  # Describes a SW implementation of a return statement.
  class Sreturn < Statement
    attr_reader :value

    # Create a new break statement in sequencer +sequencer+ 
    # returning value +val+.
    def initialize(sequencer,val)
      @sequencer = sequencer
      @value = val
    end

    # Convert to Ruby code.
    def to_ruby
      return @sequencer.clk_up + "\nreturn #{@value.to_ruby}"
    end

    # Convert to Ruby code.
    def to_c
      return @sequencer.clk_up_c + "\nreturn #{val.to_c};"
    end
  end

  # Describes a SW implementation of a terminate statement.
  class Sterminate < Statement
    # Create a new break statement in sequencer +sequencer+.
    def initialize(sequencer)
      @sequencer = sequencer
    end

    # Convert to Ruby code.
    def to_ruby
      # Implemented as returning from a function since a sequencer
      # is implemented as one.
      return @sequencer.clk_up + "\nreturn"
    end

    # Convert to C code.
    def to_c
      return @sequencer.clk_up_c + "\nreturn;"
    end
  end

  # Describes a SW synchronization of a signal.
  class Sync < Statement
    def initialize(sequencer)
      @sequencer = sequencer
    end

    # Convert to Ruby code.
    def to_ruby
      # Update the inputs and outputs.
      res = ""
      RubyHDL::High.global_sblock.each_signal do |signal|
        case signal.dir
        when :input
          res << signal.to_ruby + " = RubyHDL.#{signal.name}\n"
        when :output
          res << "RubyHDL.#{signal.name} = " + signal.to_ruby + "\n"
        end
      end
      res << "Fiber.yield"
      return res
    end

    # Convert to C code.
    def to_c
      return "yield();"
    end
  end

  # Describes arbitrary code.
  class Ruby < Expression
    @@ruby_blocks = []

    # Create a new ruby code block for either +ruby_block+ or
    # string +str+.
    def initialize(str = nil, &ruby_block)
      @str = str
      # puts "ruby_block=#{ruby_block}"
      # Create the id for the block.
      @id = @@ruby_blocks.size
      # Adds the block.
      if ruby_block then
        @@ruby_blocks << ruby_block
      else
        @@ruby_blocks << proc { TOPLEVEL_BINDING.eval(@str.to_s) }
      end
    end

    # Convert to expression: does not change but remove from the
    # statement list.
    def to_expr
      # Remove the transmit from the top SW block.
      RubyHDL::High.top_sblock.delete(self)
      return self
    end

    # Iterate on the statements.
    def each_statement(&ruby_block)
      return to_enum(:each_statement) unless ruby_block
      # By default nothing to do.
    end

    # Iterate deeply on the statements.
    def each_statement_deep(&ruby_block)
      return to_enum(:each_statement_deep) unless ruby_block
      # Just apply ruby_block on self.
      ruby_block.call(self)
    end

    # Execute a ruby code block for +ruby_block+.
    def self.call(id)
      # puts "id=#{id}"
      @@ruby_blocks[id].call
    end

    # Convert to Ruby code.
    def to_ruby
      # puts caller[0]
      if @str then
        return TOPLEVEL_BINDING.eval(@str)
      else
        return "RubyHDL::High::Ruby.call(#{@id})"
      end
    end

    # Convert to C code.
    def to_c
      return "rb_eval_string(\"#{@str.to_s}\");"
    end
  end


  # Describes a SW implementation of an call statement.
  class Scall < Expression
    using RubyHDL::High

    # Create a new call to function named +func+ statement in 
    # sequencer +sequencer+ with arguments +args+.
    def initialize(func, sequencer, *args)
      super(func.type)
      @sequencer = sequencer
      @name = func.name
      @args = args
    end

    # Iterate on the statements.
    def each_statement(&ruby_block)
      return to_enum(:each_statement) unless ruby_block
      # By default nothing to do.
    end

    # Iterate deeply on the statements.
    def each_statement_deep(&ruby_block)
      return to_enum(:each_statement_deep) unless ruby_block
      # Just apply ruby_block on self.
      ruby_block.call(self)
    end

    # Convert to Ruby code.
    def to_ruby
      return "__#{@name}(" + @args.map {|arg| arg.to_ruby}.join(",") + ")"
    end

    # Convert to C code.
    def to_c
      return "\n__#{name}(" + @args.map {|arg| arg.to_ruby}.join(",") + ");"
    end

    # Create an iterator for a given method +meth+.
    def make_iterator(meth,*args,&ruby_block)
      if ruby_block then
        blk = Sblock.new(@sequencer,&ruby_block)
        command = RubyHDL::High::Ruby.new do
          "#{meth}(#{args.map{|arg| arg.to_ruby}.join(",")}) { #{blk.to_ruby} }"
        end
      else
        command = RubyHDL::High::Ruby.new do
          "#{meth}(#{args.map{|arg| arg.to_ruby}.join(",")})"
        end
      end
      return Iter.new(@sequencer,*self.commands,command,&ruby_block)
    end

    # The iterator methods.

    # Iterator on each of the elements in range +rng+.
    # *NOTE*: 
    #   - Stop iteration when the end of the range is reached or when there
    #     are no elements left
    #   - This is not a method from Ruby but one specific for hardware where
    #     creating a array is very expensive.
    def seach_range(rng,&ruby_block)
      return self.make_iterator("each_range",rng,&ruby_block)
    end

    # Tell if all the elements respect a given criterion given either
    # as +arg+ or as block.
    def sall?(arg = nil,&ruby_block)
      return self.make_iterator("all?",arg,&ruby_block)
    end

    # Tell if any of the elements respects a given criterion given either
    # as +arg+ or as block.
    def sany?(arg = nil,&ruby_block)
      return self.make_iterator("any?",arg,&ruby_block)
    end

    # Returns an SEnumerator generated from current enumerable and +arg+
    def schain(arg)
      return self.make_iterator("chain",arg)
    end

    # HW implementation of the Ruby chunk.
    # NOTE: to do, or may be not.
    def schunk(*args,&ruby_block)
      raise "schunk is not supported yet."
    end

    # HW implementation of the Ruby chunk_while.
    # NOTE: to do, or may be not.
    def schunk_while(*args,&ruby_block)
      raise "schunk_while is not supported yet."
    end

    # Returns a vector containing the execution result of the given block 
    # on each element. If no block is given, return an SEnumerator.
    # NOTE: be carful that the resulting vector can become huge if there
    # are many element.
    def smap(&ruby_block)
      return self.make_iterator("map",&ruby_block)
    end

    # HW implementation of the Ruby flat_map.
    # NOTE: actually due to the way HDLRuby handles vectors, should work
    #       like smap
    def sflat_map(&ruby_block)
      return self.make_iterator("flat_map",&ruby_block)
    end

    # HW implementation of the Ruby compact, but remove 0 values instead
    # on nil (since nil that does not have any meaning in HW).
    def scompact
      return self.make_iterator("compact",&ruby_block)
    end


    # WH implementation of the Ruby count.
    def scount(obj = nil, &ruby_block)
      return self.make_iterator("count",obj,&ruby_block)
    end

    # HW implementation of the Ruby cycle.
    def scycle(n = nil,&ruby_block)
      return self.make_iterator("cycle",n,&ruby_block)
    end

    # HW implementation of the Ruby find.
    # NOTE: contrary to Ruby, if_none_proc is mandatory since there is no
    #       nil in HW. Moreover, the argument can also be a value.
    def sfind(if_none_proc, &ruby_block)
      return self.make_iterator("find",if_none_proc,&ruby_block)
    end

    # HW implementation of the Ruby drop.
    def sdrop(n)
      return self.make_iterator("drop",n)
    end

    # HW implementation of the Ruby drop_while.
    def sdrop_while(&ruby_block)
      return self.make_iterator("drop_while",&ruby_block)
    end

    # HW implementation of the Ruby each_cons
    def seach_cons(n,&ruby_block)
      return self.make_iterator("each_cons",n,&ruby_block)
    end

    # HW implementation of the Ruby each_entry.
    # NOTE: to do, or may be not.
    def seach_entry(*args,&ruby_block)
      raise "seach_entry is not supported yet."
    end

    # HW implementation of the Ruby each_slice
    def seach_slice(n,&ruby_block)
      return self.make_iterator("each_slice",n,&ruby_block)
    end

    # HW implementation of the Ruby each_with_index.
    def seach_with_index(*args,&ruby_block)
      return self.make_iterator("each_with_index",*args,&ruby_block)
    end

    # HW implementation of the Ruby each_with_object.
    def seach_with_object(obj,&ruby_block)
      return self.make_iterator("each_with_object",obj,&ruby_block)
    end

    # HW implementation of the Ruby to_a.
    def sto_a
      return self.make_iterator("to_a")
    end

    # HW implementation of the Ruby select.
    def sselect(&ruby_block)
      return self.make_iterator("select",&ruby_block)
    end

    # HW implementation of the Ruby find_index.
    def sfind_index(obj = nil, &ruby_block)
      return self.make_iterator("find_index",obj,&ruby_block)
    end

    # HW implementation of the Ruby first.
    def sfirst(n=1)
      return self.make_iterator("first",n)
    end

    # HW implementation of the Ruby grep.
    # NOTE: to do, or may be not.
    def sgrep(*args,&ruby_block)
      raise "sgrep is not supported yet."
    end

    # HW implementation of the Ruby grep_v.
    # NOTE: to do, or may be not.
    def sgrep_v(*args,&ruby_block)
      raise "sgrep_v is not supported yet."
    end

    # HW implementation of the Ruby group_by.
    # NOTE: to do, or may be not.
    def sgroup_by(*args,&ruby_block)
      raise "sgroup_by is not supported yet."
    end

    # HW implementation of the Ruby include?
    def sinclude?(obj)
      return self.make_iterator("include?",obj)
    end

    # HW implementation of the Ruby inject.
    def sinject(*args,&ruby_block)
      return self.make_iterator("inject",*args,&ruby_block)
    end

    # HW implementation of the Ruby reduce.
    def sreduce
      return self.make_iterator("reduce",*args,&ruby_block)
    end


    # HW implementation of the Ruby lazy.
    # NOTE: to do, or may be not.
    def slazy(*args,&ruby_block)
      raise "slazy is not supported yet."
    end

    # HW implementation of the Ruby max.
    def smax(n = nil, &ruby_block)
      return self.make_iterator("max",n,&ruby_block)
    end

    # HW implementation of the Ruby max_by.
    def smax_by(n = nil, &ruby_block)
      return self.make_iterator("max_by",n,&ruby_block)
    end

    # HW implementation of the Ruby min.
    def smin(n = nil, &ruby_block)
      return self.make_iterator("min",n,&ruby_block)
    end

    # HW implementation of the Ruby min_by.
    def smin_by(n = nil, &ruby_block)
      return self.make_iterator("min_by",n,&ruby_block)
    end

    # HW implementation of the Ruby minmax.
    def sminmax(&ruby_block)
      return self.make_iterator("minmax",&ruby_block)
    end

    # HW implementation of the Ruby minmax_by.
    def sminmax_by(&ruby_block)
      return self.make_iterator("minmax_by",&ruby_block)
    end

    # Tell if none of the elements respects a given criterion given either
    # as +arg+ or as block.
    def snone?(arg = nil,&ruby_block)
      return self.make_iterator("none?",arg,&ruby_block)
    end

    # Tell if one and only one of the elements respects a given criterion
    # given either as +arg+ or as block.
    def sone?(arg = nil,&ruby_block)
      return self.make_iterator("one?",arg,&ruby_block)
    end

    # HW implementation of the Ruby partition.
    # NOTE: to do, or may be not.
    def spartition(*args,&ruby_block)
      raise "spartition is not supported yet."
    end

    # HW implementatiob of the Ruby reject.
    def sreject(&ruby_block)
      return self.make_iterator("reject",&ruby_block)
    end

    # HW implementatiob of the Ruby reverse_each.
    def sreverse_each(*args,&ruby_block)
      return self.make_iterator("reverse_each",*args,&ruby_block)
    end

    # HW implementation of the Ruby slice_after.
    # NOTE: to do, or may be not.
    def sslice_after(pattern = nil,&ruby_block)
      raise "sslice_after is not supported yet."
    end

    # HW implementation of the Ruby slice_before.
    # NOTE: to do, or may be not.
    def sslice_before(*args,&ruby_block)
      raise "sslice_before is not supported yet."
    end

    # HW implementation of the Ruby slice_when.
    # NOTE: to do, or may be not.
    def sslice_when(*args,&ruby_block)
      raise "sslice_before is not supported yet."
    end

    # Merge two arrays in order, for ssort only.
    def ssort_merge(arI, arO, first, middle, last, &ruby_block)
      return self.make_iterator("sort_merge",arI,arO,first,middle,last,&ruby_block)
    end

    # HW implementation of the Ruby sort.
    def ssort(&ruby_block)
      return self.make_iterator("sort",&ruby_block)
    end

    # HW implementation of the Ruby sort.
    def ssort_by(&ruby_block)
      return self.make_iterator("sort_by",&ruby_block)
    end

    # HW implementation of the Ruby sum.
    def ssum(initial_value = nil,&ruby_block)
      return self.make_iterator("sum",initial_value,&ruby_block)
    end

    # The HW implementation of the Ruby take.
    def stake(n)
      return self.make_iterator("take",n)
    end

    # The HW implementation of the Ruby take_while.
    def stake_while(&ruby_block)
      return self.make_iterator("take_while",&ruby_block)
    end

    # HW implementation of the Ruby tally.
    # NOTE: to do, or may be not.
    def stally(h = nil)
      raise "stally is not supported yet."
    end

    # HW implementation of the Ruby to_h.
    # NOTE: to do, or may be not.
    def sto_h(h = nil)
      raise "sto_h is not supported yet."
    end

    # HW implementation of the Ruby uniq.
    def suniq(&ruby_block)
      return self.make_iterator("uniq",&ruby_block)
    end

    # HW implementation of the Ruby zip.
    # NOTE: for now szip is deactivated untile tuples are properly
    #       handled by HDLRuby.
    def szip(obj,&ruby_block)
      return self.make_iterator("zip",obj,&ruby_block)
    end

    # Iterator on the +num+ next elements.
    # *NOTE*:
    #   - Stop iteration when the end of the range is reached or when there
    #     are no elements left
    #   - This is not a method from Ruby but one specific for hardware where
    #     creating a array is very expensive.
    def seach_nexts(num,&ruby_block)
      return self.seach.snexts(num,&ruby_block)
    end
  end


  # Describes a SW implementation of an iterator statement.
  class Siter < Statement
    using RubyHDL::High

    # Create a new iteration statement in sequencer +sequencer+ 
    # for chain of commands +commands+ to interate while
    # executing +ruby_block+.
    def initialize(sequencer,*commands, &ruby_block)
      @sequencer = sequencer
      @commands = commands
      if ruby_block then
        # The iterator is finalized.
        @blk = Sblock.new(sequencer,&ruby_block)
      end
      # puts "New iterator with blk=#{@blk} commands=#{@commands}"
    end

    # Iterate on the commands.
    def each_command(&ruby_block)
      return to_enum(:each_command) unless ruby_block
      @commands.each(&ruby_block)
    end
    alias_method :each, :each_command

    # Iterate on the statements.
    def each_statement(&ruby_block)
      return to_enum(:each_statement) unless ruby_block
      # Apply ruby_block on the block.
      @blk.each_statement(&ruby_block)
    end

    # Iterate deeply on the statements.
    def each_statement_deep(&ruby_block)
      return to_enum(:each_statement_deep) unless ruby_block
      # Recurse on the yes block.
      @blk.each_statement_deep
      # And apply ruby_block on self.
      ruby_block.call(self)
    end

    # Convert to Ruby code.
    def to_ruby
      # puts "to_ruby with blk=#{@blk} commands=#{@commands}"
      res = @sequencer.clk_up + "\n" + 
        @commands.map { |command| command.to_ruby }.join(".") 
      return res + " do" + 
        (@blk.each_arg.any? ? 
         "|#{@blk.each_arg.map(&:to_ruby).join(",")}|" : "") + 
        "\n#{@blk.to_ruby}\n#{@sequencer.clk_up}\nend"
    end

    # Convert to C code.
    def to_c
      res = @sequencer.clk_up_c + "\n" +
        @commands.map { |command| command.to_c }.join("_")
      return res + "(#{@blk.to_c})"
    end

    # Create an iterator for a given method +meth+.
    def make_iterator(meth,*args,&ruby_block)
      # if ruby_block then
      #   blk = Sblock.new(@sequencer,&ruby_block)
      #   command = RubyHDL::High::Ruby.new do
      #     "#{meth}(#{args.map{|arg| arg.to_ruby}.join(",")}) { #{blk.to_ruby} }"
      #   end
      # else
      #   command = RubyHDL::High::Ruby.new do
      #     "#{meth}(#{args.map{|arg| arg.to_ruby}.join(",")})"
      #   end
      # end
      command = "#{meth}"
      if args.any? then
        command += "(*#{RubyHDL::High::Ruby.new {
        "#{args.map{|arg| arg.to_ruby}.join(",")}"}})"
      end
      return Siter.new(@sequencer,*@commands,command,&ruby_block)
    end

    # The iterator methods.

    # Iterator on each of the elements in range +rng+.
    # *NOTE*: 
    #   - Stop iteration when the end of the range is reached or when there
    #     are no elements left
    #   - This is not a method from Ruby but one specific for hardware where
    #     creating a array is very expensive.
    def seach_range(rng,&ruby_block)
      return self.make_iterator("each_range",rng,&ruby_block)
    end

    # Tell if all the elements respect a given criterion given either
    # as +arg+ or as block.
    def sall?(arg = nil,&ruby_block)
      return self.make_iterator("all?",arg,&ruby_block)
    end

    # Tell if any of the elements respects a given criterion given either
    # as +arg+ or as block.
    def sany?(arg = nil,&ruby_block)
      return self.make_iterator("any?",arg,&ruby_block)
    end

    # Returns an SEnumerator generated from current enumerable and +arg+
    def schain(arg)
      return self.make_iterator("chain",arg)
    end

    # HW implementation of the Ruby chunk.
    # NOTE: to do, or may be not.
    def schunk(*args,&ruby_block)
      raise "schunk is not supported yet."
    end

    # HW implementation of the Ruby chunk_while.
    # NOTE: to do, or may be not.
    def schunk_while(*args,&ruby_block)
      raise "schunk_while is not supported yet."
    end

    # Returns a vector containing the execution result of the given block 
    # on each element. If no block is given, return an SEnumerator.
    # NOTE: be carful that the resulting vector can become huge if there
    # are many element.
    def smap(&ruby_block)
      return self.make_iterator("map",&ruby_block)
    end

    # HW implementation of the Ruby flat_map.
    # NOTE: actually due to the way HDLRuby handles vectors, should work
    #       like smap
    def sflat_map(&ruby_block)
      return self.make_iterator("flat_map",&ruby_block)
    end

    # HW implementation of the Ruby compact, but remove 0 values instead
    # on nil (since nil that does not have any meaning in HW).
    def scompact
      return self.make_iterator("compact",&ruby_block)
    end


    # WH implementation of the Ruby count.
    def scount(obj = nil, &ruby_block)
      return self.make_iterator("count",obj,&ruby_block)
    end

    # HW implementation of the Ruby cycle.
    def scycle(n = nil,&ruby_block)
      return self.make_iterator("cycle",n,&ruby_block)
    end

    # HW implementation of the Ruby find.
    # NOTE: contrary to Ruby, if_none_proc is mandatory since there is no
    #       nil in HW. Moreover, the argument can also be a value.
    def sfind(if_none_proc, &ruby_block)
      return self.make_iterator("find",if_none_proc,&ruby_block)
    end

    # HW implementation of the Ruby drop.
    def sdrop(n)
      return self.make_iterator("drop",n)
    end

    # HW implementation of the Ruby drop_while.
    def sdrop_while(&ruby_block)
      return self.make_iterator("drop_while",&ruby_block)
    end

    # HW implementation of the Ruby each_cons
    def seach_cons(n,&ruby_block)
      return self.make_iterator("each_cons",n,&ruby_block)
    end

    # HW implementation of the Ruby each_entry.
    # NOTE: to do, or may be not.
    def seach_entry(*args,&ruby_block)
      raise "seach_entry is not supported yet."
    end

    # HW implementation of the Ruby each_slice
    def seach_slice(n,&ruby_block)
      return self.make_iterator("each_slice",n,&ruby_block)
    end

    # HW implementation of the Ruby each_with_index.
    def seach_with_index(*args,&ruby_block)
      return self.make_iterator("each_with_index",*args,&ruby_block)
    end
    alias_method :with_index, :seach_with_index

    # HW implementation of the Ruby each_with_object.
    def seach_with_object(obj,&ruby_block)
      return self.make_iterator("each_with_object",obj,&ruby_block)
    end

    # HW implementation of the Ruby to_a.
    def sto_a
      return self.make_iterator("to_a")
    end

    # HW implementation of the Ruby select.
    def sselect(&ruby_block)
      return self.make_iterator("select",&ruby_block)
    end

    # HW implementation of the Ruby find_index.
    def sfind_index(obj = nil, &ruby_block)
      return self.make_iterator("find_index",obj,&ruby_block)
    end

    # HW implementation of the Ruby first.
    def sfirst(n=1)
      return self.make_iterator("first",n)
    end

    # HW implementation of the Ruby grep.
    # NOTE: to do, or may be not.
    def sgrep(*args,&ruby_block)
      raise "sgrep is not supported yet."
    end

    # HW implementation of the Ruby grep_v.
    # NOTE: to do, or may be not.
    def sgrep_v(*args,&ruby_block)
      raise "sgrep_v is not supported yet."
    end

    # HW implementation of the Ruby group_by.
    # NOTE: to do, or may be not.
    def sgroup_by(*args,&ruby_block)
      raise "sgroup_by is not supported yet."
    end

    # HW implementation of the Ruby include?
    def sinclude?(obj)
      return self.make_iterator("include?",obj)
    end

    # HW implementation of the Ruby inject.
    def sinject(*args,&ruby_block)
      return self.make_iterator("inject",*args,&ruby_block)
    end

    # HW implementation of the Ruby reduce.
    def sreduce
      return self.make_iterator("reduce",*args,&ruby_block)
    end


    # HW implementation of the Ruby lazy.
    # NOTE: to do, or may be not.
    def slazy(*args,&ruby_block)
      raise "slazy is not supported yet."
    end

    # HW implementation of the Ruby max.
    def smax(n = nil, &ruby_block)
      return self.make_iterator("max",n,&ruby_block)
    end

    # HW implementation of the Ruby max_by.
    def smax_by(n = nil, &ruby_block)
      return self.make_iterator("max_by",n,&ruby_block)
    end

    # HW implementation of the Ruby min.
    def smin(n = nil, &ruby_block)
      return self.make_iterator("min",n,&ruby_block)
    end

    # HW implementation of the Ruby min_by.
    def smin_by(n = nil, &ruby_block)
      return self.make_iterator("min_by",n,&ruby_block)
    end

    # HW implementation of the Ruby minmax.
    def sminmax(&ruby_block)
      return self.make_iterator("minmax",&ruby_block)
    end

    # HW implementation of the Ruby minmax_by.
    def sminmax_by(&ruby_block)
      return self.make_iterator("minmax_by",&ruby_block)
    end

    # Tell if none of the elements respects a given criterion given either
    # as +arg+ or as block.
    def snone?(arg = nil,&ruby_block)
      return self.make_iterator("none?",arg,&ruby_block)
    end

    # Tell if one and only one of the elements respects a given criterion
    # given either as +arg+ or as block.
    def sone?(arg = nil,&ruby_block)
      return self.make_iterator("one?",arg,&ruby_block)
    end

    # HW implementation of the Ruby partition.
    # NOTE: to do, or may be not.
    def spartition(*args,&ruby_block)
      raise "spartition is not supported yet."
    end

    # HW implementatiob of the Ruby reject.
    def sreject(&ruby_block)
      return self.make_iterator("reject",&ruby_block)
    end

    # HW implementatiob of the Ruby reverse_each.
    def sreverse_each(*args,&ruby_block)
      return self.make_iterator("reverse_each",*args,&ruby_block)
    end

    # HW implementation of the Ruby slice_after.
    # NOTE: to do, or may be not.
    def sslice_after(pattern = nil,&ruby_block)
      raise "sslice_after is not supported yet."
    end

    # HW implementation of the Ruby slice_before.
    # NOTE: to do, or may be not.
    def sslice_before(*args,&ruby_block)
      raise "sslice_before is not supported yet."
    end

    # HW implementation of the Ruby slice_when.
    # NOTE: to do, or may be not.
    def sslice_when(*args,&ruby_block)
      raise "sslice_before is not supported yet."
    end

    # Merge two arrays in order, for ssort only.
    def ssort_merge(arI, arO, first, middle, last, &ruby_block)
      return self.make_iterator("sort_merge",arI,arO,first,middle,last,&ruby_block)
    end

    # HW implementation of the Ruby sort.
    def ssort(&ruby_block)
      return self.make_iterator("sort",&ruby_block)
    end

    # HW implementation of the Ruby sort.
    def ssort_by(&ruby_block)
      return self.make_iterator("sort_by",&ruby_block)
    end

    # HW implementation of the Ruby sum.
    def ssum(initial_value = nil,&ruby_block)
      return self.make_iterator("sum",initial_value,&ruby_block)
    end

    # The HW implementation of the Ruby take.
    def stake(n)
      return self.make_iterator("take",n)
    end

    # The HW implementation of the Ruby take_while.
    def stake_while(&ruby_block)
      return self.make_iterator("take_while",&ruby_block)
    end

    # HW implementation of the Ruby tally.
    # NOTE: to do, or may be not.
    def stally(h = nil)
      raise "stally is not supported yet."
    end

    # HW implementation of the Ruby to_h.
    # NOTE: to do, or may be not.
    def sto_h(h = nil)
      raise "sto_h is not supported yet."
    end

    # HW implementation of the Ruby uniq.
    def suniq(&ruby_block)
      return self.make_iterator("uniq",&ruby_block)
    end

    # HW implementation of the Ruby zip.
    # NOTE: for now szip is deactivated untile tuples are properly
    #       handled by HDLRuby.
    def szip(obj,&ruby_block)
      return self.make_iterator("zip",obj,&ruby_block)
    end

    # Iterator on the +num+ next elements.
    # *NOTE*:
    #   - Stop iteration when the end of the range is reached or when there
    #     are no elements left
    #   - This is not a method from Ruby but one specific for hardware where
    #     creating a array is very expensive.
    def seach_nexts(num,&ruby_block)
      return self.seach.snexts(num,&ruby_block)
    end
  end


  # Describes a SW implementation of a signal.
  class SignalI < Expression
    using RubyHDL::High
    attr_reader :name, :type, :dir
    # Create a new signal with type +type+ and name +name+.
    def initialize(name,type,dir)
      @name = name.to_sym
      @type = type.to_type
      @dir = dir.to_sym
      # Compute the mask for adjusting the value to the type.
      @mask = (2 ** @type.width)-1
      @sign = 2 ** (@type.width-1)
      @global = "" # The global indicator: empty or '$'
    end

    # Tell if the signal is global or not.
    def global?
      return @global == "$"
    end

    # Set the signal to be a global.
    def global!
      @global = "$"
    end

    # Tell if the signal is an array.
    def array?
      return @type.base.is_a?(TypeVector)
    end

    # Convert to Ruby code.
    def to_ruby
      return @global + "__" + self.name.to_s
    end

    # Convert to C code.
    alias_method :to_c, :to_ruby

    # Check if a value is defined for the signal.
    def value?
      if global? then
        return global_variables.include?(self.to_ruby)
      else
        return TOPLEVEL_BINDING.local_variable_defined?(self.to_ruby)
      end
    end

    # Gets the value of the signal.
    def value
      # return TOPLEVEL_BINDING.eval(self.to_ruby)
      res = TOPLEVEL_BINDING.eval(self.to_ruby)
      if res.is_a?(Integer) then
        res = res & @mask
        if @type.signed? then
          if res & @sign != 0 then
            return res - (@mask+1)
          end
        end
      end
      return res
    end

    # Generate a Ruby/C string code for accessing the value of the 
    # signal with proper bit width and sign.
    def value_text
      unless self.array? then
        if @type.signed? then
          return "(#{self.to_ruby} & #{@sign} != 0 ? #{self.to_ruby} & #{@mask} - #{@mask+1} : #{self.to_ruby} & #{@mask})"
        else
          return "(#{self.to_ruby} & #{@mask})"
        end
      else
        return self.to_ruby
      end
    end

    # Sets the value of the signal.
    def value=(val)
      return TOPLEVEL_BINDING.eval("#{self.to_ruby} = #{val}")
    end

    # Convert to an integer.
    def to_i
      return self.value.to_i
    end

    # Convert to an float.
    def to_f
      return self.value.to_f
    end

    # Convert to a string.
    def to_s
      return self.value.to_s
    end
  end

  # Describes a SW implementation of a block.
  class Sblock < SblockTop
    using RubyHDL::High

    attr_reader :sequencer

    # Create a new block for sequencer +sequencer+ and fill it by 
    # executing +ruby_block+
    def initialize(sequencer,&ruby_block)
      super()
      # Sets the sequencer.
      @sequencer = sequencer
      # Initialize the statements.
      @statements = []
      # Push the new sblock on top of the stack.
      RubyHDL::High.push_sblock(self)
      # Make signals from the arguments of the ruby block.
      # unsigned 32-bit integers by default.
      @args = []
      ruby_block.parameters.each do |typ,arg|
        # @args << SignalI.new(arg,Void,:inner)
        @args << SignalI.new(arg,bit[32],:inner)
      end
      # Fill it.
      self.instance_exec(*@args,&ruby_block)
      # Pop the new sblock.
      RubyHDL::High.pop_sblock
    end

    # Add a new statement to the block.
    def add(statement)
      # Add the statement.
      @statements.push(statement)
      # # If the statement is a transmit, schedule the corresponding
      # # signal for final update.
      # if statement.is_a?(Transmit) then
      #   @sequencer.to_update(statement.left)
      # end
      statement
    end
    alias_method :<<, :add

    # Iterate on the statements.
    def each_statement(&ruby_block)
      return to_enum(:each_statement) unless ruby_block
      @statements.each { |statement| ruby_block(statement) }
    end

    # Iterate deeply on the statements.
    def each_statement_deep(&ruby_block)
      return to_enum(:each_statement_deep) unless ruby_block
      @statements.each do |statement|
        statement.each_statement_deep(&ruby_block)
        ruby_block(statement)
      end
    end

    # Delete a statement.
    def delete(statement)
      @statements.delete(statement)
    end

    # Unshift a new statement.
    def unshift(statement)
      @statements.unshift(statement)
    end

    # Get the last statement.
    def last_statement
      return @statements[-1]
    end

    # Iterate on the arguments if any.
    def each_arg(&ruby_block)
      return to_enum(:each_arg) unless ruby_block
      @args.each(&ruby_block)
    end

    # Convert to Ruby code.
    def to_ruby
      res = ""
      # The arguments are ignored, as they are handled in SfunctionT.
      # # Generate the arguments if any.
      # if @args.any? then
      #   res = "|#{@args.map(&:to_ruby).join(",")}|\n"
      # end
      # Generate the statements.
      res += @statements.map do |stmnt|
        stmnt.to_ruby + "\n"
      end.join
      return res
    end

    # Convert to C code.
    def to_c
      res = ""
      # Generate the arguments if any.
      if @args.any? then
        res = "(#{@args.map(&:to_c).join(",")})\n"
      end
      # Generate the statements.
      res += "{" + @statements.map do |stmnt|
        stmnt.to_ruby + "\n"
      end.join + "}"
      return res
    end

    # The interface for describing statements and expressions.

    # Mark a step.
    def step
      self << RubyHDL::High::Step.new(@sequencer)
    end

    # Mark several steps.
    def steps(num)
      num.times { self.step }
    end

    # Breaks current iteration.
    def sbreak
      self << RubyHDL::High::Sbreak.new(@sequencer)
    end

    # Continues current iteration.
    def scontinue
      self << RubyHDL::High::Scontinue.new(@sequencer)
    end

    # Create a return statement.
    def sreturn(val)
      self << RubyHDL::High::Sreturn.new(@sequencer,val)
    end

    # Terminates the sequencer.
    def sterminate
      self << RubyHDL::High::Sterminate.new(@sequencer)
    end

    # Create a sequential if statement on +cond+.
    def sif(cond, &ruby_block)
      self << RubyHDL::High::Sif.new(@sequencer,cond,&ruby_block)
    end
    alias_method :hif, :sif

    # Create a sequential elsif statement on +cond+.
    def selsif(cond, &ruby_block)
      self.last_statement.selsif(&ruby_block)
    end
    alias_method :helsif, :selsif

    # Create a sequential else statement.
    def selse(&ruby_block)
      self.last_statement.selse(&ruby_block)
    end
    alias_method :helse, :selse

    # Wait a given condition.
    def swait(cond)
      self.swhile(~cond)
    end

    # Create a sequential while statement on +cond+.
    def swhile(cond,&ruby_block)
      self << RubyHDL::High::Swhile.new(@sequencer,cond,&ruby_block)
    end

    # Create a sequential infinite loop statement.
    def sloop(&ruby_block)
      self << RubyHDL::High::Sloop.new(@sequencer,&ruby_block)
    end

    # Create a sequential for statement iterating over the elements
    # of +expr+.
    def sfor(expr,&ruby_block)
      # Ensures there is a ruby block to avoid returning an enumerator
      # (returning an enumerator would be confusing for a for statement).
      ruby_block = proc {} unless ruby_block
      self << expr.seach.with_index(&ruby_block)
    end

    # The SW-specific statements and expressions.
    
    # Mark a synchronisation.
    # For software only: stop the current sequencer for allowing
    # sharing of variables with other ones.
    def sync
      self << RubyHDL::High::Sync.new(@sequencer)
    end

    # Some arbirary Ruby code as a string +str+ or as a proc
    # +ruby_block+.
    def ruby(str = nil, &ruby_block)
      self << RubyHDL::High::Ruby.new(str,&ruby_block)
    end

    # Some arbitrary code whose text is to add direction.
    def text(str)
      self << str.to_s
    end
  end


  # Describes a SW implementation of a sequencer function.
  class SfunctionT
    using RubyHDL::High
    attr_reader :name, :type
    # Create a new named +name+ with arguments +args+ and 
    # executing the content of block +sblock+
    def initialize(name,sblock,*args)
      @name = name.to_sym
      @args  = args
      @blk = sblock
      @type = self.make_return_type(@blk)
    end

    # Compute the return type from current sblock +sblock+
    def make_return_type(sblock)
      # Locate a return statement.
      sblock.each_statement_deep do |statement|
        if statement.is_a?(RubyHDL::High::Sreturn) then
          return statement.value.type
        end
      end
      # No return, so void type.
      return RubyHDL::High::Void
    end

    # Convert to Ruby code.
    def to_ruby
      return "def __#{name}(#{@args.map {|arg| "__" + arg.to_ruby}.join(",")})\n#{@blk.sequencer.clk_up}\n#{@blk.to_ruby}\nend\n"
    end

    # Convert to C code.
    def to_c
      return "unsigned long long __#{name}(#{@args.map {|arg| "unsigned long long " + arg.to_c}.join(",")} {\n#{@blk.sequencer.clk_up_c}\n#{@blk.to_c}\n}\n"
    end
  end


  

  # Describes a SW implementation of a sequencer.
  class SequencerT 

    # The source code (in ruby).
    attr_reader :source

    # The clock counter.
    attr_reader :clk

    # Create a new sequencer block, with clock counter +clk+ and
    # run control +start+.
    # Note: if +clk+ is not provided no clock counter will be generate.
    def initialize(clk = nil, start = nil, &ruby_block)
      # Sets the clock counter and start control.
      @clk = clk
      @start = start
      if @start then
        this = self
        # Make @start a controlling signal.
        @start.define_singleton_method(:<=,val) do
          this.resume if val.to_i == 1
        end
      end
      # Create a set of sfunction used in the sequencer.
      @sfunctions = {}
      # Create the main block.
      @blk = RubyHDL::High::Sblock.new(self,&ruby_block)
      # Build the Ruby code.
      @source = ""
      @code = nil
      self.build_ruby
    end

    # Add a sfunction.
    def add_sfunction(name,sfunction)
      @sfunctions[name.to_sym] = sfunction
    end

    # Check if a sfunction is present.
    def sfunction?(name)
      return @sfunctions.key?(name.to_sym)
    end

    # Get a sfunction by name.
    def sfunction(name)
      return @sfunctions[name.to_sym]
    end

    # Build the ruby code.
    def build_ruby
      this = self
      @source = <<-BUILD
#{RubyHDL::High.global_sblock.each_signal.map do |signal|
      # puts "for signal=#{signal.name} with type=#{signal.type}"
      case signal.dir
      when :input
        signal.to_ruby + " = RubyHDL.#{signal.name}"
      else
        signal.to_ruby + " ||= " + 
        (signal.array? ? "[]" : signal.value? ? signal.value.inspect : "0")
      end
end.join("\n")}

#{@sfunctions.map {|n,f| f.to_ruby }.join("\n\n")}

Fiber.new do
#{@blk.to_ruby}
end
BUILD
      # puts "building code_txt=" + @source
      self.reset!
    end

    # Get the Ruby code.
    def to_ruby
      return @code
    end

    # Convert to C code.
    def to_c
      typ = nil
      res = <<-BUILDC
#{RubyHDL::High.global_sblock.each_signal.map do |signal|
      typ = signal.type
      typ.to_c + " " + signal.to_c + "=" + typ.to_c_init + ";"
end.join("\n")}
#{sblock.to_c}
BUILDC
      return res
    end

    # Handling of the clock if any.

    # Generate a clock up of +count+ cycles if any clock.
    def clk_up(count = 1)
      if @clk then
        return "#{clk.to_ruby} += #{count.to_i}"
      else
        return ""
      end
    end

    # Generate a clock up of +count+ cycles if any clock for C code.
    def clk_up_c(count = 1)
      if @clk then
        return "#{clk.to_c} += #{count.to_i};"
      else
        return ""
      end
    end


    # Control of the sequencer.

    # Executes the sequencer.
    def resume
      # @code.call
      @code.resume
    end
    alias_method :call, :resume

    # Resets the sequencer.
    def reset!
      @code = TOPLEVEL_BINDING.eval(@source)
    end

    # Check is the sequencer can still be resumed.
    def alive?
      @code.alive?
    end

  end





  # Create a new sequencer block, with clock counter +clk+ and
  # run control +start+
  def sequencer(clk = nil, start = nil, &ruby_block)
    # Ensure the clock is global.
    clk.global! if clk
    return SequencerT.new(clk,start,&ruby_block)
  end

  # Create a 1-bit input signal.
  def input(*names)
    return [1].input(*names)
  end

  # Create a 1-bit output signal.
  def output(*names)
    return [1].output(*names)
  end

  # Create a 1-bit inner signal.
  def inner(*names)
    return [1].inner(*names)
  end

  # Create a new function named +name+, built using block +ruby_block+.
  def sdef(name,&ruby_block)
    name = name.to_sym
    # Get the arguments of the ruby_block.
    block_args = ruby_block.parameters.map {|typ,name| name.to_s }
    # Create function.
    cur_sblock = RubyHDL::High.top_sblock
    # Register the call.
    cur_sblock.register(name.to_sym) do |*args|
      # Create the function.
      # Get the current sequencer.
      cur_seq = RubyHDL::High.top_sblock.sequencer
      # Get the function from the sequencer if any.
      function = cur_seq.sfunction(name)
      unless function then
        # There were no function for the sequencer, create it.
        # Execute the ruby block in a sequencer environment for building
        # the sblock.
        sblock = Sblock.new(cur_seq,&ruby_block)
        # Create the arguments.
        block_args.each_with_index do |block_arg,i|
          # puts "args[#{i}]=(#{args[i].name},#{args[i].type})"
          sblock.make_inners(args[i].type,block_arg.to_sym)
        end
        # Create the function.
        function = SfunctionT.new(name,sblock,*block_args)
        # Add it to the current sequencer.
        cur_seq.add_sfunction(name,function)
      end
      # And create the call
      Scall.new(function,cur_seq,*args)
    end
  end

end



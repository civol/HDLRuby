<h1>HDLRuby Tutorial for software people (<em>and hardware people too</em>)</h1>
<p>In this tutorial, you will learn the basics about the description of digital circuits using HDLRuby from the software point of view. In detail you will learn:</p>
<ol>
<li><p><a href="#1-what-is-hdlruby-and-how-to-use-its-framework">What is HDLRuby and how to use its framework.</a></p>
</li>
<li><p><a href="#2-how-to-represent-a-circuit-in-hdlruby">How to represent a circuit.</a></p>
</li>
<li><p><a href="#3-how-to-describe-an-algorithm-to-be-implemented-by-a-circuit">How to describe an algorithm to be implemented by a circuit.</a></p>
</li>
<li><p><a href="#4-how-to-add-parallelism-to-your-algorithms">How to add parallelism to your algorithms.</a></p>
</li>
</ol>
<p>Then, the following section will introduce advanced concepts about hardware design and HDLRuby:</p>
<ol start="5">
<li><p><a href="#5-toward-lower-level-hardware-design-the-processes">Toward lower level hardware design: the processes.</a></p>
</li>
<li><p><a href="#6-not-enough-what-about-genericity-object-orientation-metaprogramming-and-reflection">Not enough? What about genericity, object orientation, metaprogramming, and reflection?</a></p>
</li>
<li><p><a href="#7-how-to-mix-hardware-and-softwware">How to mix hardware and software.</a></p>
</li>
<li><p><a href="#8-how-to-interact-with-the-simulator">How to interact with the simulator.</a></p>
</li>
<li><p><a href="#9-what-about-using-Verilog-hdl-instead">What about using Verilog HDL instead?</a></p>
</li>
</ol>
<p>Within these topics, you will also have an explanation of how the following high-level concepts can be used in HDLRuby:</p>
<ul>
<li><p>Object-oriented programming</p>
</li>
<li><p>Reflection</p>
</li>
<li><p>Genericity</p>
</li>
<li><p>Metaprogramming</p>
</li>
</ul>
<p>But, before going further, here are a few...</p>
<h2>Prerequisites</h2>
<p>Since this tutorial is aimed at software people, it is assumed you have a good understanding of programming and the relevant tools (e.g., editor, compiler). However, it is not assumed that you have any knowledge about digital hardware design. Otherwise, knowing the Ruby programming language is recommended but not mandatory.</p>
<p>To use HDLRuby the following software is required:</p>
<ul>
<li><p>A distribution of the Ruby language.</p>
</li>
<li><p>A text editor. If you like syntax highlighting or other fancy features, please choose one supporting Ruby.</p>
</li>
<li><p>A command line interface (e.g., command prompt, terminal emulator.)</p>
</li>
</ul>
<p>The following software is also recommended:</p>
<ul>
<li>A wave viewer supporting <em>vcd</em> files (e.g., <a href="https://gtkwave.sourceforge.net/">GTKWave</a>, or, <a href="https://civol.github.io/htmlwave/htmlwave.html">HTMLWave</a>)</li>
</ul>
<h2>1. What is HDLRuby and how to use its framework</h2>
<p>HDLRuby is a hardware description language (HDL) based on the Ruby programming language. It is implemented as a Ruby library so that, by construction, any Ruby code can be used and executed within the HDLRuby description.</p>
<p>Before going further, let us briefly explain what is a <a href="#11-what-is-a-hardware-description-language-hdl">HDL</a>. Then, more details will be given about how to <a href="#12-installing-hdlruby">install HDLRuby</a> and how to <a href="#13-using-hdlruby">use it</a>.</p>
<h3>1.1. What is a hardware description language (HDL)</h3>
<p>A hardware description language (HDL) is a formal language that is used for describing electronic circuits. Such circuits can be divided into two categories: analog circuits and digital circuits. While there exists HDL for describing the first category of circuits, a large majority of them only support the second one. Hence, in practice, HDL usually means language for describing digital circuits only. Among the multiple HDL, two became de-facto standards: Verilog HDL and VHDL.</p>
<p>Nowadays, there exist powerful software tools that can automatically produce circuits from HDL descriptions. However, like in software, there may be errors in the descriptions, or they may be sub-optimal, so that the final circuit does not work, or does not meet some constraints. Unfortunately, in hardware, producing a circuit is very time-consuming and expensive so contrary to software, errors or low-performance results must be avoided as early as possible. This is why it is common in hardware to <strong>simulate</strong> your circuit description before starting to produce it. In other words, while in software it is common to perform the following loop:</p>
<p align="center">
<img src="sw_flow.png"  width="50%">
</p>
<p>In hardware, the design loop is more like as follows:</p>
<p align="center">
<img src="hw_flow.png"  width="50%">
</p>
<p>At first, an HDL has the same look and feel compared to classical programming languages like C or Java: it includes expressions, control statements, and kinds of variables. However, the underlying model of computation is quite different, especially because circuits are inherently parallel devices. This will be explained progressively during this tutorial, but for now, it is enough to remember the following:</p>
<ul>
<li><p>HDL are used for describing digital circuits and the most common ones are Verilog HDL and VHDL.</p>
</li>
<li><p>Using software tools called synthesis tools, you can produce real digital circuits from HDL description. But before that, you will need to simulate your description.</p>
</li>
<li><p>An HDL looks like a common programming language but does not work the same.</p>
</li>
</ul>
<h4>And what about HDLRuby?</h4>
<p>Well, HDLRuby is an HDL for describing digital circuits like Verilog HDL or VHDL but aims at being more flexible and productive than them by relying on many concepts inherited from the Ruby programming language. So everything said earlier about HDL applies to HDLRuby, but we try to make it much easier for the designers. Furthermore, HDLRuby includes constructs for describing and simulating software modules so that you can design a full hardware-software device using the same framework (there is a fancy word for that: hardware-software co-design).</p>
<h3>1.2. Installing HDLRuby</h3>
<p>HDLRuby is distributed as a RubyGems package. It can therefore be installed using the following command:</p>
<pre><code class="language-bash">gem install HDLRuby
</code></pre>
<p>If everything is OK, the following should be displayed:</p>
<pre><code>Fetching HDLRuby-&lt;version&gt;.gem
Building native extensions. This could take a while...
Successfully installed HDLRuby-&lt;version&gt;
Parsing documentation for HDLRuby-&lt;version&gt;
Done installing documentation for HDLRuby after &lt;x&gt; seconds.
</code></pre>
<p>The <code>version</code> number should be the latest version of HDLRuby.</p>
<p>You can then check if HDLRuby is properly installed by using the following command:</p>
<pre><code class="language-bash">hdrcc --version
</code></pre>
<p>And the result should be:</p>
<pre><code>&lt;version&gt;
</code></pre>
<p>If the resulting <code>version</code> number does not match the install number, there may have been a problem somewhere. It may be a good idea to close the terminal or command prompt and try again the command in a new one.</p>
<h3>1.3. Using HDLRuby</h3>
<p>Up to now, we said that HDLRuby is a language, it is in truth a complete framework for designing and simulating digital circuits. It includes several compilers, simulators, and libraries that are all accessible through a single command: <code>hdrcc</code>.</p>
<p>Basically, <code>hdrcc</code> is used as follows:</p>
<pre><code class="language-bash">hdrcc &lt;options&gt; &lt;input file&gt; &lt;output/working directory&gt;
</code></pre>
<p>Where <code>options</code> specifies the action to be performed, <code>input file</code> specifies the input HDLRuby file, and <code>output/working directory</code> specifies the directory where the command results will be saved. As a general rule, when an input file is specified, an output directory must also be specified.</p>
<p>Several actions are possible using <code>hdrcc</code>, the main ones being the following:</p>
<ul>
<li>Simulate a circuit description:</li>
</ul>
<pre><code class="language-bash">hdrcc --sim &lt;input file&gt; &lt;output directory&gt;
</code></pre>
<ul>
<li>Generate a graphical representation of the RTL code in SVG format:</li>
</ul>
<pre><code class="language-bash">hdrcc --svg &lt;input file&gt; &lt;output directory&gt;

* Generate the equivalent Verilog HDL code:  

```bash
hdrcc --verilog &lt;input file&gt; &lt;output directory&gt;
</code></pre>
<p>This second action is necessary if you want to produce a real circuit since HDLRuby is not yet supported by synthesis tools.</p>
<p><strong>Note</strong>: VHDL generation is also possible using the following command.</p>
<pre><code class="language-bash">hdrcc --vhdl &lt;input file&gt; &lt;output directory&gt;
</code></pre>
<p>While being able to convert HDLRuby to Verilog HDL may usually be enough to design a cricuits, it may also sometimes be useful to be able to do the reverse: converting a Verilog HDL file to HDLRuby.
To do this, you can use the following command:</p>
<pre><code class="language-bash">v2hdr &lt;input Verilog HDL file&gt; &lt;output HDLRuby file&gt;
</code></pre>
<p>For example, assuming that you have a Verilog ddHDL named 'adder.v' describing and adder circuit, you can convert it to HDLRuby as follows:</p>
<pre><code class="language-bash">v2hdr adder.v adder.rb
</code></pre>
<p>It is also possible to directly use a Verilog file as input to 'hdrcc', but its top module must be specified. For example, to directly simulate the previous 'adder.v', and assuming its top module is 'adder' you can do as follows:</p>
<pre><code class="language-bash">hdrcc --sim -t adder adder.v adder
</code></pre>
<p><strong>Note</strong>: for the command above, it is assumed that 'adder.v' contains a simulation benchmark.</p>
<p>And that's it! For details about all the actions that can be performed, how to write an input file, and what kind of output can be produced, let us see the remaining of the tutorial.</p>
<h3>1.4. About the HDLRuby files.</h3>
<p>The HDLRuby files, that include HDLRuby description of circuits, are text files (the default encoding is UTF-8), is file name's extension is by convension <code>.rb</code>. It is possible to include other HDLRuby file within the current one using the <code>require</code> (for HDLRuby standard files) or <code>require_relative</code> (for local HDLRuby files) methods as follows:</p>
<pre><code class="language-ruby">require &quot;filename&quot;
require_relative &quot;path_to_another_filename&quot;
</code></pre>
<p>As it will be seen later, software Ruby code can also be used for generic descriptions of circuits. It is also possible to include Ruby code from different files using respectively <code>require_ruby</code> for standard libraries and gems, and <code>require_relative_ruby</code> for local files.</p>
<h2>2. How to represent a circuit in HDLRuby</h2>
<p>In this section we will see:</p>
<ul>
<li><p><a href="#21-declaring-a-circuit">How to declare a circuit.</a></p>
</li>
<li><p><a href="#22-how-to-reuse-a-circuit-already-declared">How to reuse a circuit already declared.</a></p>
</li>
</ul>
<h3>2.1. Declaring a circuit</h3>
<p>In HDLRuby as well as in other HDL, a circuit is viewed as a box that communicates with its environment with ports. The following charts illustrate such a view with a circuit including 5 ports:</p>
<p align="center">
<img src="circuit_view.png"  width="35%">
</p>
<p>Ports are not simple entry points though, because they also have a data type and a direction that can be one of the following:</p>
<ul>
<li><p><code>input</code>: such a port can be used for transmitting data from the outside of the circuit to its inside.</p>
</li>
<li><p><code>output</code>: such a port can only be used for transmitting data from the inside of the circuit to its outside.</p>
</li>
<li><p><code>inout</code>: such a port can only be used both as an <code>input</code> port and as an <code>output</code> port. Due to physical limitations, these ports are difficult to use though, and will therefore be ignored until the <a href="#tri-state">advance part of this tutorial</a>.</p>
</li>
</ul>
<h4>That's all very well, but when do I write HDLRuby code?</h4>
<p>With that in mind, declaring a circuit consists of specifying its name and its ports. In HDLRuby this is done as follows:</p>
<pre><code class="language-ruby">system :my_circuit do
   input :clk, :rst
   [16].input :addr
   input :ce
   [8].input  :data_in
   [8].output :data_out
end
</code></pre>
<p>So please write the code above in a file called (for example) <code>my_circuit.rb</code>, and let us explain its meaning.</p>
<ul>
<li><p>In the first line, the keyword <code>system</code> indicates a new circuit will be described. Its name is given after the colon, <code>my_circuit</code> here.</p>
</li>
<li><p>The <code>do</code> → <code>end</code> block contains the description of the circuit. Here, only the ports are specified as follows:</p>
<ul>
<li><p>On the second line, <code>input</code> specifies two one-bit input ports named respectively <code>clk</code> and <code>rst</code>.</p>
</li>
<li><p>The third line specifies a 16-bit input port named <code>addr</code>.</p>
</li>
<li><p>The fourth line specifies a one-bit input port named <code>ce</code>.</p>
</li>
<li><p>The fifth line specifies an eight-bit input port named <code>data_in</code>.</p>
</li>
<li><p>The sixth line specifies an 8-bit output port named <code>data_out</code>.</p>
</li>
</ul>
</li>
</ul>
<p>And here is a diagram of this circuit:</p>
<p align="center">
<img src="circuit_hdr.png"  width="50%">
</p>
<p>To sum up things:</p>
<ul>
<li><p><code>system</code> declares a new circuit description.</p>
</li>
<li><p><code>input</code> specifies one or several input ports, <code>output</code> one or several output ports, and <code>inout</code> one or several input-output ports.</p>
</li>
<li><p>The data type of the port is given before the direction as follows:</p>
</li>
</ul>
<pre><code class="language-ruby">&lt;type&gt;.input &lt;list of ports names&gt;
</code></pre>
<p>We will give later more details about data types in HDLRuby.</p>
<p>Now let us see if your circuit description is all right with the following command:</p>
<pre><code class="language-bash">hdrcc my_circuit.rb work
</code></pre>
<p>...Nothing happened? Great, that means that there was no syntax error in your description. Now let us try something else:</p>
<pre><code class="language-bash">hdrcc --hdr my_circuit.rb work
</code></pre>
<p>If everything was OK, a file named <code>my_circuit.rb</code> should have appeared in the <code>work</code> directory. Open it with a text editor, its content should be the following:</p>
<pre><code class="language-ruby">system :&quot;__:T:0:1&quot; do
   bit. input :clk
   bit.input :rst
   bit[15..0].input :addr
   bit.input :ce
   bit[7..0].input :data_in
   bit[7..0].output :data_out

end
</code></pre>
<p>It looks somewhat similar to the code you have just written. This is because it is the internal representation (IR) of your circuit in HDLRuby. You can see that the name of the circuit changed to some weird character string and that the data types also changed. The weird string is for avoiding name clashes, so you do not need to be concerned about it. The data types are low-level representations of the same data types that were used in the initial file. Still, this low-level representation is very close to the original one, but that will be less and less the case as the features are added to the circuit.</p>
<p>Now, out of curiosity, how will look the equivalent Verilog HDL code? To check that just type the following command:</p>
<pre><code class="language-bash">hdrcc --verilog my_circuit.rb work
</code></pre>
<p>If everything was OK, a file named <code>my_circuit.v</code> should have appeared in the <code>work</code> directory. Open it with a text editor, its content should be the following:</p>
<pre><code class="language-verilog">`timescale 1ps/1ps

module _v0_1( clk, rst, addr, data_in, data_out );
   input clk;
   input rst;
   input [15:0] addr;
   input ce;
   input [7:0] data_in;
   output [7:0] data_out;


endmodule
</code></pre>
<p>The syntax looks indeed a little bit different from HDLRuby, but you should be able to recognize the description of the circuit. The name of the module is different though, this is because HDLRuby supports any Unicode character for names and to avoid compatibility problems, it recreates the names when generating Verilog. But, just for the fun, please replace <code>:addr</code> in the HDLRuby file with <code>:☺</code> and regenerate Verilog HDL from it... It works! And the result is:</p>
<pre><code class="language-verilog">`timescale 1ps/1ps

module _v0_1( clk, rst, _v1_, data_in, data_out );
   input clk;
   input rst;
   input [15:0] _v1_;
   input ce;
   input [7:0] data_in;
   output [7:0] data_out;


endmodule
</code></pre>
<p>Unfortunately, there is no more smiling face. This is because Verilog HDL only supports a subset of ASCII for names. But even without smiling, the code is valid because the HDLRuby framework did recreate Verilog HDL-friendly names.</p>
<h3>2.2. How to reuse a circuit already declared</h3>
<p>Like with functions in software, a circuit is often used as part of one or several larger circuits. Contrary to the software, however, the circuit must be physically copied to be reused. This copy is called an <em>instance</em> and the act of copying an <em>instantiation</em>. In HDLRuby, an instantiation is done as follows:</p>
<pre><code class="language-ruby">&lt;circuit name&gt;(:&lt;copy name&gt;)
</code></pre>
<p>For example, if you want to use copies of the previously defined circuit <code>my_circuit</code> in a new circuit called <code>another_circuit</code> you can do as follows:</p>
<pre><code class="language-ruby">system :another_circuit do
   input :clk, :rst
   [16].input :addr
   input :ce0, :ce1
   [8].input :data_in
   [8].output :data_out

   my_circuit(:my_circuit0)
   my_circuit(:my_circuit1)
end
</code></pre>
<p>For testing purposes, write the code above into another file called <code>another_circuit.rb</code>, and try to generate Verilog HDL from it:</p>
<pre><code class="language-bash">hdrcc --verilog another_circuit.rb work
</code></pre>
<p>Oh, it appears that something went wrong since the following should have appeared:</p>
<pre><code>another_circuit.rb:8:in `block in &lt;main&gt;': undefined HDLRuby construct, local variable or method `my_circuit'.
</code></pre>
<p>This error message indicates that <code>my_circuit</code> is not known. This is because, like the Ruby language, in HDLRuby you must specify the files you are using. Please add as the first line in your <code>another_circuit.rb</code> file the following code:</p>
<pre><code class="language-ruby">require_relative &quot;my_circuit.rb&quot;
</code></pre>
<p>Then retry the Verilog HDL generation command:</p>
<pre><code class="language-bash">hdrcc --verilog another_circuit.rb work
</code></pre>
<p>Three new files should have appeared in the <code>work</code> directory: <code>_v10_5.v</code>, <code>_v8_4.v</code> and <code>another_circuit.v</code>. If you open the third file you should see:</p>
<pre><code class="language-verilog">`timescale 1ps/1ps

module _v0_3( clk, rst, addr, ce0, ce1, data_in, data_out );
   input clk;
   input rst;
   input [15:0] addr;
   input ce0;
   input ce1;
   input [7:0] data_in;
   output [7:0] data_out;

   _v8_4 my_circuit0();
   _v10_5 my_circuit1();

endmodule
</code></pre>
<p>Again, we can see similarities between the resulting Verilog HDL code and the original HDLRuby one. Still, what are <code>_v8_4</code> and <code>_v10_5</code>? You can see them by opening the corresponding files <code>_v8_4.rb</code> and <code>_v10_5.rb</code>, those are the descriptions of <code>my_circuit</code> in Verilog HDL.</p>
<blockquote>
<p><strong>But why two of them?</strong> I would like to answer that this is because of a limitation of Verilog HDL, but this is not the case. It is because HDLRuby's instantiation mechanism is very different from the Verilog HDL (and the VHDL) one, so for the moment, and only for easing the coding work of the HDLRuby compiler, one description of <code>my_circuit</code> is generated per instance.</p>
</blockquote>
<p>Copying a circuit is easy, but it achieves no purpose if the copied circuit is not in a relationship with its environment. It is where the ports become useful: they are the communication points between a circuit and its outside world. Concretely, to interact with a circuit, its ports must be connected to something that will interact with them. How this interaction works is a story for the other sections of this tutorial. For now, let us focus on connections: in HDLRuby this is done using the assignment operator <code>&lt;=</code> as follows:</p>
<ul>
<li>For an input port of the current circuit:</li>
</ul>
<pre><code class="language-ruby">&lt;something&gt; &lt;= &lt;input port&gt;
</code></pre>
<ul>
<li>For an output port of the current circuit:</li>
</ul>
<pre><code class="language-ruby">&lt;output port&gt; &lt;= &lt;something&gt;
</code></pre>
<p>Many things can be connected to a port, but right now, we only know about ports, so let us do the connection in <code>another_circuit</code> with them. So here is the new code of <code>another_circuit.rb</code>, please modify the file accordingly:</p>
<pre><code class="language-ruby">require_relative &quot;my_circuit.rb&quot;

system :another_circuit do
   input :clk, :rst
   [16].input :addr
   input :ce0, :ce1
   [8].input :data_in
   [8].output :data_out

   my_circuit(:my_circuit0)
   my_circuit(:my_circuit1)

   my_circuit0.clk  &lt;= clk
   my_circuit0.rst  &lt;= rst
   my_circuit0.addr &lt;= addr
   my_circuit0.ce   &lt;= ce0
   my_circuit0.data_in &lt;= data_in

   my_circuit1.clk  &lt;= clk
   my_circuit1.rst  &lt;= rst
   my_circuit1.addr &lt;= addr
   my_circuit1.ce   &lt;= ce1
   my_circuit1.data_in &lt;= data_in
end
</code></pre>
<p>If you are familiar with object-oriented or structured software programming, this code should be straightforward: the dot <code>.</code> operator is used to access a sub-element and in this case the ports of <code>my_circuit0</code> and <code>my_circuit1</code>. For example, the first connection line (line 10) connects the <code>clk</code> port of <code>another_circuit</code> to the one of <code>my_circuit0</code>, so that any data that goes through the former port will also go through the latter.</p>
<p>Now, the <code>data_out</code> ports are still not connected. It may be tempting to connect them like <code>data_in</code> as follows:</p>
<pre><code class="language-ruby">  data_out &lt;= circuit0.data_out
  data_out &lt;= circuit1.data_out
</code></pre>
<p>This will work indeed, but not the way you may think: in hardware, you cannot normally connect to one port several different objects. It is like assigning several values at the <strong>same</strong> time to a single variable. What will happen in HDLRuby, is that only the last statement will be kept, i.e., port <code>data_out</code> of <code>circuit0</code> will not be connected.</p>
<p>With such kind of cases, what we often want to do is to connect to <code>data_out</code> some computation result between the output of <code>circuit0</code> and <code>circuit1</code>. This is the opportunity to see another kind of construct that can be connected to a port: an expression. Like in software, an expression represents an arithmetic and logic computation. For example, let us consider the following connection:</p>
<pre><code class="language-ruby">  data_out &lt;= my_circuit0.data_out + my_circuit1.data_out
</code></pre>
<p>With this connection, the sum of the outputs <code>my_circuit0</code> and <code>my_circuit1</code> is transmitted through the output port <code>data_out</code> of <code>another_circuit</code>.</p>
<blockquote>
<p><strong>But when is this computation performed?</strong> This is a very good question: while in software, programs are executed one instruction after the other, in hardware, there is no such thing as the execution of instructions. The expression connected to <code>data_out</code> is not an instruction at all! It is a description of a part of the circuit that specifies that an adder (a circuit that does addition) must be instantiated with the output ports <code>data_out</code> of <code>my_circuit0</code> and <code>my_circuit1</code> connected to its inputs and its output connected to the output port <code>data_out</code> of <code>another_circuit</code>. The following figures show the schematic of this hardware portion:</p>
</blockquote>
<p align="center">
<img src="circuit_hie.png"  width="40%">
</p>
<blockquote>
<p><strong>So, when this expression is executed?</strong> It is continuously executed, i.e., as soon as one of the outputs <code>data_out</code> of <code>my_circuit0</code> or <code>my_circuit1</code> changes, so does the output <code>data_out</code> of <code>another_circuit</code>.</p>
</blockquote>
<p>For trying this new circuit, please update the code of <code>another_circuit.rb</code> as follows:</p>
<pre><code class="language-ruby">require_relative &quot;my_circuit.rb&quot;

system :another_circuit do
   input :clk, :rst
   [16].input :addr
   input :ce0, :ce1
   [8].input :data_in
   [8].output :data_out

   my_circuit(:my_circuit0)
   my_circuit(:my_circuit1)

   my_circuit0.clk  &lt;= clk
   my_circuit0.rst  &lt;= rst
   my_circuit0.addr &lt;= addr
   my_circuit0.ce   &lt;= ce0
   my_circuit0.data_in &lt;= data_in

   my_circuit1.clk  &lt;= clk
   my_circuit1.rst  &lt;= rst
   my_circuit1.addr &lt;= addr
   my_circuit1.ce   &lt;= ce1
   my_circuit1.data_in &lt;= data_in

   data_out &lt;= my_circuit0.data_out + my_circuit1.data_out
end
</code></pre>
<p>Then, let us generate again Verilog HDL from it:</p>
<pre><code class="language-bash">hdrcc --verilog another_circuit.rb work
</code></pre>
<p>Oh! If you get the following error message:</p>
<pre><code>another_circuit.rb:15:in `block in &lt;main&gt;': undefined method `addr' for #&lt;HDLRuby::High::Namespace:&lt;whatever number&gt;&gt;
</code></pre>
<p>Do not forget to replace the smiling face with <code>addr</code> in <code>my_circuit.rb</code>.</p>
<p>When the compile succeeds (no error message), two new files appear in <code>work</code>, namely <code>_v20_4.v</code> and <code>_v23_5.v</code>. Those are the new descriptions of <code>my_circuit</code>, they did not change, but since new hardware has been added their name changed. For the interesting part, let us open again <code>another_circuit.v</code>, the result should be as follows:</p>
<pre><code class="language-verilog">`timescale 1ps/1ps

module _v0_3( clk, rst, addr, ce0, ce1, data_in, data_out );
   input _v1_clk;
   input _v2_rst;
   input [15:0] addr;
   input ce0;
   input ce1;
   input [7:0] data_in;
   output [7:0] data_out;
   wire _v8_0;
   wire _v9_1;
   wire [15:0] _v10_2;
   wire _v11_3;
   wire [7:0] _v12_4;
   wire _v13_5;
   wire _v14_6;
   wire [15:0] _v15_7;
   wire _v16_8;
   wire [7:0] _v17_9;
   wire [7:0] _v18_10;
   wire [7:0] _v19_11;

      _v20_4 my_circuit0(.clk(_v8_0),.rst(_v9_1),.addr(_v10_2),.ce(_v11_3),.data_in(_v12_4),.data_out(_v18_10));
   _v23_5 my_circuit1(.clk(_v13_5),.rst(_v14_6),.addr(_v15_7),.ce(_v16_8),.data_in(_v17_9),.data_out(_v19_11));
   assign _v8_0 = clk;

   assign _v9_1 = rst;

   assign _v10_2 = addr;

   assign _v11_3 = ce0;

   assign _v12_4 = data_in;

   assign _v13_5 = clk;

   assign _v14_6 = rst;

   assign _v15_7 = addr;

   assign _v16_8 = ce1;

   assign _v17_9 = data_in;

   assign data_out = (_v18_10 + _v19_11);


endmodule
</code></pre>
<p>The code is starting to get complicated and seems to be much different from the HDLRuby description than before. This is because this time, real syntactic limitations of Verilog HDL compared to HDLRuby have to be bypassed. Here, the limitation is that while in HDLRuby, ports can be connected wherever we want, in Verilog HDL, this must be done only while instantiating.</p>
<p>In fact, in HDLRuby too you can do the connection while instantiating, this is even recommended for better readability of the code. There are two ways to do so: by position (like for the arguments of a function call) or by name. Let us see both by editing again <code>another_circuit.rb</code>: please just replace both instantiation lines with the following:</p>
<pre><code class="language-ruby">my_circuit(:my_circuit0).(clk,rst,addr,ce0,data_in,data_out)
my_circuit(:my_circuit1).(clk: clk, rst: rst, addr: addr, ce: ce1,
                          data_in: data_in, data_out: data_out)
</code></pre>
<p>The instantiation for <code>my_circuit0</code> does the connection by position, that is to say, that each port given between the second parenthesis is connected in the order of declaration of in ports of <code>my_circuit.rb</code>. For <code>my_circuit1P</code> the connection is done by name: then syntax <code>&lt;name&gt;: &lt;something&gt;</code> connects ports named <code>name</code> of the instance of <code>my_circuit</code> to <code>something</code>. For example <code>clk: clk</code> connects port <code>clk</code> of <code>my_circuit0</code> to port <code>clk</code> of <code>another_circuit</code>.</p>
<h4>That's all for this section!</h4>
<hr>
<p>Now you know:</p>
<ul>
<li><p>How to declare a new circuit with its name and ports in HDLRuby.</p>
</li>
<li><p>How to check it with hdrcc.</p>
</li>
<li><p>How to convert it to Verilog HDL.</p>
</li>
<li><p>How to reuse it into another circuit.</p>
</li>
<li><p>And even, how to describe the computation of some expressions and connect them to an output port.</p>
</li>
</ul>
<p>But you still do not know: how to describe more complex computations, e.g., controls, and how to simulate a circuit. Let us start slowly (from the software person's point of view) with how to describe an algorithm the simple way in HDLRuby.</p>
<h2>3. How to describe an algorithm to be implemented by a circuit</h2>
<p>In this section we will see:</p>
<ul>
<li><p><a href="#31-how-to-handle-values-in-a-circuit">How to handle values in a circuit.</a></p>
</li>
<li><p><a href="#32-how-to-describe-an-algorithm-that-a-circuit-can-implement">How to describe an algorithm that a circuit can implement.</a></p>
</li>
</ul>
<h3>3.1. How to handle values in a circuit</h3>
<p>In software, handling values looks straightforward enough: they are computed with expressions and stored in variables. In hardware it is slightly different since two kinds of components handle values: the wires and the storage components:</p>
<ul>
<li><p>The wires are abstractions of physical wires or sets of wires that transmit data to the hardware component they are connected to. A wire cannot hold a value: if a component drives a value to a wire, this wire takes this value, and it will last as soon as this drive stops.</p>
</li>
<li><p>The storage components are abstractions of registers or memories that can hold values. Depending on how they are described, the value they hold can be changed on specific events like the rising edge of a clock. Hence, the storage components are closer to the software variable than the wires are.</p>
</li>
</ul>
<p>With HDL like Verilog HDL, there is a real distinction between wires and storage components. However, with other HDL like VHDL, or here with HDLRuby, both are abstracted by a single concept: the signal. Specifically, when a signal is only driven on a given event, it becomes a storage element, otherwise, it will remain a wire.</p>
<p><strong>Note</strong>: one may ask what about the <code>variable</code> construct in VHDL: those are syntactic intermediates used for simplifying the descriptions. HDLRuby also supports such a <code>variable</code> construct, but those are simply the variables of the Ruby language. Therefore, these variables can hold not only values but any Ruby or HDLRuby constructs.</p>
<p>In HDLRuby, there are four kinds of signals: the input ports, the output ports, the inout ports, and the inner signals. The first three kinds of signals have already been described in the section about declaring a <a href="#circuit-declare">circuit</a>. At that time they were called ports because it is what such constructs are called in common HDL. However, in HDLRuby there is no distinction at all between ports and signals, hence from now on, we will use the term <code>signal</code> in general, and the term <code>port</code> when we only want to refer to the interface of a circuit. The inner signals can be used inside a circuit and are usually used as an intermediate for internal computations. They are declared like the ports, but using <code>inner</code> instead of <code>input</code>, <code>output</code>, or <code>inout</code>. For example, the following code declares a module named <code>a_circuit</code> with two 1-bit inputs, one 8-bit output, and one 4-bit inner signal.</p>
<pre><code class="language-ruby">system(:a_circuit) do
   input :u, :v
   [8].output :z

   [4].inner :sig
end
</code></pre>
<p><strong>Note</strong>: the inner signals as well as the ports can be declared anywhere within the body of a module. It is however recommended to declare the ports at the beginning, and the inner signal when relevant, e.g., it may not be a good idea to declare an inner signal at the beginning of a circuit description if it is only used at the end.</p>
<h4>What about the data types?</h4>
<p>For now, we only used positive integer values, e.g., <code>[8].inner</code> declares an 8-bit positive integer. To tell the truth, <code>[8]</code> is not the designation of the 8-bit positive integer data type, but a syntactic sugar that stands for: <code>bit[8]</code>. As a general rule, in HDLRuby, the designation of a data type is as follows:</p>
<pre><code class="language-ruby">&lt;base&gt;[&lt;range&gt;]
</code></pre>
<p>Where <code>base</code> is another data type and <code>range</code> describes the range of indexes used for accessing its elements individually. In addition, there are three root data types used for building all the other ones:</p>
<ul>
<li><p><code>bit</code>: for boolean or 1-bit unsigned values, i.e., the only possible values are 0 and 1.</p>
</li>
<li><p><code>signed</code>: for 1-bit signed values in 2's complement, i.e., the only possible values are 0 and -1.</p>
</li>
<li><p><code>float</code>: for 1-bit floating point values, but, <strong>WARNING</strong>: this data type is not supported yet!</p>
</li>
</ul>
<p>For example, a 32-bit input signed integer signal and an inner array of eight 24-bit integers are declared respectively as follows:</p>
<pre><code class="language-ruby">signed[32].input :sig
bit[24][8].inner :ar
</code></pre>
<blockquote>
<p>Unfortunately, the following is not valid:<br>
<code>[24][8].inner :ar</code><br>
This is because it conflicts with other constructs in the language.</p>
</blockquote>
<p>When the code above is declared, you can access one element of array <code>ar</code> using the brackets like before, e.g., its first element is <code>ar[0]</code>, its second one <code>ar[1]</code>, and so on. But you can also access its last element as follows: <code>ar[-1]</code>, its element before the last one as follows <code>ar[-2]</code>, and so on. Moreover, since an integer is just an array of bits, it is possible to access its bits individually in the same way. For example, accessing the first bit of the last element of ar can be done as follows: <code>ar[-1][0]</code>.</p>
<p>But compared to the software you can do even more than that: you can also access to sub-range of elements of a signal. For example, assigning bits from index 4 to 27 of signal <code>sig</code> to element 1 of array <code>ar</code> can be written as follows using <em>range</em>:</p>
<pre><code class="language-ruby">ar[1] &lt;= sig[27..4]
</code></pre>
<p>A range is noted as follows: <code>&lt;start value&gt;..&lt;end value&gt;</code>, and indicates respectively the value of the first and the last indexes. Convenient, is not it? But wait... Why <code>27..4</code> and not <code>4..27</code>?</p>
<h4>Let us talk about endianness.</h4>
<p>If you are familiar with hardware or with low-level software, you may be aware of this topic. There are two possible ways for reading a value or the content of an array: from the most significant bit or index to the least significant one (big-endian) and the opposite (little-endian). Since big-endian is more natural for reading numbers it is the default mode in HDL, including HDLRuby. However, for an array, software programming usually does the opposite. In HDLRuby, using little-endian instead of big-endian is declared by using a negative number for the size instead of a positive one.</p>
<p>As a general rule, code will be much easier to understand if integer values are big-endian and the array accesses little-endian. That is to say that the following declaration is the best for <code>ar</code>:</p>
<pre><code class="language-ruby">bit[24][-8].inner :ar
</code></pre>
<blockquote>
<p>One last thing: it is also possible to set the numbering of each bit of a signal using again a <em>range</em> instead of an integer indicating the size. For example, with the following declaration, <code>a</code> is an 8-bit big-endian integer with its bits numbered from 0 to 7, and <code>b</code> is a 9-bit little-endian integer with its bits numbered from 1 to 9:<br>
<code>[7..0].inner :a</code><br>
<code>[1..9].inner :b</code></p>
</blockquote>
<p>So now you know about basic types in HDLRuby, but what happens when we make operations between signals of different types?</p>
<h4>About casting and auto-casting</h4>
<p>First, you can convert the type of a signal using the cast operator <code>as</code>. For example, in the following code, the result of a 16-bit unsigned addition is performed between the 8-bit signal <code>x</code> converted to 16-bit and the 16-bit signal <code>y</code>:</p>
<pre><code class="language-ruby">[8].inner :x
[16].inner :y, :z

&lt;some code&gt;

z &lt;= x.as(bit[16]) + y
</code></pre>
<p>However, if you do not use the cast operator, HDLRuby will do it automatically for you and cast the operands to the largest of their types. That is to say that for the following code the result is identical to the previous one:</p>
<pre><code class="language-ruby">[8].inner :x
[16].inner :y, :z

&lt;some code&gt;

z &lt;= x + y
</code></pre>
<p>This rule means that for the following code, <code>z</code> will have the result of an 8-bit addition since both operands <code>x</code> and <code>y</code> are 8-bit:</p>
<pre><code class="language-ruby">[8].inner :x, :y
[16].inner :z

&lt;some code&gt;

z &lt;= x + y
</code></pre>
<p>If you want a 16-bit addition, you must add a cast to at least one of the operands, e.g.:</p>
<pre><code class="language-ruby">[8].inner :x, :y
[16].inner :z

&lt;some code&gt;

z &lt;= x.as(bit[16]) + y
</code></pre>
<hr>
<p>These explanations about data types may have been not so fun, be we should better get over with them first so that now we can start the real fun with actual &quot;programming&quot;...</p>
<p><strong>Note</strong>: &quot;Programming&quot; is put between quotes because this is not programming since there is no program, but instead, a description of a physical circuit.</p>
<h3>3.2. How to describe an algorithm that a circuit can implement</h3>
<p>So now you know how to declare a circuit, use it, connect it, and declare variable-like constructs that are called signals. We will see later that signals are definitive <strong>not</strong> software variables, but let us go on with the illusion for a little while and see how you can describe an algorithm in HDLRuby. As a side note, the features described in this section are unique to HDLRuby so do not expect to be able to do the same with Verilog HDL or VHDL.</p>
<p>With software languages, when you want to describe an algorithm you use assignments but also control statements like <code>if</code>, <code>for</code>, or <code>while</code>. If you know higher-level languages like <code>Java</code> or <code>Ruby</code> you may also use design patterns like <code>iterators</code> (or <code>enumerators</code>). You can do the same in HDLRuby with constructs called <em>sequencers</em>. At first glance, a sequencer can be seen as the description of a hardware component implementing a software algorithm. Hence, a sequencer may look like a processor, but there are differences:</p>
<ul>
<li><p>It is not possible to change the algorithm implemented by a sequencer (you cannot &quot;load&quot; a new program).</p>
</li>
<li><p>A sequencer starts execution according to a given start signal, and from there advances execution at each cycle of a given clock.</p>
</li>
<li><p>You have control of the algorithm at the clock cycle level, and incidentally, a sequencer is much more efficient than a processor executing a program.</p>
</li>
</ul>
<p>This section will explain the following about sequencers:</p>
<ul>
<li><p><a href="#321-how-to-declare-and-control-a-sequencer">How to declare and control a sequencer.</a></p>
</li>
<li><p><a href="#322-how-to-write-a-structured-programming-algorithm-in-a-sequencer">How to write a structured programming algorithm in a sequencer.</a></p>
</li>
<li><p><a href="#323-how-to-write-and-use-a-sequencer-function">How to write and use a sequencer function.</a></p>
</li>
<li><p><a href="#324-how-to-use-enumerators-in-a-sequencer">How to use enumerators in a sequencer.</a></p>
</li>
<li><p><a href="#325-what-happens-when-there-are-several-sequencers">What happens when there are several sequencers?</a></p>
</li>
</ul>
<h4>3.2.1 How to declare and control a sequencer</h4>
<p>As said in the previous section, a sequencer advances execution according to a clock and starts execution according to a start signal. A clock is a single-bit signal that alternates from 0 to 1, and it is the transition from 0 to 1, or from 1 to 0 of this signal that will make a sequencer progress execution. Let us see two examples of sequencers to understand better:</p>
<pre><code class="language-ruby">system :the_counter do
   inner :clk, :start

   sequencer(clk,start) do
   end
end
</code></pre>
<p>In the code above, a module containing one sequencer is described. The sequencer is controlled by the start signal <code>start</code> and clock signal <code>clk</code>, which means that:</p>
<ul>
<li><p>it will advance execution every time <code>clk</code> switches from 0 to 1 - we call such an event a <em>positive edge</em> of <code>clk</code>;</p>
</li>
<li><p>it will start when signal <code>start</code> switches from 1 to 0 - we call such an event a <em>negative edge</em> of <code>start</code>.</p>
</li>
</ul>
<p>Why a positive edge for <code>clk</code> and a negative one for <code>start</code>? It does not matter much, and you can specify the edges you want using the <code>posedge</code> and <code>negedge</code> methods. For example, the following sequencer advances execution on a negative edge of <code>clk</code> and starts on a positive edge of <code>start</code>:</p>
<pre><code class="language-ruby">sequencer(clk.negedge,start.posedge) { }
</code></pre>
<p><strong>Note</strong>: the curly brackets used here are equivalent to the <code>do</code> and <code>end</code> keywords we used until now.</p>
<blockquote>
<p><strong>WARNING</strong>: there is a caveat though, since a sequencer advances execution according to a clock signal, it will not be able to start properly unless the start signal is strictly slower than the clock.</p>
</blockquote>
<p>But now, what will this sequencer do? ... Nothing right now since its body is empty. So let us start small and make it count the number of a few clock cycles:</p>
<pre><code class="language-ruby">system :the_counter do
   inner :clk, :start
   [8].inner :count

   sequencer(clk,start) do
      count &lt;= 0
      step
      count &lt;= count + 1
      step
      count &lt;= count + 1
      step
      count &lt;= count + 1
   end
end
</code></pre>
<p>The first line of the body of the counter looks like the connection of ports we described <a href="#circuit-use">previously</a>. However, it is inside the body of a sequencer and will therefore be <em>executed</em> by it, that is to say, before this statement is executed, <code>count</code> may not be 0. More generally:</p>
<ul>
<li><p>Every assignment statement outside sequencers (and later processes) is a connection: the signal will <em>always</em> and <em>continuously</em> have the value that is assigned to it.</p>
</li>
<li><p>The other assignment statements, e.g., the ones inside a sequencer, are called <em>transmission</em> in HDLRuby and happen only when &quot;executed.&quot;</p>
</li>
</ul>
<p>In our example, the count is set to 0 when the sequencer starts execution. But before that, no one knows the value of count: it is said to be <em>undefined</em>.</p>
<p>Just after this initial line, there is the <code>step</code> keyword. There we go from the software world to the hardware one: this keyword indicates that the sequencer ends execution here until the next clock cycle. Looking at the subsequent line you may understand why we waited: this line increases the value of <code>count</code> by one, i.e., the sequencer counted one clock cycle. Again, a <code>step</code> is inserted, and <code>count</code> is increased, and so on, so that this is indeed the code of a sequencer that counts the clock cycles. However the code ends after 3 clock cycles, and like with software, when the code of a sequencer is over, it stops execution.</p>
<p>This may look abstract, so let us try to simulate this circuit. For that purpose, write the code into a file named <code>the_counter.rb</code> (for example) and try the following command that will simulate the circuit:</p>
<pre><code class="language-bash">hdrcc --sim the_counter.rb the_counter
</code></pre>
<p>If everything was all right the following text will appear:</p>
<pre><code>__:T:0:::2: 000
</code></pre>
<p>It indicates that a signal named <code>__: T:0:::2</code> has been initialized to 0 (000), and that's all... Why is that, and why only that? First, this signal with a strange name has been generated by HDLRuby for the internal processing of the sequencer and is required to be initialized to 0. So, ok, the simulation did some initialization, but it did not seem to do any execution. This is because we did not give any description of the physical environment of the circuit, and especially, we did not say that the clock and the start signal need to change value. For describing the behavior of the environment of a circuit, we use a construct called, in HDLRuby, the <em>timed process</em>. They are somewhat close to sequencers but are not controlled by a clock signal but by physical time. So let us add the following code just after the sequencer (but still inside the module <code>the_counter</code>:</p>
<pre><code class="language-ruby">   timed do
      clk &lt;= 0
      start &lt;= 0
      !10.ns
      clk &lt;= 1
      !10.ns
      clk &lt;= 0
      start &lt;= 1
      !10.ns
      clk &lt;= 1
      !10.ns
      clk &lt;= 0
      start &lt;= 0
      !10.ns
      clk &lt;= 1
      !10.ns
      clk &lt;= 0
      !10.ns
      clk &lt;= 1
      !10.ns
      clk &lt;= 0
      !10.ns
      clk &lt;= 1
      !10.ns
      clk &lt;= 0
      !10.ns
      clk &lt;= 1
      !10.ns
      clk &lt;= 0
      !10.ns
      clk &lt;= 1
      !10.ns
   end
</code></pre>
<p>Sorry, this code is a little bit long... Did you add it to the file <code>the_counter.rb</code>? now please try again the simulation command:</p>
<pre><code class="language-bash">hdrcc --sim the_counter.rb the_counter
</code></pre>
<p>You should have the following result:</p>
<pre><code>__:T:0:::2: 000
__:T:0::clk: 0
__:T:0::start: 0
# 10000ps
__:T:0::clk: 1
__:T:0:::1: 000
# 20000ps
__:T:0::clk: 0
__:T:0::start: 1
# 30000ps
__:T:0::clk: 1
__:T:0:::2: 001
# 40000ps
__:T:0::start: 0
__:T:0::clk: 0
# 50000ps
__:T:0::clk: 1
__:T:0:::1: 001
__:T:0::count: 00000000
__:T:0:::2: 010
# 60000ps
__:T:0::clk: 0
# 70000ps
__:T:0::clk: 1
__:T:0:::1: 010
__:T:0::count: 00000001
__:T:0:::2: 011
# 80000ps
__:T:0::clk: 0
# 90000ps
__:T:0::clk: 1
__:T:0:::1: 011
__:T:0::count: 00000010
__:T:0:::2: 100
# 100000ps
__:T:0::clk: 0
# 110000ps
__:T:0::clk: 1
__:T:0:::1: 100
__:T:0::count: 00000011
__:T:0:::2: 101
# 120000ps
__:T:0::clk: 0
# 130000ps
__:T:0::clk: 1
__:T:0:::1: 101
__:T:0:::2: 000
# 140000ps
</code></pre>
<p>If you look at the last line of the simulation result you should have <code># 140000ps</code>, which means that final the simulation time was 140000 picoseconds (140 nanoseconds). If you look at the result in totality, you will see an alternation of signal names followed by a value in binary (e.g., <code>__:T:0::clk: 1</code> means that the <code>clk</code> signal is 1) and an indication of the time of the simulation. The names look indeed messy, but please only focus on their last parts: that will be the names of the signals you defined in your HDLRuby file. You will also notice some signals that you did not declare (e.g., <code>__:T:0:::1</code> and <code>__:T:0:::2</code>, but those are only signals generated by HDLRuby.</p>
<p>Now, let us see what happened, and what was the meaning of the <code>timed</code> construct we added. As explained before, <code>timed</code> constructs are like sequencers, but controlled by physical time instead of a clock signal. Inside, you can put assignments but also statements that advance the time. For instance: <code>!10.ns</code> is a statement that advances time by 10 nanoseconds (i.e., 10000 picoseconds). Hence, with such a construct you can declare that a signal will take a given value at a given time. For this example, it is enough to tell how the <code>clk</code> and <code>start</code> signal change over time to make the sequencer run by itself. Hence, the <code>clk</code> signal is made to switch from 0 to 1 then from 1 to 0 every 10 nanoseconds, which simulates a 50 MHz clock, and the start signal is set to 1 and then to 0 so that the sequencer starts execution. The first thing it does is set <code>counter</code> to 0, and then the following cycles this counter is increased until its execution completes. Even when the sequencer completes execution, the simulation goes on though, until the timed process also completes.</p>
<blockquote>
<p><strong>WARNING</strong>: in HDLRuby, everything is synthesizable, i.e., it can be turned into a real circuit, <strong>apart</strong> from the timed processes. These constructs are only there for simulating the physical environment of a circuit.</p>
</blockquote>
<h4>Ugh! The simulation result is ugly!</h4>
<p>Indeed, the text output of the simulator is hard to read, and therefore we highly recommend generating a graphical one using the following command:</p>
<pre><code class="language-bash">hdrcc --sim --vcd the_counter.rb the_counter
</code></pre>
<p>The new option <code>--vcd</code> makes the simulator produce a <em>Value Change Dump</em> file (VCD) that can be visualized graphically by many HW design tools. If you do not have any such tool you can get <a href="https://gtkwave.sourceforge.net/">GTKWave</a> which is under GNU General Public License v2.0, or <a href="https://github.com/civol/htmlwave">HTMLWave</a> by the author of HDLRuby (link of interest!) and which is under the MIT License (also available as web application at this <a href="https://civol.github.io/htmlwave/htmlwave.html">link</a>.)</p>
<p>The resulting vcd file can be found in the <code>the_counter</code> directory with the name <code>hruby_simulator.vcd</code>. If you open it and select the <code>clk</code>, <code>start</code>, and <code>counter</code> signals you will see something like the following picture:</p>
<p align="center">
<img data-name="hruby_simulator.vcd" src="the_counter_vcd.png"  width="80%">
</p>
<p>Such a graph is called a time chart and displays the evolution of signals with time on the X-axis. You can see that <code>clk</code> is indeed alternating from 0 to 1, and that <code>start</code> is set to 1 for one clock cycle only. After this later signal becomes 0 again, the sequencer starts. This can be verified by looking at the value of <code>counter</code>: at first, it is undefined, that it is set to 0, then increased by 1 at each clock cycle until it reaches 3.</p>
<hr>
<p>So now, you know:</p>
<ul>
<li><p>How to describe an algorithm in HDLRuby.</p>
</li>
<li><p>How to simulate it.</p>
</li>
<li><p>How to display a cool graph showing the simulation results (maybe?)</p>
</li>
</ul>
<p>Hum, the algorithm part is quite limited, and the timed processes seem to be real pains to write. So let us see how to do better in the following section.</p>
<h4>3.2.2. How to write a structured programming algorithm in a sequencer</h4>
<p>Now, when we speak about algorithms, we often think about software constructs like <code>if</code> for conditional executions and <code>for</code> for loops. Unfortunately, in HW design this is usually not that simple at all... But for the HDLRuby sequencers, it is indeed that simple: all these control statements are supported without any limitation. The only thing you have to be careful about is their name: to avoid confusion with the Ruby language, their names are all prefixed with an <code>s</code> (for <em>sequencer</em>), e.g., you have to use <code>sif</code> for doing an <em>if</em>.</p>
<p>In detail here is a list of the control statements you can use within a sequencer:</p>
<ul>
<li><p><code>sif(&lt;condition&gt;) &lt;block&gt;</code>: executes <code>block</code> if <code>condition</code> is true (i.e., different from 0).</p>
</li>
<li><p><code>selsif(&lt;condition&gt;) &lt;block&gt;</code>: executes <code>block</code> if the previous <code>sif</code> and <code>selsif</code> conditions are false and if the current <code>condition</code> is true.</p>
</li>
<li><p><code>selse &lt;block&gt;</code>: executes <code>block</code> if the conditions of the previous <code>sif</code> and <code>selsif</code> are false (i.e., equals 0). It is also used for giving the default block for the <code>scase</code> statements (see below).</p>
</li>
<li><p><code>scase(&lt;choice&gt;)</code>: initializes a multiple case statement.</p>
</li>
<li><p><code>swhen(&lt;value&gt;) &lt;block&gt;</code>: executes block if <code>value</code> is equal to the <code>choice</code> of the previous <code>scase</code> statement.</p>
</li>
<li><p><code>sloop &lt;block&gt;</code>: loops infinitely repeating the execution of <code>block</code> (yes, like Ruby, if you want to do an infinite loop, do it explicitly, not with constructs like <code>while(true)</code>... even if you can).</p>
</li>
<li><p><code>swhile(&lt;condition&gt;) &lt;block&gt;</code>: repeats the execution of <code>block</code> as long as <code>condition</code> is true.</p>
</li>
<li><p><code>sfor(&lt;enumerable&gt;) &lt;block&gt;</code>: executes <code>block</code> on each element of <code>enumerable </code>.</p>
</li>
<li><p><code>sbreak</code>: ends the current loop (even if it is a <code>sloop</code>).</p>
</li>
<li><p><code>scontinue</code>: ends the current iteration.</p>
</li>
<li><p><code>steps(&lt;num&gt;)</code>: performs <code>num</code> times <code>step</code> (<code>num</code> can be any expression). Useful for waiting a certain number of cycles.</p>
</li>
</ul>
<blockquote>
<p><strong>IMPORTANT</strong>: each control statement requires one clock cycle for each branch they perform, independently of what their block contains. For example, in the following code, the value of <code>y</code> will be set one cycle after <code>x</code> is set to 0, and one cycle before <code>z</code> is set to 1.</p>
</blockquote>
<pre><code class="language-ruby">x &lt;= 0
sif(~x) { y &lt;= 2 }
z &lt;= 1
</code></pre>
<p>Let us see the details about these constructs with a few examples. First, let us make a circuit that computes the factorial of an input value when asked for:</p>
<pre><code class="language-ruby">system :fact do
   input :clk, :start, :req
   [5].input :data_in
   output :ack
   [32].output :data_out

   [4].inner :val
   [24].inner :res

   sequencer(clk,start) do
      sloop do
         ack &lt;= 0
         swhile(req != 1)
         val &lt;= data_in
         res &lt;= 1
         swhile(val&gt;1) do
             res &lt;= res*val
             val &lt;= val - 1
         end
         data_out &lt;= res
         ack &lt;= 1
      end
   end
end
</code></pre>
<p>The code is more complex than what we have seen up to now, so let us study it progressively:</p>
<ul>
<li><p>The circuit is named <code>fact</code> (for factorial).</p>
</li>
<li><p>It has four inputs:</p>
<ul>
<li><p><code>clk</code> and <code>start</code>: the signals that control the execution of the sequencer (nothing new here).</p>
</li>
<li><p><code>req</code>: the signal that will ask for a factorial computation (<em>req</em> stands for require).</p>
</li>
<li><p><code>data_in</code>: the signal that will provide the input value. It is a 4-bit unsigned integer.</p>
</li>
</ul>
</li>
<li><p>It has two outputs:</p>
<ul>
<li><p><code>ack</code>: the signal that will tell that the current computation of factorial is over. Such a signal is necessary for the environment to know if the output result is valid or not since the computation time of a factorial depends on the input value.</p>
</li>
<li><p><code>data_out</code>: the signal that will hold the computation result. It is a 24-bit unsigned integer, much larger than the input, but we are computing factorials here! (This is not enough yet: 15! equals 1307674368000 which requires 41 bits... But 24-bit was the largest that could fit in the picture of the time chart that is shown after.)</p>
</li>
</ul>
</li>
<li><p>The sequencer includes an infinite loop (<code>sloop</code>) so that it does not stop after one computation. Within this loop:</p>
<ul>
<li><p>It first sets <code>ack</code> to 0 to tell that currently, its output is not valid (no computation is done yet).</p>
</li>
<li><p>Then it waits for a request, i.e., it waits for that signal <code>req</code> is 1. This loop (<code>swhile(req != 1)</code>) does not have any block to execute, it will therefore loop without doing anything.</p>
</li>
<li><p>When <code>req</code> becomes 1, it loads the input value into an internal temporary signal (<code>val</code>) and initializes the computed value (<code>res</code>) to one.</p>
</li>
<li><p>Finally, it loops by multiplying <code>res</code> by <code>val</code> and decreasing <code>val</code> until 1 is reached before assigning the computation result to <code>data_out</code> and setting <code>ack</code> to 1 for telling the computation is over.</p>
</li>
</ul>
</li>
</ul>
<h4>Does it work?</h4>
<p>Now let us simulate this circuit. For that, you now know that we must describe the environment using a timed process. But this time, let us do this properly  by putting the description of the environment in a different module to separate the circuit description from the simulation: please write in a file named <code>fact.rb</code> the code of module <code>fact</code>, and then the following code:</p>
<pre><code class="language-ruby">system :fact_bench do
   inner :clk, :start, :req, :ack
   [4].inner :x
   [24].inner :z

   fact(:factI).(clk,start,req,x,ack,z)

   def clk!
       clk &lt;= 0
       !10.ns
       clk &lt;= 1
       !10.ns
   end

   timed do
      start &lt;= 0
      !10.ns
      clk!
      start &lt;= 1
      req   &lt;= 0
      clk!
      start &lt;= 0
      repeat(2) do
          clk!
      end
      req   &lt;= 1
      x     &lt;= 10
      clk!
      req   &lt;= 0
      repeat(20) do
          clk!
      end
   end
end
</code></pre>
<p>This module introduces the <code>repeat</code> construct. It can be used within a timed process only and has the following syntax:</p>
<pre><code class="language-ruby">repeat(&lt;number&gt;) &lt;block&gt;
</code></pre>
<p>It executes the <code>block</code> <code>number</code> times with the number of iterations as an argument.</p>
<p><strong>WARNING</strong>: the repeat construct cannot be used outside a timed process. Inside a sequencer, you can use instead <code>swhile</code> or <code>sfor</code>.</p>
<blockquote>
<p>There seems to be another new kind of command in the timed process: <code>clk!</code>. This is not a command though, but it is a Ruby function defined just before with the <code>def</code> block. If you are not familiar with Ruby, <code>def</code> is used for defining a new function (actually a method), also, it is not necessary to put parenthesis when calling a function. Hence, <code>clk!</code> is simply the call of this previously defined function (in Ruby, function names can terminate with characters like <code>!</code> or <code>?</code>). If you look at the body of this function, you will see not plain Ruby code, but again HDLRuby code:</p>
</blockquote>
<pre><code class="language-Ruby">clk &lt;= 0
!10.ns
clk &lt;= 1
!10.ns
</code></pre>
<blockquote>
<p><strong>IMPORTANT</strong>: as said when presenting HDLRuby, this language is implemented on top of the Ruby language, and is fully compatible with it. For instance, you can write any Ruby code within HDLRuby constructs (e.g., <code>def</code>), and you can write HDLRuby code within Ruby constructs. However, there is an important difference: Ruby code is executed at compile time (i.e., when hdrcc runs) and does not produce any hardware, whereas HDLRuby code is the description of the hardware that will be produced and will be then executed either through simulation or after production physically.
Then, what calling <code>clk!</code> does is paste the HDLRuby code in place. Here it is used to shorten the code: instead of each time setting the clock to 0, advancing time, then setting it to 1 again, writing <code>clk!</code> is enough to obtain the same result.<br>
It is from this capability to mix Ruby and HDLRuby that comes the <em>meta programmability</em> of HDLRuby.</p>
</blockquote>
<p>Finally, when you simulate with the following command:</p>
<pre><code class="language-bash">hdrcc --sim --vcd fact.rb fact
</code></pre>
<p>You should obtain the following kind of resulting VCD file:</p>
<p align="center">
<img data-name="hruby_simulator.vcd" src="fact_vcd.png"  width="80%">
</p>
<h4>But in structured programming, it is better to use local variables!</h4>
<p>Indeed, in the factorial program, signals <code>val</code> and <code>res</code> are only used within the sequencer, so why declare them outside it? The code would be more clear if they were declared more locally, i.e., <em>inside</em> it, and even better, inside its main loop. So let us modify it as follows:</p>
<pre><code class="language-ruby">system :fact do
   input :clk, :start, :req
   [5].input :data_in
   output :ack
   [32].output :data_out

   sequencer(clk,start) do
      sloop do
         [4].inner :val
         [24].inner :res

         ack &lt;= 0
         swhile(req != 1)
         val &lt;= data_in
         res &lt;= 1
         swhile(val&gt;1) do
             res &lt;= res*val
             val &lt;= val - 1
         end
         data_out &lt;= res
         ack &lt;= 1
      end
   end
end
</code></pre>
<p>You can simulate it again, and you should obtain the same result. However, if you try to access <code>res</code> or <code>val</code> outside the main loop, then an error will be raised.</p>
<h4>Now about <code>sfor</code></h4>
<p>With a for statement you may expect something like C with the definition of an index, its initialization, and its increment. However, the <code>sfor</code> of HDLRuby is simpler: it only takes as argument an enumerable object and will iterate on each of its elements. An enumerable object is any Ruby enumerable object as well as any signal. For example, the following circuit outputs bit by bit the content of a 32-bit input value:</p>
<pre><code class="language-ruby">system :serializer do
   input :clk, :start, :req
   [32].input :data_in
   output :tx, :data_out

   sequencer(clk,start) do
      tx &lt;= 0
      data_out &lt;= 0
      sloop do
         sif(req) do
            tx &lt;= 1
            sfor(data_in) do |b|
               data_out &lt;= b
            end
            tx &lt;= 0
            data_out &lt;= 0
         end
      end
   end
end
</code></pre>
<p>This circuit takes as input <code>data_in</code> and sends its content bit by bit to <code>data_out</code> when <code>req</code> is set to 1. In detail, it first indicates the beginning of the transmission by setting <code>tx</code> to 1, then from the next clock cycle will send one bit of <code>data_in</code> per clock cycle. When the transmission is over, it sets tx to 0 again. There are a few more details to unwrap:</p>
<ul>
<li><p>By default both <code>tx</code> and <code>data_out</code> are set to 0, this is done at the beginning of the sequencer but also just after the <code>sfor</code>.</p>
</li>
<li><p><code>tx</code> is set to 1 just before the <code>sfor</code> loop, i.e., one cycle before the actual transmission. As said in the description of the <a href="#sequencer-structured">control statements</a>, each of them requires one clock cycle before branching.</p>
</li>
</ul>
<blockquote>
<p>This for loop could also have been implemented using an index as follows:</p>
</blockquote>
<pre><code class="language-ruby">   sfor(0..31) do |i|
      data_out &lt;= data_in[i]
   end
</code></pre>
<blockquote>
<p>However, the advantage of the first version of the code is that it is still valid when the data type of <code>data_in</code> is changed whereas the second version must be rewritten to adjust the range of the index.</p>
</blockquote>
<p>If you want, you can try this serializer, you need to add a module representing the environment. For example:</p>
<pre><code class="language-ruby">system :serializer_bench do
   inner :clk, :start, :req, :tx
   [8].inner :x
   inner :z

   serializer(:serializerI).(clk,start,req,x,tx,z)

   def clk!
       clk &lt;= 0
       !10.ns
       clk &lt;= 1
       !10.ns
   end

      timed do
      start &lt;= 0
      !10.ns
      clk!
      start &lt;= 1
      req   &lt;= 0
      clk!
      start &lt;= 0
      repeat(2) do
          clk!
      end
      req   &lt;= 1
      x     &lt;= _hAB
      clk!
      req   &lt;= 0
      repeat(16) do
          clk!
      end
   end
end
</code></pre>
<blockquote>
<p>There is a new notation: <code>_hAB</code>, this is used for representing fixed bit-width hexadecimal. Since there are two digits, it is an 8-bit value. You can also use binary representations as follows: <code>_b10101011</code>.</p>
</blockquote>
<p>When everything is put in a file named: <code>serializer.rb</code> and simulated as follows:</p>
<pre><code class="language-bash">hdrcc --sim --vcd serializer.rb serializer
</code></pre>
<p>You should obtain the following time chart:</p>
<p align="center">
<img data-name="hruby_simulator.vcd" src="serializer_vcd.png"  width="80%">
</p>
<h4>3.2.3. How to write and use a sequencer function.</h4>
<p>Why not necessarily associated with algorithmic, it is common in software to define functions for code reuse and implementation of recursive algorithms. HDLRuby also provided such kinds of functions, with all the software features, including recursion, using the construct <code>sdef</code>. Such a function is defined as follows:</p>
<pre><code class="language-ruby">sdef :&lt;name&gt; do |&lt;arguments&gt;|
   &lt;body&gt;
end
</code></pre>
<p>In the code above, <code>name</code> is the name of the function, <code>arguments</code> is a list of arguments and <code>body</code> is the code of the function that can be any kind of HDLRuby sequencer code. For returning a value from a function, the <code>sreturn(&lt;value&gt;)</code> command is used. For example, the following describes a function computing the factorial of its argument <code>n</code>:</p>
<pre><code class="language-ruby">sdef :fact do |n|
   sif(n&gt;1) { sreturn(n*fact(n-1) }
   selse    { sreturn(1) }
end
</code></pre>
<p>There is a lot to unpack from this small example:</p>
<ol>
<li><p>Such a function can be defined outside or inside a module, but can only be called within a sequencer.</p>
</li>
<li><p>The arguments of a function, here <code>n</code>, do not have any defined type: their type, and consequently the final implementation of the function, is determined by the data type of the actual arguments when the function is called. For example, in the following code, the data type of the actual argument <code>val</code> is 16-bit unsigned, hence that will be the data type of <code>n</code>.</p>
<pre><code class="language-ruby">[16].inner :val, :res

sequencer do
   val &lt;= 5
   res &lt;= fact(val)
end
</code></pre>
</li>
<li><p>When a function is recursive, a stack is created to store the arguments and the sequencer states for returning at each recursion. The size of this stack is by default set to the bit width of the largest argument, e.g., for <code>fact</code> it is set for supporting 16 recursions. In case of stack overflow, i.e., there were too many recursive calls, the recursion is stopped, and the execution of the sequencer proceeds from just after the last call.</p>
</li>
<li><p>The behavior of the stack can be controlled in two ways when defining a function as follows:</p>
<pre><code class="language-ruby">sdef(:&lt;name&gt;,&lt;size&gt;, proc &lt;error_handler&gt;) do |&lt;arguments&gt;|
   &lt;body&gt;
end
</code></pre>
<p>In the code above, <code>size</code> is the forced size of the stack, and <code>error_handler</code> is a block of code that will be executed when a stack overflow occurs. Both arguments are optional, but if the error handler is provided, then the size must also be provided. For example, the code of the factorial can be rewritten as follows to force the stack to support 64 recursions:</p>
<pre><code class="language-ruby">sdef(:fact,64) do |n|
   sif(n&gt;1) { sreturn(n*fact(n-1) }
   selse    { sreturn(1) }
end
</code></pre>
<p>It can also be defined as follows to support only 8 recursions but to set a signal named <code>stack_overflow</code> to 1 when a stack overflow happens:</p>
<pre><code class="language-ruby">sdef(:fact, 8, proc { stack_overflow &lt;= 1 }) do |n|
   sif(n&gt;1) { sreturn(n*fact(n-1) }
   selse    { sreturn(1) }
end
</code></pre>
</li>
</ol>
<p>Here is a full example using the factorial:</p>
<pre><code class="language-ruby">sdef(:fact,8,proc { stack_overflow_error &lt;= 1 }) do |n|
    sif(n &gt; 1) { sreturn(n*fact(n-1)) }
    selse      { sreturn(1) }
end


# Checking the fact function.
system :module_with_fact do

    inner :clk,:rst

    [16].inner :val
    [16].inner :res
    inner stack_overflow_error: 0

    sequencer(clk.posedge,rst) do
        5.stimes do |i|
            val &lt;= i
            res &lt;= fact(val)
        end
        hprint(&quot;stack_overflow_error=&quot;,stack_overflow_error,&quot;\n&quot;)
    end

    timed do
        clk &lt;= 0
        rst &lt;= 0
        !10.ns
        clk &lt;= 1
        !10.ns
        clk &lt;= 0
        rst &lt;= 1
        !10.ns
        clk &lt;= 1
        !10.ns
        clk &lt;= 0
        rst &lt;= 0
        !10.ns
        clk &lt;= 1
        repeat(500) do
            !10.ns
            clk &lt;= ~clk
        end
    end
end
</code></pre>
<hr>
<p>So now, you know:</p>
<ul>
<li>How to describe fully-fledged algorithms with sequencers using conditional and control statements as well as functions, including recursive ones.</li>
</ul>
<p>Also, if you are not familiar with languages like Ruby or Python, the <code>sfor</code> may look great compared to what C can provide. But this is just the beginning, HDLRuby can do better than that.</p>
<h4>3.2.4. How to use enumerators in a sequencer</h4>
<p>If sometimes you program with Ruby, you may know about enumerators: they are objects used for processing iteratively several elements of objects. The HDLRuby's sequencer provides the same concept: it is possible to build hardware enumerators for any enumerable objects and they will run like Ruby's.</p>
<blockquote>
<p>We recommend before going on with this tutorial you study the Ruby enumerable and enumerators. Indeed, since the HDLRuby enumerators and enumerable objects do reproduce the functionalities of the Ruby ones, we will only point out what is specific to the hardware.</p>
</blockquote>
<h4>First, what is an enumerable?</h4>
<p>So, enumerators iterate over enumerable, but what is it? In HDLRuby, an enumerable is either a Ruby enumerable object, an enumerator (Ruby or HDLRuby), or a signal of any type. If the signal is an array, the iteration will be over its elements, if it is a number, it will be done over its bits. For example, <code>0..2</code> is an enumerable including 0, 1, and 2 as elements, <code>[3,6,7]</code> is one including 3, 6, and 7, and the following signal <code>sig</code> includes 0, 1, 1, 0, 1, 1, 1, 0:</p>
<pre><code class="language-ruby">[8].inner sig: _b01110110
</code></pre>
<h4>Let us build HDLRuby enumerators.</h4>
<p>Like Ruby builds enumerators using the <code>each</code> method and its derivates (<code>each_with_index</code> and so on,) HDLRuby uses the <code>seach</code> method to build its enumerator. For example, an enumerator over the bits of signal <code>sig</code> will be built as follows: <code>sig.seach</code>, and if you want an enumerator with index, just like Ruby: <code>sig.seach_with_index</code>, and so on. Then, an enumerator can be executed when created by providing the block that will be applied on each element like in ruby, or executed later using the <code>seach</code> method again. For example, the following sequencer code first sums the bits of signal sig at once, then does it again later with another enumerator previously stored in the Ruby variable <code>another_enumerator</code>:</p>
<pre><code class="language-ruby">input :clk, :start

[8].inner sig: _b01110110
[4].inner num0, :num1

sequencer(clk,start) do
   another_enum = sig.seach
   num0 &lt;= 0
   num1 &lt;= 0
   sig.seach {|b| num0 &lt;= num0 + b }
   sig &lt;= _hCD
   another_enum.seach {|b| num1 &lt;= num1 + b }
end
</code></pre>
<p>That's all that we will explain here, the remaining is exactly like Ruby. Moreover, almost all the methods related to enumerable and enumerator have been reimplemented in HDLRuby using the prefix <code>s</code>, so please refer to the main documentation of HDLRuby about <a href="README.md#enumerator">enumerators</a> for details. Let us just see a few examples:</p>
<ul>
<li><p>Count the number of 1 bit of a signal - again - but within an infinite loop, and with a much shorter code using the HDLRuby version of the Ruby enumerator method <code>reduce</code>:</p>
<pre><code class="language-ruby">input :clk,:start
[8].input :sin
[4].output :sout

sequencer(clk,start) do
   sloop do
      sout &lt;= sin.sreduce(_h0,&amp;:+)
   end
end
</code></pre>
<p>Here are a couple of remarks about this code:</p>
<ul>
<li><p>You may have noticed that the initial value of reduce is set to a 4-bit 0 (<code>_h0</code>, since a hexadecimal digit is 4-bit). If this value is not set, the data type of the elements will be used for the additions, in this case, 1-bit (and a 1-bit addition is actually an exclusive or).</p>
</li>
<li><p>While the count of the bits is a single-line statement, it is executed like a usual sequencer loop and therefore requires 8 clock cycles to complete.</p>
</li>
</ul>
</li>
<li><p>Fill array <code>ar</code> from input <code>sin</code> one byte per cycle then sort it and output its content one byte per cycle.</p>
<pre><code class="language-ruby">input :clk,:start
[8].input :sin
[8].output :sout

bit[8][-16].inner :ar

sequencer(clk,start) do
   16.stimes {|i| ar[i] &lt;= sin }
   res = ar.ssort
   16.stimes {|i| sout &lt;= res[i] }
end
</code></pre>
<p>In this example, <code>16.stimes</code> generates an enumerator over the <code>0..7</code> range, and is a way to build an enumerator from an integer value. In addition, please notice the use of the Ruby variable <code>res</code> for accessing the signal containing the sort result.</p>
</li>
<li><p>Apply a 4-point FIR filter over an array obtained from input signal <code>sin</code> with 0-padding at the beginning and output the result to <code>sout</code></p>
<pre><code class="language-ruby">input :clk,:start
[8].input :sin
[8].output :sout

bit[8][-4].inner coefs: [_h01,_h05,_h0A,_hFE]
bit[8][-16].inner : ar

sequencer(clk,start) do
   16.stime {|i| ar[i] &lt;= sin }
   sout &lt;= ([_h00]*3).seach + ar.seach).seach_slice(4).sreduce(_h00) do |a,b,c,d|
      a*coefs[0] + b * coefs[1] + c * coefs[2] + d * coefs[3]
   end
end
</code></pre>
<p>In this example, <code>[_h00]*3</code> builds an array of three 8-bit zeros for the padding, <code>seach</code> creates the iterators over this padding. This iterator is added to one over <code>ar</code> which creates a global iterator over them all. <code>seach_slice</code> and <code>sreduce</code> work the same way their Ruby equivalent <code>each_slice</code> and <code>reduce</code> do. Here, since the result is a single byte, it is directly assigned to the output <code>sout</code>, but the following could also have been possible:</p>
<pre><code class="language-ruby">input :clk,:start
[8].input :sin
[8].output :sout

bit[8][-4].inner coefs: [_h01,_h05,_h0A,_hFE]
bit[8][-16].inner : ar
   
res = nil

sequencer(clk,start) do
   16.stime {|i| ar[i] &lt;= sin }
   res = ([_h00]*3).seach + ar.seach).seach_slice(4).sreduce(_h00) do |a,b,c,d|
      a*coefs[0] + b * coefs[1] + c * coefs[2] + d * coefs[3]
   end
end

sout &lt;= res
</code></pre>
<p>Please notice that since the Ruby variable <code>res</code> is used outside the sequencer, it must also be declared outside (<code>res = nil</code>).</p>
</li>
</ul>
<h4>Create your enumerator.</h4>
<p>The method <code>seach</code> and its derivates make it possible to iterate over signals or other enumerable objects. But you can also create your enumerator that can iterate on whatever you want and the way you want. For that purpose, please use the following command:</p>
<pre><code class="language-ruby">&lt;variable&gt; = senumerator(&lt;element type&gt;, &lt;number of elements&gt;) &lt;block&gt;
</code></pre>
<p>Where <code>block</code> is a block of sequencer code for accessing an element by index. For example, the following defines the enumerator named <code>enum0</code> enumerating over the 100 first square numbers in 32-bit:</p>
<pre><code class="language-ruby">enum0 = senumerator(bit[32],100) {|i| i*i }
</code></pre>
<p>It is also possible to put a sequencer control statement in the access block, for example, the following enumerator accesses each bit of signal x waiting for 2 cycles between each access:</p>
<pre><code class="language-ruby">[128].input :x
enum1 = senumerator(bit,x.width) do |i|
   step
   step
   x[i]
end
</code></pre>
<hr>
<p>Now you know:</p>
<ul>
<li><p>You create enumerators.</p>
</li>
<li><p>How to use enumerators for easily building complex algorithms.</p>
</li>
<li><p>How to create your enumerators.</p>
</li>
</ul>
<p>And with that, you may be able to build sequential hardware almost as easily as software. But why bother? Simply because the performance of the resulting hardware is much better than that of software, at least in terms of energy and/or power consumption.</p>
<p>But this is not all: contrary to software, hardware is inherently parallel, a property that has not been considered at all yet. From now on, that will be the main topic of this tutorial. We will start slowly by studying what happens when there are several sequencers.</p>
<h4>3.2.5. What happens when there are several sequencers?</h4>
<h4>General considerations</h4>
<p>You can have as many sequencers as you want in a module, and of course, you can have as many modules as you want in a circuit description. In total, all these sequencers will run independently of one another and in parallel. Furthermore, these parallel sequencers can be controlled by the same clock and start signals or by different ones.</p>
<p>As long as the sequencers do not access the same signals, they will not interfere with one another and what has been explained up to now is enough. However, it is common that the various parts of a circuit cooperate, and therefore exchange information, i.e., access common signals. There are two ways to handle access to the same signal from several sequencers...</p>
<h4>The easy way: stick to a simple rule</h4>
<p>There is a simple rule to follow in hardware design to avoid any trouble when accessing a signal:</p>
<blockquote>
<p>A signal can be read from anywhere at any time, but only one component (e.g., a port connection or a sequencer) can write to a given signal.</p>
</blockquote>
<p>This rule is not absolute as you will see in the <a href="#the-hard-way-arbitrating-between-writes-to-signals">hard way</a> to access signals, but it has the advantage of not requiring any additional hardware construct to be implemented. Hence, we do recommend following this rule as much as possible.</p>
<p>Let us see an example for understanding how several sequencers can interact while following this rule. First, let us consider a sequencer that increases periodically a value and sends it to another sequencer that will count the number of bits of this value and tell the first one to proceed with the increase:</p>
<pre><code class="language-ruby">system :bit_pong do
   inner :clk,:start
   inner :req, :ack
   [4].inner :value
   [3].inner :count

   sequencer(clk,start) do
      req &lt;= 0
      value &lt;= 0
      sloop do
         req &lt;= 1
         swhile(ack != 1)
         value &lt;= value + 1
         req &lt;= 0
      end
   end

   sequencer(clk,start) do
      ack &lt;= 0
      count &lt;= 0
      sloop do
         ack &lt;= 0
         swhile(req != 1)
         count &lt;= value.sreduce(_h0,:+)
         ack &lt;= 1
      end
   end

   def clk!
      !10.ns
      clk &lt;= 1
      !10.ns
      clk &lt;= 0
   end

   timed do
      clk   &lt;= 0
      start &lt;= 0
      clk!
      start &lt;= 1
      clk!
      start &lt;= 0
      repeat(100) { clk! }
   end

end
</code></pre>
<p>If you write this code in a file named <code>bit_pong.rb</code> and simulate it as follows:</p>
<pre><code class="language-bash">hdrcc --sim --vcd bit_pong.rb bit_pong
</code></pre>
<p>You will obtain the following kind of time chart:</p>
<p align="center">
<img data-name="hruby_simulator.vcd" src="bit_pong_vcd.png"  width="80%">
</p>
<p>You may notice a detail that is crucial in hardware: the increase of <code>value</code> by the first sequencer starts not when <code>ack</code> becomes 1, but the next clock cycle. This is the second important rule in hardware design:</p>
<blockquote>
<p>When a signal is read in a clock-synchronized component (e.g., a sequencer), the real value is not the value of the signal at this exact instant, but the one it has a little while before. This is because hardware implementation of signals takes physical time to propagate.</p>
</blockquote>
<p>With this simple rule and enough training, one can easily and efficiently implement a large range of applications. But a few cases do require several components (e.g., sequencers) to write to the same signal. For example, when a resource must be shared among several components. Let us see what can be done in such cases.</p>
<h4>The hard way: arbitrating between writes to signals</h4>
<p>The problem when several components write to the same signal is handling the cases where different values are assigned at the <em>same</em> time. This requires extra arbitration circuitry that must be described by the designer or generated by the synthesis tool. Since there is no general good way of arbitrating, the first option is the most common, but with HDLRuby's sequencer, there is an intermediate solution that does not require designing a new circuit but still lets the designer control the arbitration. It is this approach that is explained here, for the design from scratch of an arbitration please consult tutorials about advanced RTL design.</p>
<h4>The hard way but not so much: shared signals</h4>
<p>The HDLRuby sequencer supports another kind of signal called the <em>shared signals</em>. They are inner signals of a module that can be written to by any number of sequencers without causing any trouble. They are declared like any other inner signals, but using the <code>shared</code> keyword instead of <code>inner</code>. For example, a shared 8-bit signed signal named <code>sh</code> can be declared as follows:</p>
<pre><code class="language-Ruby">signed[8].shared :sh
</code></pre>
<p>After being declared, shared signals can be used exactly like any other inner signals, but without any restriction when written within a sequencer.</p>
<h4>But what about the arbitration?</h4>
<p>By default, the arbitration when writing to a shared signal is blunt: the first declared sequencer that writes to this signal is <strong>the only one</strong> that changes its value. The other sequencers' writes are simply ignored. For example, in the following, code, the value of <code>sh</code> is 55, whatever the second sequencer does:</p>
<pre><code class="language-ruby">signed[8].shared :sh

sequencer(clk,start) do
   sh &lt;= 55
end

sequencer(clk,start) do
   100.stimes { |i| sh &lt;= i }
end
</code></pre>
<p>This is not so useful that way, but you can control that by setting which sequencer has exclusive access using the <code>select</code> method of a shared signal. For example, in the following code, the first sequencer first writes 55 to <code>sh</code> but then gives access to the second one:</p>
<pre><code class="language-ruby">signal[8].shared :sh

sequencer(clk,start) do
   sh &lt;= 55
   sh.select &lt;= 1
end

sequencer(clk,start) do
  100.stimes { |i| sh &lt;= i }
end
</code></pre>
<p>With this code, the value of <code>sh</code> will be at each clock: 55, 1, 2, 3,...</p>
<p>This is simple enough, right? However, there is a limitation: only one sequencer can access to the <code>select</code> of a shared signal... Otherwise, another layer of arbitration is required and we are back to the beginning. Often, this is all right, but sometimes, complex arbitration between several sequencers and several signals makes things messy.</p>
<h4>Enter the global arbiters</h4>
<p>So, you have multiple sequencers fighting with one another for accessing several shared signals, what to do? You need a global arbiter that will decide for everyone. The sequencer library provides such a module, named <code>arbiter</code> that is instantiated like any module. However, it does not have any specific port, instead, it must be connected to the shared signals it will arbitrate. For example, an arbiter named <code>arb01</code> controlling shared signals <code>sh0</code> and <code>sh1</code> can be declared as follows:</p>
<pre><code class="language-ruby">arbiter(:arb01).(sh0,sh1)
</code></pre>
<p>Then, when a sequencer wants to write to either <code>sh0</code> or <code>sh1</code> it must ask the right by sending 1 to the arbiter, and when the access is done, it must release that right by sending 0 so that it does not monopolize the signal. For example, the following sequencers write in turn to the 2-bit shared signal <code>pingpong</code>:</p>
<pre><code class="language-ruby">system :pingpong do
   inner :clk, :start

   [2].shared :pingpong
   arbiter(:arb).(pingpong)

   sequencer(clk,start) do
      sloop do
        arb &lt;= 1
        pingpong &lt;= 1
        step
        arb &lt;= 0
      end
   end
   
   sequencer(clk,start) do
      sloop do
        arb &lt;= 1
        pingpong &lt;= 2
        step
        arb &lt;= 0
      end
   end

   timed do
      clk   &lt;= 0
      start &lt;= 1
      !10.ns
      clk   &lt;= 1
      !10.ns
      clk   &lt;= 0
      start &lt;= 0
      !10.ns
      repeat(20) { clk &lt;= ~clk ; !10.ns }
   end
end
</code></pre>
<p>Now, you should be used to it, so please try to simulate the code above. If you look at the VCD file in detail you will see a lot of signals but not any signal called <code>pingpong</code>. This is because shared signals hide underlining hardware that is exposed at simulation. Usually, what is relevant is the output value of the shared signal, which is called <code>&lt;shared signal name&gt;_out$&lt;number&gt;</code>. For our <code>pingpong</code> it is <code>pingpong_out$2</code>. Hence, you should get the following graph:</p>
<p align="center">
<img data-name="hruby_simulator.vcd" src="pingpong0_vcd.png"  width="80%">
</p>
<p>Well, this is not an interesting result: <code>pingpong</code> is always 1, what about the second sequencer? There are two reasons for this:</p>
<ul>
<li><p>By default, an arbiter gives priority to sequencers in order of declaration.</p>
</li>
<li><p>When a sequencer is denied access, its write access is ignored and that's all.</p>
</li>
</ul>
<p>Here, it happens that both sequencers always write to <code>pingpong</code> at the exact <em>same</em> time and the first one has higher priority. For instance, if the second sequencer were delayed a bit compared to the first one, it would obtain access too:</p>
<pre><code class="language-ruby">system :pingpong do
   inner :clk, :start

   [2].shared :pingpong
   arbiter(:arb).(pingpong)

   sequencer(clk,start) do
      sloop do
        pingpong &lt;= 1
        arb &lt;= 1
        step
        arb &lt;= 0
      end
   end
   
   sequencer(clk,start) do
      step
      sloop do
        pingpong &lt;= 2
        arb &lt;= 1
        step
        arb &lt;= 0
      end
   end

   timed do
      clk   &lt;= 0
      start &lt;= 1
      !10.ns
      clk   &lt;= 1
      !10.ns
      clk   &lt;= 0
      start &lt;= 0
      !10.ns
      repeat(20) { clk &lt;= ~clk ; !10.ns }
   end
end
</code></pre>
<p>And the simulation result should be:</p>
<p align="center">
<img data-name="hruby_simulator.vcd" src="pingpong1_vcd.png"  width="80%">
</p>
<p>Still, it may be annoying that some writes of a sequencer can be ignored. In such a case, you can use a blocking version of the arbiter called the <code>monitor</code>. This module is used like the arbiter, but when write access is required, the sequencer will be blocked until the access is granted. Hence to avoid confusion with the arbiters' syntax, requiring access to a monitor is done by the <code>lock</code> method, and releasing it is done by the <code>unlock</code> one. For example, with the following code, the expected pingpong exchange will happen even when both sequencers try to write at the same time:</p>
<pre><code class="language-ruby">system :pingpong do
   inner :clk, :start

   [2].shared :pingpong
   monitor(:arb).(pingpong)

   sequencer(clk,start) do
      sloop do
        pingpong &lt;= 1
        arb.lock
        arb.unlock
      end
   end
   
   sequencer(clk,start) do
      sloop do
        pingpong &lt;= 2
        arb.lock
        arb.unlock
      end
   end

   timed do
      clk   &lt;= 0
      start &lt;= 1
      !10.ns
      clk   &lt;= 1
      !10.ns
      clk   &lt;= 0
      start &lt;= 0
      !10.ns
      repeat(20) { clk &lt;= ~clk ; !10.ns }
   end
end
</code></pre>
<p>As seen in the example, since the monitor locks processes, no <code>step</code> is required, and the simulation result should be:</p>
<p align="center">
<img data-name="hruby_simulator.vcd" src="pingpong2_vcd.png"  width="80%">
</p>
<blockquote>
<p><strong>WARNING</strong>: while with an arbiter it was of no importance, with a monitor the lock must be made <em>after</em> the shared signal is written, otherwise this value will be taken into account one cycle later.</p>
</blockquote>
<p>By the way, why does HDLRuby provide the arbiters if the monitors do a better job? For performance reasons first: using an arbiter produces a smaller and faster circuit. Also, it is sometimes better not to block a sequencer: for example, maybe you want to write to a shared signal if possible, and if not do something else. this can be done as follows:</p>
<pre><code class="language-ruby">sequencer(clk,start) do
   arb &lt;= 1
   sif(sh.select == arb.cur_priority) { sh &lt;= 2 }
   selse { &lt;do something else&gt; }
   arb &lt;= 0
end
</code></pre>
<p>In the code above, the sequencer checks if it has access by comparing the shared signal selection with its priority (obtained by <code>arb.cur_priority</code>).</p>
<h4>I do not like the priority rule of the arbiter/monitor</h4>
<p>Indeed, sometimes we need to define our priority rules. This can be done when instantiating an arbiter or a monitor in two possible fashions:</p>
<ul>
<li>You can provide your priority table as an array containing the declaration order of the sequencers in order of priority, e.g., for reversing the priority in our example:</li>
</ul>
<pre><code class="language-ruby">arbiter(:arb,[1,0]).(pingpong)
</code></pre>
<ul>
<li>You can provide your policy as a chunk of HDLRuby code whose argument is the declaration order of a sequencer and that returns true if the sequencer is granted priority. Here is an example that switches priority at each acquirement:</li>
</ul>
<pre><code class="language-ruby">inner switch: 1
arbiter(:arb) { |i| switch &lt;= ~switch ; i == switch }.(pingpong)
</code></pre>
<hr>
<p>Now you know:</p>
<ul>
<li><p>That sequencers run in parallel.</p>
</li>
<li><p>How to synchronize them.</p>
</li>
<li><p>How to share resources between them.</p>
</li>
<li><p>How to make intricate deadlocks and how to escape them using arbiters and monitors... Just to make even more intricate ones (trust me with that).</p>
</li>
<li><p>And...</p>
</li>
</ul>
<h4>That's all for this section!</h4>
<p>Congratulations! You know everything about describing a working circuit and using your knowledge of software design, I am sure you can already do great things.</p>
<p>But in hardware, you can go much more into the details for even more performance. So let us go to the more advanced parts of this tutorial.</p>
<h2>4. How to add parallelism to your algorithms</h2>
<p>In software, when you want to do parallelism you usually need specific libraries because the model of computation of software is inherently sequential. But this is not the case with the HDLRuby sequencers because:</p>
<ul>
<li><p><a href="#41-a-sequencer-is-not-a-program">A sequencer is not a program</a></p>
</li>
<li><p><a href="#42-parallel-control-statements-functions-and-enumerators">Adding parallelism is genuine</a></p>
</li>
</ul>
<h3>4.1. A sequencer is not a program</h3>
<p>We said earlier that hardware is inherently parallel and we showed that multiple sequencers run concurrently by default. However, you may want to increase parallelism within an algorithm too: after all, it is what recent processors do, so why not hardware?</p>
<p>To tell the truth, we lied a little when we said that the sequencers were &quot;executing&quot; statements in order. They do not execute anything and statements are not <em>instructions</em>. Rather, they are <em>instantiations</em> of circuits performing basic computations, and the sequencer only schedules when each circuit is to be used. For example, the following code describes two 3-value addition circuits selected respectively at the first and second clock cycles:</p>
<pre><code class="language-ruby">sequencer(clk,start) do
   d &lt;= a + b + c
   step
   z &lt;= u + v + w
end
</code></pre>
<p>Now, what about the following:</p>
<pre><code class="language-ruby">sequencer(clk,start) do
   d &lt;= a + b + c
   z &lt;= u + v + w
end
</code></pre>
<p>... Yes, as said early, when there is no control statement or step, the clock does not advances. That means that both adder circuits are selected at the same time and do &quot;run&quot; in parallel. Then what about the following:</p>
<pre><code class="language-ruby">sequencer(clk,start) do
   d &lt;= a + b + c
   z &lt;= u + v + d
</code></pre>
<p>... This time, <code>z</code> requires the value of <code>d</code>, but both circuits will again be selected at the same time. However, the output of the first one is connected to the third input of the second one: since they are combinatorial, waiting a little bit is enough to obtain the right <code>d</code> input for computing <code>z</code>.</p>
<blockquote>
<p><strong>WARNING</strong>: in hardware design with HDLRuby (and with all similar languages like Verilog VHDL or VHDL,) it is assumed that a clock is slow enough for the relevant combinatorial circuits to complete computation before the next cycle. If this is not the case, the resulting circuits will not function properly. Fortunately, the synthesis frameworks usually provide tools for verifying these timings.</p>
</blockquote>
<h3>4.2. Parallel control statements, functions, and enumerators</h3>
<p>Sequencers provide many constructs for easy control and enumeration. However, those constructs are sequential by construction. What if you would like to do the same in parallel? This is possible, but there is an important restriction:</p>
<blockquote>
<p><strong>WARNING</strong>: there cannot be any loop within a parallel section of an algorithm.</p>
</blockquote>
<h4>4.2.1. Parallel conditionals</h4>
<p>With that being said, even without loops you can do a lot of things. First, let us see parallel conditional and case statements. We already presented the sequential versions: <code>sif</code> and <code>scase</code>. The parallel versions have the same syntax but use an <code>h</code> instead of an <code>s</code>:</p>
<ul>
<li><code>hif(&lt;condition&gt;) &lt;block&gt;</code>: executes <code>block</code> if <code>condition</code> is true (i.e., different from 0).</li>
</ul>
<ul>
<li><code>helsif(&lt;condition&gt;) &lt;block&gt;</code>: executes <code>block</code> if the conditions of the previous <code>hif</code> and <code>helsif</code> are false and if the current <code>condition</code> is true.</li>
</ul>
<ul>
<li><p><code>helse &lt;block&gt;</code>: executes <code>block</code> if the conditions of the previous <code>hif</code> and <code>helsif</code> are false (i.e., equals 0). It is also used for giving the default block for the <code>hcase</code> statement (see below).</p>
</li>
<li><p><code>hcase(&lt;choice&gt;)</code>: initializes a multiple case statement.</p>
</li>
</ul>
<blockquote>
<p><strong>WARNING</strong>: these are parallel statements, hence their blocks <strong>CANNOT</strong> contain any sequential statement like <code>step</code>, <code>sif</code>, <code>sloop</code>, or even <code>sbreak</code>.</p>
</blockquote>
<p>However, they have the advantage of not waiting for the next clock cycle, hence high-speed algorithms can be devised when using them. For example, the following assigns to <code>d</code> the max of signals <code>u</code>, <code>v</code>, and <code>w</code> in less than one cycle:</p>
<pre><code class="language-ruby">   sequencer(clk,start) do
      hif(u &gt; v) do
         hif(u &gt; w) { d &lt;= u }
     helse      { d &lt;= w }
      end
      helsif(v &gt; w) { d &lt;= v }
      helse         { d &lt;= w }
      ...
   end
</code></pre>
<h4>4.2.2. Yes, but without loops, we are quite limited no?</h4>
<p>There is a whole range of computations that do not require any loop: the <em>dataflow</em> computations. Indeed, more often than not, in software programs, the loops like <code>for</code> or <code>while</code> are only there for ease of design or conciseness of code, and do not have any algorithmic purpose. For example, if you want to pick up the max value of a fixed-sized array, you do not need a loop for that... Heh, we just did that in the previous section (just replace <code>u</code>, <code>v</code>, and <code>w</code> with <code>ar[0]</code>, <code>ar[1]</code>, and <code>ar[2]</code>).</p>
<p>Still, the code of the previous section was only for three variables, and the code was already a bit messy. Fortunately, you can use Ruby for this purpose... Do you remember? In HDLRuby, Ruby code is executed at compile time, so Ruby loops or iterators can be used to produce complex hardware descriptions cleanly. However...</p>
<blockquote>
<p><strong>WARNING</strong>: Ruby code itself does not generate nor interact with hardware, for obtaining real hardware description you <strong>must</strong> put HDLRuby code within the Ruby loops.</p>
</blockquote>
<p>Also:</p>
<blockquote>
<p><strong>WARNING</strong>: Ruby iterators <strong>do not</strong> apply on HDLRuby construct. But, you can convert an HDLRuby signal to a Ruby array for applying Ruby iterators on it. For that purpose, please use the <code>to_a</code> method.</p>
</blockquote>
<p>Let us wrap everything we said with a sequencer selecting in parallel the largest element of an array signal of sixteen 8-bit elements:</p>
<pre><code class="language-ruby">system :maxxer do
   inner :clk, :start

   bit[8][-8].inner ar: [ _h05, _hA3, _h54, _h2F, _h33, _hE4, _h6B, _h1C ]
   bit[8].inner :ar_max

   sequencer(clk,start) do
      ar_max &lt;= 0
      ar.to_a.each do |e|
         hif(ar_max &lt; e) { ar_max &lt;= e }
      end
   end

   timed do
      clk   &lt;= 0
      start &lt;= 1
      !10.ns
      clk   &lt;= 1
      !10.ns
      clk   &lt;= 0
      start &lt;= 0
      !10.ns
      repeat(20) { clk &lt;= ~clk ; !10.ns }
   end
end
</code></pre>
<p>The simulation result should be:</p>
<p align="center">
<img data-name="hruby_simulator.vcd" src="maxxer_vcd.png"  width="80%">
</p>
<p>As promised, the max is obtained at the first cycle of the sequencer execution!</p>
<p>However, the code given below will not produce anything other than setting <code>ar_max</code> to 0, because the Ruby <code>max</code> method does not use any HDLRuby code:</p>
<pre><code class="language-ruby">   sequencer(clk,start) do
      ar_max &lt;= 0
      ar.to_a.max
   end
</code></pre>
<p>So, you can use <code>each</code> but not <code>max</code>... Why? Because the <code>max</code> method does the comparison between elements at HDLRuby compile time and does not generate any hardware. More generally:</p>
<blockquote>
<p>If the method iterates without any <strong>implicit</strong> computation, then it can be used for parallel HDLRuby description.</p>
</blockquote>
<p>Yes, this is becoming confusing because it is hard to know what Ruby does when executing its methods. Unfortunately, there is nothing to help with that yet, but we hope to clarify things in future versions of HDLRuby. For now, if unsure, it is recommended to stick to the following Ruby methods:</p>
<ul>
<li><p><code>each</code>, <code>each_cons</code>, <code>each_slice</code></p>
</li>
<li><p><code>reduce</code> (or <code>inject</code>)</p>
</li>
<li><p><code>zip</code></p>
</li>
</ul>
<h4>4.2.3. Can functions be parallel too?</h4>
<p>As explained before, the body of a <code>sdef</code> function can contain any kind of sequencer code, hence parallel code is also possible. Yet, calling and returning from such a function are themselves sequential procedures that require several cycles to be performed. Hence, there exists a parallel version of <code>sdef</code> whose call and return as well as its body execution is fully combinatorial. It is declared as follows:</p>
<pre><code class="language-ruby">hdef :&lt;name&gt; do |&lt;arguments&gt;|
   &lt;body&gt;
end
</code></pre>
<p>As you can see, the declaration is identical to the <code>sdef</code> one. However the behavior is different, and this new kind of function has the following limitations:</p>
<ol>
<li><p>It cannot contain any sequential code, i.e., constructs like <code>step</code>, <code>sif</code> or <code>sloop</code>.</p>
</li>
<li><p>It does not support the <code>sreturn</code> constructs either, instead, it is the last value computed by the function that is returned.</p>
</li>
<li><p>It cannot be recursive.</p>
</li>
</ol>
<p>Here is an example of a parallel-compatible function counting the number of ones in the input argument:</p>
<pre><code class="language-ruby">hdef :popcount do |n|
   n.each.reduce(_b0.as(n.type),&amp;:+)
end
</code></pre>
<p>In the code above, it can be seen that no return is provided but instead, it will be the result of the parallel sum result that will be returned since it is the last computation of the function. Also, the data type of the sum is obtained from the argument <code>n</code> (<code>as(n.type)</code>).</p>
<hr>
<p>Now you know:</p>
<ul>
<li><p>How to introduce parallelism within a sequencer.</p>
</li>
<li><p>How to define a parallel-compatible function using <code>hdef</code></p>
</li>
</ul>
<p>But, by the way, why bother with sequential code if parallel one is faster?</p>
<h4>4.2.4. Parallel is faster, so why do sequential computations?</h4>
<p>Why parallel dataflow computations are indeed faster than sequential ones, in theory, they also have some drawbacks.</p>
<ul>
<li><p>First, not every algorithm can be implemented by a dataflow computation. For example, the initial sequencer example that counts the clock cycles is necessarily sequential. More generally, any algorithm that has as input or output a sequence of values must be sequential. But that is not all:</p>
<blockquote>
<p>Any algorithm that processes data of arbitrary size requires at least partly some sequential computation.</p>
</blockquote>
<p>For example, how can you process a text whose size is unknown without any sequential computation... You can say, OK, let us first look for the end of the text and then we can process it in parallel but wait... Looking for this end will require some sequential processing, e.g., looking at one character after the other if it is the end (EOF).</p>
</li>
<li><p>Second, parallel implementation of algorithms requires much more chip area than sequential ones. This is expensive, and there are some physical limitations with the size of a chip.</p>
</li>
<li><p>Third, while faster in theory, parallel implementations may end slower than sequential ones in practice. This is because, the larger a combinatorial circuit is, the longer its delays are.</p>
</li>
</ul>
<p>Now, the big question is: how do we know which part of our circuit would better be parallel?</p>
<blockquote>
<p>Unfortunately, the best answer is the designer's experience.</p>
</blockquote>
<p>Indeed, some design tools can decide for you, but the solution they give may not match your expectations. For HDLRuby, the idea is to let the designer decide but help him with as easy to use as possible sequential and parallel constructs.</p>
<h4>That's all for this section!</h4>
<p>That was short this time because almost all had been already said in the previous sessions. But now it is time to go past the sequencers and dive into real RTL design.</p>
<h2>5. Toward lower level hardware design: the processes</h2>
<p>Why sequencers are easy to use with a software mindset, they are implemented on top of a control circuit that schedules their operations. While this circuit does not represent much overhead, you may want top-notch optimizations, or simply you may want more precise control over what hardware will be produced. It is therefore time to leave the comfort of the sequencer and study genuine hardware description constructs: the <em>processes</em>. Things will become more difficult, but here is an attempt to do it progressively:</p>
<ul>
<li><p><a href="#51-what-are-the-processes">What are the processes?</a></p>
</li>
<li><p><a href="#52-what-are-the-connection-processes">What are the connection processes?</a></p>
</li>
<li><p><a href="#53-what-are-the-combinatorial-processes">What are the combinatorial processes?</a></p>
</li>
<li><p><a href="#54-what-are-the-clocked-processes">What are the clocked processes?</a></p>
</li>
<li><p><a href="#55-what-about-the-control-statements-in-processes">What about the control statements in processes?</a></p>
</li>
<li><p><a href="#56-how-to-share-signals-in-processes">How to share signals in processes?</a></p>
</li>
</ul>
<h3>5.1. What are the processes?</h3>
<p>First, we must make things clear:</p>
<blockquote>
<p>Processes in hardware have very little (nothing?) to do with any kind of software process.</p>
</blockquote>
<p>In hardware, a process is a list of data flow statements that are activated (we would say <em>executed</em> if they were software instructions) on a common condition.</p>
<blockquote>
<p>By data flow statements, we mean all the assignment statements, the <code>hif</code>, <code>helse</code>, <code>hcase</code> and <code>hwhen</code> statements, and the calls to <code>hdef</code> functions.</p>
</blockquote>
<p>Depending on the activation condition, there are three kinds of processes:</p>
<ul>
<li><p>The connection processes (in HDLRuby they are considered to be processes)</p>
</li>
<li><p>The combinatorial processes</p>
</li>
<li><p>The clocked processes</p>
</li>
</ul>
<p>We also saw earlier the timed processes, they are indeed kinds of processes, but they do not represent hardware and are therefore not considered in this section.</p>
<p>We will detail these three kinds of hardware processes in further sections, but there is another property to discuss before: that is the way the data flow statements are scheduled within a process. Like with the sequencer between clock cycles, everything is parallel, but unlike it, there are two possible ways for handling dependencies:</p>
<ul>
<li><p>Blocking assignments scheduling where the result of a statement can be used directly as input of the following statements. Such processes are declared with the <code>seq</code> keyword.</p>
</li>
<li><p>Non-blocking assignments where all the statements are independent of each other. Such processes are declared with the <code>par</code> keyword.</p>
</li>
</ul>
<p>For example, if we assume that the initial value of <code>x</code> is 1 and that the initial value of <code>y</code> is 0, when the following process is activated, the value of <code>z</code> will become 4:</p>
<pre><code class="language-ruby">seq(&lt;activation condition&gt;) do
   y &lt;= x + 1
   z &lt;= y + 2
end
</code></pre>
<p>Whereas, with the following process, <code>z</code> will become 2, i.e., it will be the result of the addition of the initial value of <code>y</code> which is still 0:</p>
<pre><code class="language-ruby">par(&lt;activation condition&gt;) do
   y &lt;= x + 1
   z &lt;= y + 2
end
</code></pre>
<blockquote>
<p>There is a couple of caveats with the non-blocking processes. First, only the last assignment prevails when a signal is assigned multiple times. For example, with the following process, assuming the same initial values for x and y as before, z will become 3 and not 2:</p>
</blockquote>
<pre><code class="language-ruby">par(&lt;activation condition&gt;) do
   y &lt;= x + 1
   z &lt;= y + 2
   z &lt;= y + 3
end
</code></pre>
<blockquote>
<p>Second, the order of statements assigning to different values does not affect the result. For example, the following process is identical to the previous one:</p>
</blockquote>
<pre><code class="language-ruby">par(&lt;activation condition&gt;) do
   z &lt;= y + 2
   z &lt;= y + 3
   y &lt;= x + 1
end
</code></pre>
<blockquote>
<p>But this one is different (we switched two assignments to the same signal):</p>
</blockquote>
<pre><code class="language-ruby">par(&lt;activation condition&gt;) do
   y &lt;= x + 1
   z &lt;= y + 3
   z &lt;= y + 2
end
</code></pre>
<p>Now let us see the different kinds of processes in detail.</p>
<h3>5.2. What are the connection processes?</h3>
<p>We already mentioned the connections at the beginning of this tutorial about how to <a href="#circuit-use">reuse circuits</a>. Each connection is considered to be a standalone process. Such a process is continuously activated, and its left value is <em>always</em> equal to its right value.</p>
<p>Since the connection processes are one-statements only, they do not require a <code>seq</code> or <code>par</code> keyword. For example, the following module includes two connections to its output ports:</p>
<pre><code class="language-ruby">system :a_system_with_cnx do
   [8].input :x, :y
   [8].output :u,:v

   u &lt;= x + y
   v &lt;= x - y
end
</code></pre>
<h3>5.3. What are the combinatorial processes?</h3>
<p>These processes are declared with a <code>seq</code> or a <code>par</code> keywords with a list of signals as activation conditions. They have activated each time one or more signals of their activation condition changed value. For example, the following process will only be activated when <code>x</code> or <code>y</code> changes value, but not when <code>z</code>, <code>u</code> or <code>v</code> does:</p>
<pre><code class="language-ruby">par(x,y) do
   u &lt;= x + z
   v &lt;= y - z
end
</code></pre>
<p>Another kind of combinatorial process is activated each time a signal its computations depend on changes in value. They are declared with the <code>seq</code> or <code>par</code> keywords without any activation condition. For example, the following process will be activated when <code>x</code>, <code>y</code>, or <code>z</code> change value:</p>
<pre><code class="language-ruby">par do
   u &lt;= x + z
   v &lt;= y - z
end
</code></pre>
<p>Here is a more practical example: a circuit that computes the 8-bit checksum of an input 32-bit vector.</p>
<pre><code class="language-ruby">system :checksum do
   [32].input :x
   [32+8].output :z

   [8].inner :sum

   seq do
      sum &lt;= x[31..24] ^ x[23..16] ^ x[15..8] ^ x[7..0]
      z &lt;= [x,sum]
   end
end
</code></pre>
<p>In this code, the statement <code>z &lt;= [x,sum]</code> concatenates the value of <code>x</code> with the value of <code>sum</code> using the concatenation operator <code>[]</code>.</p>
<blockquote>
<p>Please note that the concatenation operator is different from the access operator even if they use the same characters: the syntax <code>&lt;sig&gt;[&lt;integer or range]</code> is the access operator, and the syntax <code>[&lt;list of signals or values&gt;]</code> is the concatenation operator.</p>
</blockquote>
<p>You can check this module with the following simulation environment:</p>
<pre><code class="language-ruby">system :checksum_sim do
   [32].inner :x
   [40].inner :z

   checksum(:checksumI).(x,z)

   timed do
      x &lt;= 0
      !10.ns
      x &lt;= _h34F4AC68
      !10.ns
   end
end
</code></pre>
<p>The simulation result should be:</p>
<p align="center">
<img data-name="hruby_simulator.vcd" src="checksum_vcd.png"  width="80%">
</p>
<p>That is to say that the checksum of <code>x</code> is <code>04</code> appended at the end of <code>z</code>.</p>
<h4>Combinatorial processes that cannot become combinatorial circuits.</h4>
<p>In the final hardware, a circuit whose output signals are also used as inputs is <strong>not</strong> a combinatorial circuit, and may not be a viable circuit at all. Such non-combinatorial circuits are used for making memory points (e.g., registers), or local synchronization (e.g., C elements). It is possible to describe such an element with a combinatorial process: it is enough to make a signal dependent on itself in a process. For example, for both combinatorial processes, signals <code>x</code> and <code>u</code> depend on themselves, and are therefore not describing combinatorial circuit:</p>
<pre><code class="language-ruby">par do
   x &lt;= x + 1
end

seq do
  u &lt;= v + 1
  v &lt;= u + w
end
</code></pre>
<blockquote>
<p><strong>WARNING</strong>: while such processes are accepted in HDLRuby (as well as in other hardware description languages like Verilog HDL), it is strongly recommended <strong>not</strong> to use them because the behavior of the resulting circuit is hard to predict. If you want to use memory elements, you should use the clocked processes instead.</p>
</blockquote>
<h3>5.4. What are the clocked processes?</h3>
<p>These processes are declared with the <code>par</code> or <code>seq</code> keyword with a list of signal edges as an activation condition. There are two kinds of signal edges:</p>
<ul>
<li><p>The positive edges indicate changes in single-bit signals from 0 to 1. They are noted as follows: <code>sig.posedge</code> where <code>sig</code> is a single-bit signal.</p>
</li>
<li><p>The negative edges indicate changes in single-bit signals from 1 to 0. They are noted as follows: <code>sig.negedge</code> where <code>sig</code> is a single-bit signal.</p>
</li>
</ul>
<p>These processes are usually used for describing parts of circuits that are synchronized by a global clock. This includes the cases where you want to memorize a value.</p>
<p>Here is a simple example for illustrating this kind of process:</p>
<pre><code class="language-ruby">system :clock_counter do
   input :clk, :run
   [32].output :count

   par(clk.posedge) do
       hif(run) { count &lt;= count + 1 }
       helse    { count &lt;= 0 }
   end
end

system :clock_counter_sim do
   inner :clk, :run
   [32].inner :count

   clock_counter(:clock_counterI).(clk,run,count)

   timed do
      clk &lt;= 0
      run &lt;= 0
      !10.ns
      clk &lt;= 1
      !10.ns
      run &lt;= 1
      repeat(30) { clk &lt;= ~clk ; !10.ns }
   end
end
</code></pre>
<p>The result should be:</p>
<p align="center">
<img data-name="hruby_simulator.vcd" src="clock_counter_vcd.png"  width="80%">
</p>
<p>Did you get what the <code>clock_counter</code> circuit does? Yes, it simply counts the number of the positive edge of the signal <code>clk</code> when <code>run</code> is 1: signal <code>count</code> is initialized at 0 when declared, then the process which is activated on each positive edge of <code>clk</code> increases this signal by one. If you remember the sequencers, these clocked processes should look somewhat similar. Indeed, sequencers are built upon such processes. However, within processes, the fancy control statements like <code>sif</code>, <code>sloop</code>, or the enumerators <strong>cannot</strong> be used.</p>
<p>As seen in this code, a previously seen control statement has been used: the <code>hif</code>. Yes, this statement was used for parallel computation in sequencers... But more generally, are there any other control statements that can be used in processes?</p>
<h3>5.5. What about the control statements in processes?</h3>
<p>There is not much to say in this section... Because all has been said in the section about <a href="#parallelism">parallelism in sequencer</a>. The fact is all the constructs described in this previous section were initially designed for the processes, and by extension could also be used in sequencers.</p>
<p>These statements can be used for both clocked processes and combinatorial processes. For example, the following is a combinatorial circuit that implements a simple ALU (Arithmetic and Logic Unit), able to perform the addition, the subtraction, the bitwise AND, and the bitwise OR of the two input values, while the operation is selected by a third input signal.</p>
<pre><code class="language-ruby">system :alu do
   [8].input :x,:y
   [2].input :opr
   [8].output :z

   par do
      hcase(opr)
      hwhen(0) { z &lt;= x + y }
      hwhen(1) { z &lt;= x - y }
      hwhen(2) { z &lt;= x &amp; y }
      hwhen(3) { z &lt;= x | y }
   end
end
</code></pre>
<p>This circuit is combinatorial, hence every time <code>x</code>, <code>y</code>, or <code>opr</code> change value, <code>z</code> will also instantaneously change (in reality, there is a small physical delay that is not simulated).</p>
<p>You can check it as follows:</p>
<pre><code class="language-ruby">system :alu_sim do
   [8].inner :x, :y
   [2].inner :opr
   [8].inner :z

   alu(:aluI).(x,y,opr,z)

   timed do
      x &lt;= _h2A
      y &lt;= _h31
      opr &lt;= 0
      !10.ns
      opr &lt;= 1
      !10.ns
      opr &lt;= 2
      !10.ns
      opr &lt;= 3
      !10.ns
   end
end
</code></pre>
<p>The result should be:</p>
<p align="center">
<img data-name="hruby_simulator.vcd" src="alu_vcd.png"  width="80%">
</p>
<p>...So we can do controls with processes, but what about sharing signals?</p>
<h3>5.6. How to share signals in processes?</h3>
<p>This was the last feature of the sequencer: signals that can be written to by multiple sequencers. But can we do the same with processes?</p>
<ul>
<li><p>The short answer is no: the shared signals and the arbiter or monitor constructs can only be used in sequencers.</p>
</li>
<li><p>The long answer is yes, there are even two possible ways, but you will have to describe the underlying hardware from scratch.</p>
</li>
</ul>
<h4>5.6.1. The first way: use a multiplexer.</h4>
<p>A multiplexer is a circuit that selects one input among several ones to be output. Usually, this is done according to an additional input that indicates the number of the selected input. In HDLRuby, there are two simple ways to describe multiplexers:</p>
<ul>
<li><p>The use of the <code>hcase</code> statements. We had an example previously with the ALU:</p>
<pre><code class="language-ruby">system :alu do
   [8].input :x,:y
   [2].input :opr
   [8].output :z

   par do
      hcase(opr)
      hwhen(0) { z &lt;= x + y }
      hwhen(1) { z &lt;= x - y }
      hwhen(2) { z &lt;= x &amp; y }
      hwhen(3) { z &lt;= x | y }
   end
end
</code></pre>
<p>With this example, all the operations are performed in parallel, and the <code>hcase</code> statement selects which result is to be sent to <code>z</code> according to the selection signal <code>opr</code>.</p>
</li>
<li><p>The use of the <code>mux</code> operator that has the following syntax: <code>mux(&lt;selection&gt;,&lt;input 0&gt;,&lt;input 1&gt;, ...)</code> where <code>selection</code> is the selection signal, and the other arguments are the possible inputs. The same ALU circuit can therefore be described as follows:</p>
<pre><code class="language-ruby">system :alu do
   [8].input :x,:y
   [2].input :opr
   [8].output :z

   z &lt;= mux(opr, x+y, x-y, x &amp; y, x | y)
end
</code></pre>
<p>A connection is used instead of a combinatorial process for this second example since there is a single statement.</p>
</li>
</ul>
<h4>5.6.2. The second way: use of tri-state bus <a name="tri-state"></a></h4>
<p>Multiplexers are easy to describe and use, but their size grows exponentially with the number of inputs and linearly with their bit width. Moreover, the number of inputs of a chip is often strongly limited. For all these reasons, an alternative is sometimes used: the tri-state buses. They are signals where several processes or circuits can write a value provided that only one does it at a time and that when not writing the accesses are set in high impedance.</p>
<blockquote>
<p>Before explaining further the tri-state buses, we need to clarify a possible misconception about hardware values: we often spoke about bits, and you may have assumed that their possible values were 0 or 1 for standard boolean logic. However, in hardware design it is common to use a 4-valued logic that represents the relevant states of a wire in a circuit:</p>
</blockquote>
<ul>
<li><p><code>0</code> for ground level, used for representing <code>false</code> or the digit <code>0</code>;</p>
</li>
<li><p><code>1</code> for power supply level, used for representing <code>true</code> or the digit <code>1</code>;</p>
</li>
<li><p><code>Z</code> for high impedance, used in tri-state buses;</p>
</li>
<li><p><code>X</code> for undefined level, usually indicating a problem in the circuit or an uninitialized state.</p>
</li>
</ul>
<p>Physically, when a signal is set to the <code>Z</code> state, it is possible to safely write another value on it, its state becoming this written value. Such a signal is then called a tri-state signal or bus.</p>
<p>Tri-state signals can be <code>inner</code> or <code>inout</code>, and as long as there are no simultaneous <code>0</code> or <code>1</code> writes on them, they can be used freely... In theory. However, in practice, synthesis tools prioritize safety over flexibility and will reject several descriptions that should work. This is highly dependent on the tool you are using, hence we cannot give precise guidelines for the proper use of such signals. Instead, here is an example of tri-state bus usage that should work with a majority of the design tools, please feel free to adapt it to your needs:</p>
<pre><code class="language-ruby">system :ram8 do
    input :clk, :en, :rwb
    [8].input :addr
    [8].inout :data

    bit[8][-2**8].inner :content

    [8].inner :tmp

    par do
       hif(en &amp; rwb) { data &lt;= tmp }
       helse         { data &lt;= _bZZZZZZZZ }
    end

    par(clk.posedge) do
        hif(en) do
            # Read case
            hif(rwb)   { tmp &lt;= content[addr] }
            helse      { content[addr] &lt;= data }
        end
    end
end

system :ram8_sim do
    inner :clk, :en, :rwb
    [8].inner :addr, :data

    [8].inner :value

    ram8(:ram8I).(clk,en,rwb,addr,data)

    par do
       hif(en &amp; ~rwb) { data &lt;= value }
       helse          { data &lt;= _bZZZZZZZZ }
    end

    timed do
        addr  &lt;= 0
        en    &lt;= 0
        rwb   &lt;= 1
        value &lt;= 0
        clk   &lt;= 0
        !10.ns
        clk   &lt;= 1
        !10.ns
        repeat(256) do
            en  &lt;= 1
            rwb &lt;= 1
            clk &lt;= 0
            !10.ns
            clk   &lt;= 1
            !10.ns
            en    &lt;= 0
            addr  &lt;= addr + 1
            value &lt;= value + 1
            clk   &lt;= 0
            !10.ns
            clk   &lt;= 1
            !10.ns
            en  &lt;= 1
            rwb &lt;= 0
            clk &lt;= 0
            !10.ns
            clk &lt;= 1
            !10.ns
            en &lt;= 0
            clk &lt;= 0
            !10.ns
            clk &lt;= 1
            !10.ns
        end
    end
end
</code></pre>
<p>And the simulation result should be:</p>
<p align="center">
<img data-name="hruby_simulator.vcd" src="ram_vcd.png"  width="80%">
</p>
<p>The first module is an 8-bit address 8-bit data RAM with a single data bus for both reading and writing. When the RAM is not read (<code>en</code> is 0 or <code>rwb</code> is 0), the data bus is set to <code>Z</code>. The second module simply accesses the RAM, and for that purpose uses a process specifically for writing to the data bus: when a write operation is performed (<code>en</code> is 1 for activating the access to the RAM and <code>rwb</code> is set to 0), the value is written to the bus, otherwise, a value is nonetheless written but it is a <code>Z</code> value. The coding style of this process is crucial for ensuring synthesis tools will succeed: we cannot guarantee it will work if it is described differently.</p>
<h4>This section may have been quite a leap from the software mindset...</h4>
<hr>
<p>But, now you may understand:</p>
<ul>
<li><p>How to describe low-level hardware with HDLRuby with processes.</p>
</li>
<li><p>The existence of three kinds of processes: the connections, combinatorial, and clocked processes.</p>
</li>
<li><p>How to use controls in processes.</p>
</li>
<li><p>How to write several values to a single signal without the comfort brought by the sequencers and their shared signals.</p>
</li>
<li><p>What is a tri-state bus and how to use it.</p>
</li>
</ul>
<p>With that, you have all the constructs required for describing optimized hardware. Of course, mastering them requires a lot of know-how, but this is out of the scope of this tutorial. To go further, please follow lessons about hardware design using popular hardware description languages like Verilog HDL or VHDL since what you can do with them, you can do it with HDLRuby.</p>
<p>However, there remain a few major features for more efficient coding inherited from the Ruby language.</p>
<h2>6. Not enough? What about genericity, object orientation, metaprogramming, and reflection?</h2>
<p>Let us imagine you spent hours designing a circuit processing 8-bit values for outputting a 16-bit result and you learn that the input should be 16-bit and the output 8-bit. Well, that's not so tough, you just need to modify the data types in your circuit description... <strong>everywhere</strong>. When you just finished, you learn that it would be great if there was also another version of the circuit that could output flags about the result. Ok, so let us make another version of the circuit, and since it is not so different, let us do some copy and paste, and then make modifications for the flags... But whoop! You did not notice that with your modifications you unintentionally modified a few lines of code introducing new bugs... And of course, you realize it after hours of testing.</p>
<p>Such situations happen all the time in software design... But it is much worse in hardware. Indeed, due to the variety of hardware circuits, it is very common to want to reuse a design with different bit widths. This is why, existing hardware description language supports genericity to a certain degree. However, HDLRuby ruby goes further in terms of genericity, and also adds object-oriented programming, metaprogramming, and reflection concepts to maximize the possibilities of code reuse. From now on, let us detail:</p>
<ul>
<li><p><a href="#61-genericity-in-hdlruby">Genericity in HDLRuby</a></p>
</li>
<li><p><a href="#62-object-oriented-programming-in-hdlruby">Object-oriented programming in HDLRuby</a></p>
</li>
<li><p><a href="#63-metaprogramming-and-reflection-in-hdlruby">Metaprogramming and reflection in HDLRuby</a></p>
</li>
</ul>
<h3>6.1. Genericity in HDLRuby</h3>
<p>In HDLRuby, genericity is supported through the <em>generic module</em> constructs. These constructs describe circuits like standard module does but with the addition of parameters that control their content. They are declared as follows:</p>
<pre><code class="language-ruby">system :&lt;name&gt; do |&lt;list of parameters&gt;|
   &lt;some hardware description code&gt;
end
</code></pre>
<p>The list of parameters is simply a list of variable names that can represent anything, e.g., some values of any type, some data types, or even some chunks of Ruby or HDLRuby code.</p>
<p>Before being used, a generic module must be specialized by specifying each of its parameters. This is done as follows:</p>
<pre><code class="language-ruby">&lt;generic system&gt;(&lt;list of objects&gt;)
</code></pre>
<p>Where <code>generic system</code> is the name of the generic module to specialize.</p>
<p>And there is nothing more to explain since there is no restriction with the parameters. Instead, here are a couple of examples. First, a module counting the clock cycles whose counter bit width is a generic parameter:</p>
<pre><code class="language-ruby">system :counter do |size|
   input :clk, :rst
   [size].output :count

   par(clk.posedge) do
      hif(rst) { count &lt;= 0 }
      helse    { count &lt;= count + 1 }
   end
end
</code></pre>
<p>If you want to instantiate this circuit, you will need first to specialize it. For example, here are two instances, named <code>counterI8</code> and <code>counterI16</code> that have respectively a 8-bit and a 16-bit output:</p>
<pre><code class="language-ruby">counter(8).(:counterI8)
counter(16).(:counterI16)
</code></pre>
<p>The second example is again a counter of clock cycles but whose full data type of the output is a generic parameter (not only its size), and which has a given value that when reached triggers some hardware code also provided as a generic parameter:</p>
<pre><code class="language-ruby">system :counter_ext do |typ,trig,code|
   input :clk, :rst
   typ.output :count

   seq(clk.posedge) do
      hif(rst) { count &lt;= 0 }
      helse do
         count &lt;= count + 1
         hif(count == trig) { code.call(count) }
      end
   end
end
</code></pre>
<p>There is more to unwrap here:</p>
<ul>
<li><p><code>typ</code> is the data type of the output, and is therefore used as is for declaring <code>count</code></p>
</li>
<li><p><code>trig</code> is the value that will activate the hardware provided as a generic parameter.</p>
</li>
<li><p><code>code</code> is a chunk of HDLRuby code. To paste this code chunk, the <code>call</code> method is used, and for giving access to the <code>count</code> signal to this code chunk, it is passed as an argument of the method.</p>
</li>
</ul>
<p>And here is one instance of this module called <code>counter_extI</code>, with a 16-bit signed output, a trigger at value 5, and a triggered code that sets the count to -4:</p>
<pre><code class="language-ruby">system :counter_ext_sim do
   inner :clk,:rst
   signed[16].inner :count
   counter_ext(signed[16],5, proc { |count| count &lt;= -4 }).(:counter_extI).(clk,rst,count)

   timed do
      clk &lt;= 0
      rst &lt;= 0
      !10.ns
      clk &lt;= 1
      !10.ns
      clk &lt;= 0
      rst &lt;= 1
      !10.ns
      clk &lt;= 1
      !10.ns
      clk &lt;= 0
      rst &lt;= 0
      repeat(20) { !10.ns; clk &lt;= ~clk }
      !10.ns
   end
end
</code></pre>
<p>In this code, the syntax <code>proc &lt;block&gt;</code> is for creating a chunk of HDLRuby (or Ruby) code from the content of <code>block</code>. With this environment, the simulation result should be:</p>
<p align="center">
<img data-name="hruby_simulator.vcd" src="counter_ext_vcd.png"  width="80%">
</p>
<h3>6.2. Object-oriented programming in HDLRuby</h3>
<p>Genericity allows using a single design for several different circuits but it does not allow modifying this design. This possibility is brought by object-oriented programming and its key concept: <a href="#621-inheritance">inheritance</a>. With it, it is possible to modify afterward a circuit design without touching the original description, to define a new circuit based on an original one without redoing everything from scratch, and to change a single instance of a circuit without influencing the other ones, all that with a simple <a href="#622-modifying-a-module-or-an-instance">construct</a>. Finally, it is possible under certain conditions to <a href="#623-overriding">reimplement parts of the code</a>.</p>
<h4>6.2.1 Inheritance</h4>
<p>In HDLRuby, inheritance can be applied to modules. When a module inherits from another one, the latter is called its <em>superclass module</em>. By default, a module contains all the ports and all the content of its superclass modules. Then, new ports or content can be added to the later at will. Inheritance is declared as follows:</p>
<pre><code class="language-ruby">system :&lt;name&gt;, &lt;list of superclass modules&gt; &lt;block&gt;
</code></pre>
<p>Alternatively, the following syntax is also possible:</p>
<pre><code class="language-ruby">system :&lt;name&gt; do
   include &lt;list of superclass modules&gt;
   &lt;HDLRuby code&gt;
end
</code></pre>
<p>For example, let us consider the following 8-bit adder/subtracter module:</p>
<pre><code class="language-ruby">system :addsub8 do
   input :s
   signed[8].input :x, :y
   signed[8].output :z

   par do
      hif(s) { z &lt;= x - y }
      helse  { z &lt;= x + y }
   end
end
</code></pre>
<p>And let us assume we want to design a new 8-bit adder/subtracter module that also outputs a zero flag. That can be done with inheritance as follows:</p>
<pre><code class="language-ruby">system :addsub_zf8, addsub8 do
   output :zf

   zf &lt;= (z == 0)
end
</code></pre>
<p>So why is there an alternate syntax with the <code>include</code> keyword? This is for easing the mix of genericity and inheritance. For example, the previous circuit was 8-bit only. What if you want to do the same with generic input and output widths? For the initial counter, this is straightforward:</p>
<pre><code class="language-ruby">system :addsub do |width|
   inner :s
   [width].input :x, :y
   [width].output :z

   par do
      hif(s) { z &lt;= x - y }
      helse  { z &lt;= x + y }
   end
end
</code></pre>
<p>But for the second one? It needs to transmit its generic parameter to its superclass module, but the parameter is only available within its block description. In such a case, the second syntax is useful:</p>
<pre><code class="language-ruby">system :addsub_zf do |width|
   include addsub(width)
   output :zf

   zf &lt;= (z == 0)
end
</code></pre>
<h4>6.2.2. Modifying a module or an instance</h4>
<p>Let us assume that you think that after all, the adder-subtracter circuit you described previously should definitively have a <code>zf</code> flag for your new project. You can of course create a new module with inheritance for that, but you can also modify afterward the initial <code>addsub</code> module using the <code>open</code> method as follows:</p>
<pre><code class="language-ruby">addsub.open do
   output :zf

   zf &lt;= (z == 0)
end
</code></pre>
<p>After that, all the instances that are created from <code>addsub</code> will include the <code>zf</code> flag computation and output.</p>
<p>In contrast, you may want only one instance to have the flag. In such a case, it may not be necessary to define a new module for that but just modify this instance only. This is possible using again the <code>open</code> method but on the instance. For example with the instance used in the following simulation environment:</p>
<pre><code class="language-ruby">system :addsub_sim do
   signed[8].inner :x, :y, :z
   inner :zf, :s

   addsub(signed[8]).(:addsubI8).(s,x,y,z)

   addsubI8.open do
      output :zf
   
      zf &lt;= (z == 0)
   end

   zf &lt;= addsubI8.zf

   timed do
      x &lt;= 0
      y &lt;= 0
      s &lt;= 0
      repeat(3) { !10.ns; x &lt;= x + 1 }
      repeat(3) { !10.ns; y &lt;= y + 1 }
      s &lt;= 1
      repeat(3) { !10.ns; x &lt;= x - 1 }
      repeat(3) { !10.ns; y &lt;= y - 1 }
      !10.ns
   end
end
</code></pre>
<p>And the simulation result should be:</p>
<p align="center">
<img data-name="hruby_simulator.vcd" src="addsub_vcd.png"  width="80%">
</p>
<h4>6.2.3. Overriding</h4>
<p>Let us consider the following circuit that performs an addition a computes four flags:</p>
<pre><code class="language-ruby">system :adder_flags do |width|
   signed[width].input :x, :y
   signed[width].output :z
   output :cf, :zf, :sf, :of

   [cf,z] &lt;= x.as(signed[width+1]) + y

   zf &lt;= (z == 0)
   sf &lt;= z[-1]
   of &lt;= (x[-1] &amp; y[-1] &amp; ~z[-1]) | (~x[-1] &amp; ~y[-1] &amp; z[-1])
end
</code></pre>
<p>Let us also assume that we want to make a circuit that does the same but saturates the addition result between -300 and +300. For that purpose, the computation of <code>z</code> must be replaced. This is called <code>overriding</code> and for the sake of code readability overriding is only permitted for <em>named sub-sections</em> of a module. A named subsection is declared as follows:</p>
<pre><code class="language-ruby">sub(:&lt;name&gt;) &lt;block&gt;
</code></pre>
<p>Where <code>block</code> can contain any HDLRuby code apart from the port definition. A named subsection can be overridden anywhere in the code, and also in subclass modules by redefining it. In our previous example, if <code>adder_flags</code> is rewritten as follows:</p>
<pre><code class="language-ruby">system :adder_flags do |width|
   signed[width].input :x, :y
   signed[width].output :z
   output :cf, :zf, :sf, :of

   sub(:add) do
      [cf,z] &lt;= x.as(signed[width+1]) + y
   end

   zf &lt;= (z == 0)
   sf &lt;= z[-1]
   of &lt;= (x[-1] &amp; y[-1] &amp; ~z[-1]) | (~x[-1] &amp; ~y[-1] &amp; z[-1])
end
</code></pre>
<p>Then a new module with saturated addition can be defined as follows using inheritance and overriding:</p>
<pre><code class="language-ruby">system :adder_sat_flags do |width|
   include adder_flags(width)

   sub(:add) do
      seq do
         [cf,z] &lt;= x.as(signed[width+1]) + y
         hif(z&lt;-300) { z &lt;= -300 }
         hif(z&gt;300)  { z &lt;= 300 }
      end
   end
end
</code></pre>
<p>If you wish to see how this adder with saturation works, here is a simple simulation environment for it:</p>
<pre><code class="language-ruby">system :adder_sat_flags_sim do
   signed[16].inner :x, :y, :z
   inner :cf, :zf, :sf, :of

   adder_sat_flags(16).(:adderI).(x,y,z,cf,zf,sf,of)

   timed do
      x &lt;= 0
      y &lt;= 0
      repeat(3) { !10.ns; x &lt;= x + 1 }
      repeat(3) { !10.ns; y &lt;= y + 1 }
      !10.ns
      x &lt;= 299
      y &lt;= 0
      repeat(3) { !10.ns; x &lt;= x + 1 }
      !10.ns
      x &lt;= -1
      y &lt;= -300
      repeat(3) { !10.ns; x &lt;= x + 1 }
      !10.ns
   end
end
</code></pre>
<p>And the simulation result should be:</p>
<p align="center">
<img data-name="hruby_simulator.vcd" src="adder_sat_flags_vcd.png"  width="80%">
</p>
<p><strong>Note</strong>: with this circuit, the <code>of</code> flag (overflow) is always 0 because there cannot be any overflow for a 10-bit number with saturation at -300, 300.</p>
<h3>6.3. Metaprogramming and reflection in HDLRuby</h3>
<p>There is not much to say about metaprogramming and reflection because both have been used extensively in this tutorial.</p>
<ul>
<li><p>Metaprogramming consists of using programs that generate the final code. In HDLRuby, this is done by using Ruby code for generating, passing as an argument, and appending chunks of HDLRuby code. This has been done when presenting how to describe parallel code in sequencers, but this can be used everywhere, e.g., within the general processes. Moreover, the possibility to use a chunk of code as a generic argument presented in this section is also metaprogramming.</p>
</li>
<li><p>Reflection has been used in several cases, e.g., the <code>width</code> method for knowing the bit width of a type or the <code>open</code> method. More generally, HDLRuby provides a large number of methods for inspecting and modifying directly the objects of the internal representation. Please consult the documentation of the HDLRuby classes for details about them (good luck, this is low-level coding documentation).</p>
</li>
</ul>
<blockquote>
<p><strong>Note</strong>: the sequencers, the shared signals, the arbiter, and the monitor are not native HDLRuby constructs, they have all been implemented with metaprogramming and reflection.</p>
</blockquote>
<h2>7. How to mix hardware and software.</h2>
<p>Digital electronic devices often contain one of several processors for executing software. That makes then more versatile and easier to update or fix. However, designing a mix of software and hardware (hardware-software co-design) can be challenging, especially because both worlds use different languages and models of computation.</p>
<p>For HDLRuby, the mix of hardware and software is done using a construct, called a program, that provides a basic communication interface made of registers and interrupts. This interface can then be extended both on the hardware and the software side to support more complex interactions.</p>
<h3>7.1. The Program construct</h3>
<p>A program construct, like the processes or the sequencers, is declared within a module, but unlike them, its content is not some code description (neither hardware nor software), but instead a description of its hardware-software interface.</p>
<p>More specifically, a program is declared as follows:</p>
<pre><code class="language-ruby">program(&lt;programming language&gt;, &lt;function name&gt;) do
   &lt;location of the software files and description of its interface&gt;
end
</code></pre>
<p>In the code above, <code>programming language</code> is a symbol representing the programming language used for the software. For now, only two languages are supported:</p>
<ul>
<li><p><code>:ruby</code>: for programs in Ruby.</p>
</li>
<li><p><code>:c</code>: for programs in C. However, for this case, any language that can be compiled to a shared library linkable with C is supported.</p>
</li>
</ul>
<p>The <code>function name</code> parameter indicates which function is to be executed when an activation event occurs. There can be only one such function per program, but any number of programs can be declared inside the same module.</p>
<p>The <code>location of the software files and description of its interface</code> part can include the following declaration statements:</p>
<ul>
<li><p><code>actport &lt;list of events&gt;</code>: for declaring the list of events that activates the program, i.e., that will trigger the execution of the program's start function.</p>
</li>
<li><p><code>inport &lt;list of port names associated with a signal&gt;</code>: for declaring the list of ports that the software code of the program can read.</p>
</li>
<li><p><code>outport &lt;list of port names associated with a signal&gt;</code>: for declaring the list of ports that the software code of the program can write to.</p>
</li>
<li><p><code>code &lt;list of filenames&gt;</code>: for declaring the source code files.</p>
</li>
</ul>
<p>For example the following declares a program in the Ruby language whose start function is <code>echo</code> that is activated on the positive edge of signal <code>req</code>, has a read port called <code>inP</code> that is connected to signal <code>count</code> and a write port called <code>outP</code> that is connected to signal <code>val</code>, finally the code of this program is given in a file named <code>echo.rb</code> (the extension <code>.rb</code> can also be omitted):</p>
<pre><code class="language-ruby">system :my_system do
   inner :req
   [8].inner :count, :val

   program(:ruby,'echo') do
      actport req.posedge
      inport  inP:  count
      outport outP: val
      code &quot;echo.rb&quot;
   end

   ...

end
</code></pre>
<p>A similar program construct can also use C as follows:</p>
<pre><code class="language-ruby">system :my_system do
   inner :req
   [8].inner :count, :val

   program(:c,'echo') do
      actport req.posedge
      inport  inP:  count
      outport outP: val
      code &quot;echo&quot;
   end

   ...

end
</code></pre>
<p>There is a difference from Ruby though in that the C code cannot be used directly and must be compiled to a library, and it is the name of the library that has to be indicated in the <code>code</code> section. Since the format of the compiler program depends highly on the target software environment, it is recommended to omit the extension (e.g., here only <code>echo</code> and not <code>echo.so</code> or any other extension), so that the framework looks for the suitable format automatically.</p>
<p>Now, let us see how the software code can be written to interact with hardware.</p>
<h3>7.2. Writing software for a HDLRuby Program construct.</h3>
<p>As long as the language is supported by HDLRuby (i.e., Ruby or a C-compatible compiled language), there should not be any restrictions for the software code. The function that has been declared in the HDLRuby program construct for being activated will act as a handler for an interrupt raised by one of the corresponding events.</p>
<p>Then, for accessing the ports on the hardware-software interface, a library that depends on the used software language must be loaded.</p>
<h4>7.2.1. In the case of Ruby</h4>
<p>If the software language is Ruby, then the library is loaded by requiring the file <code>rubyHDL.rb</code>. If HDLRuby is correctly installed, adding the following line at the beginning of the code is enough:</p>
<pre><code class="language-ruby">require 'rubyHDL.rb'
</code></pre>
<p>This library gives access to a Ruby module named &quot;RubyHDL&quot; which gives access to the ports of the hardware-software interface described in the HDLRuby program construct. Those ports are directly accessible by name as follows: <code>RubyHDL.&lt;name&gt;</code>.</p>
<p>For example, the following is an example of implementation of the <code>echo.rb</code> software used in the previous HDLRuby program example:</p>
<pre><code class="language-ruby">require 'rubyHDL'

def echo
   val = RubyHDL.inP
   RubyHDL.outP = val
end
</code></pre>
<p>This program is limited to the handler <code>echo</code>, that reads on port <code>inP</code> and write the result to port <code>outP</code>. If you remember the corresponding HDLRuby program construct, that means <code>echo</code> will get the value of signal <code>count</code> and send it to signal <code>val</code>.</p>
<h4>7.2.2. For the case of C</h4>
<p>If the software language is C (or a compatible compiled language), then the library is accessed by including the file <code>cHDL.h</code>. However, this file is probably not within the includes path of the C compiler, so you need to bring it to your working directory, as well as other possible necessary files, using the <code>hdrcc</code> command as follows:</p>
<pre><code class="language-bash">hdrcc --ch &lt;path to your working directory&gt;
</code></pre>
<p>Here, your working directory is assumed to contain the source code for your C program.</p>
<p>Then, you can include the file as follows in your C source code:</p>
<pre><code class="language-ruby">#include &quot;cHDL.h&quot;
</code></pre>
<p>This library gives access to three C functions for interacting with the ports:</p>
<ul>
<li><p><code>void* c_get_port(const char* name)</code>: returns a pointer to the port whose name is passed as argument.</p>
</li>
<li><p><code>int c_read_port(void* port)</code>: reads the port whose pointer is passed as argument and returns its value.</p>
</li>
<li><p><code>int c_write_port(void* port, int val)</code>: write the value <code>val</code> to the port passed as argument.</p>
</li>
</ul>
<p>Please notice that whatever the bit width of the signal connected to the part may be, from the software side the type of the data going through a port is always <code>int</code>. If the signal is larger than an <code>int</code>, the extra bits will be truncated, and if it is smaller, the value of the extra bits from the software side is undefined.</p>
<p>For example, the following is an example of implementation of the <code>echo.rb</code> software used in the previous HDLRuby program example:</p>
<pre><code class="language-c">#include &quot;cHDL.h&quot;

void echo() {
   static void* inP = c_get_port(&quot;inP&quot;);
   static void* outP = c_get_port(&quot;outP&quot;);
   int val = c_read_port(inP);
   c_write_port(outP);
end
</code></pre>
<p>This program is the same as the Ruby version, but the ports are only available after being looked up by name using the <code>c_get_port</code> function. It is enough to do that once though, so that in the example, we set the corresponding port variable <code>inP</code> and <code>outP</code> as static local.</p>
<h3>7.3. Hardware-software co-simulation</h3>
<p>Hardware-software co-simulation is done, like pure hardware simulation, using the HDLRuby simulator using the <code>hdrcc --sim</code> command (please see <a href="#1-3-using-hdlruby">section 1.3.</a>.</p>
<p>When the software language is Ruby, there is nothing more to do. However, when the software language is C, its code must first be compiled to a shared library for the host (i.e., the computer that executes the HDLRuby simulator). For example, assuming you want to compile the C file <code>echo.c</code> located into the <code>echo</code> directory, if you are using GCC on a Linux system, you could type (after entering the <code>echo</code> directory):</p>
<pre><code class="language-bash">cd echo
gcc -shared -fPIC -undefined dynamic_lookup  -o c_program.so echo.c
</code></pre>
<p>Otherwise, it may be easier to use the Ruby environment by first installing <code>rake-compiler</code> as follows:</p>
<pre><code class="language-bash">gem install rake-compiler
</code></pre>
<p>And simply type the following command (after entering the <code>echo</code> directory):</p>
<pre><code class="language-bash">rake compile
</code></pre>
<p>The rake tool will take care of everything for performing the compiling whatever your system may be.</p>
<p>When the C code is compiled, the HDLRuby simulator can be executed as usual.</p>
<p><strong>Note</strong>:</p>
<p><strong>Important:</strong> for windows, dynamically loaded functions must be declared with the following prefix: <code>__declspec(dllexport)</code>. If this prefix is not present before each function that is used as an HDLRuby program, the simulation will not work. For example, for Windows, the function echo <em>must</em> be written as follows:</p>
<pre><code class="language-c">#include &quot;cHDL.h&quot;

__declspec(dllexport) void echo() {
   void* inP = c_get_port(&quot;inP&quot;);
   void* outP = c_get_port(&quot;outP&quot;);
   int val;
   
   val = c_read_port(inP);
   c_write_port(outP,val);
}
</code></pre>
<h3>7.4. Is that all?</h3>
<p>Technically, there is nothing else to describe hardware-software interaction in HDLRuby. Hence, no shared memory, buffer, or other complex communication or synchronization systems. But the reason is that we do not need them in the core of HDLRuby, they can be described using a mix of standard HDLRuby and software programming. With the same method, you can also simulate external devices as black boxes.</p>
<p>To illustrate how this mix of HDLRuby and software can be implemented, let us see three examples: a memory shared between software and hardware, a model of an operating system, a real-time clock, and a method for modeling program execution time. In all these examples we will use Ruby as software language, but this can also be done with C.</p>
<h4>7.4.1. Modeling a memory shared between software and hardware</h4>
<p>There are two possibilities for modeling such a memory: either describe it in plain HDLRuby as a full hardware component, and write a program construct that simulates the access of the software part to this memory, or describe the memory as a part of the software part and simulate its access from the hardware part using a program construct. The first approach is more accurate and may be useful when a specific kind of memory is to be used, but it is slower than the second one.</p>
<h5>7.4.1.1 Memory described as a hardware component</h5>
<p>For the first approach, if we assume a memory with an 8-bit address bus, and an 8-bit data bus the HDLRuby code could be as follows:</p>
<pre><code class="language-ruby">system :hw_sw_with_hw_memory do
   [8].inner :addr
   [8].inner :din, :dout
   inner     :rwb, :ce

   inner :clk, :rst

   # Instantiation of the memory.
   instance :memory do
      inner      :clk
      [8].input :addr
      [8].input  :din
      [8].output :dout
      input      :rwb, :ce

      bit[8][-256].inner :content

      par(clk.posedge) do
         hif(ce) do
            hif(rwb) { dout &lt;= content[addr] }
            helse    { content[addr] &lt;= din }
      end
   end.(clk,addr,din,dout,rwb,ce)

   # The hw generating the tick activating the software part (e.g., an OS tick):
   # one tick every 10 clock cycles.
   inner :tick
   (tick &lt;= ~rst &amp; ~tick).at(clk.posedge * 5)

   inner :req_sw, :ack_sw, :rwb_sw
   [8].inner :addr_sw
   [8].inner  :din_sw, :dout_sw

   inner[16] :addr_hw
   inner :req_hw, :ack_hw, :rwb_hw
   [8].inner  :din_hw, :dout_hw

   # Description of the software part.
   program(:ruby,:some_sw) do
      actport tick.posedge
      outport req :req_sw, ack: ack_sw, rwb: rwb_sw
      outport addr: addr_sw
      outport dout: dout_sw
      inport  din:  din_sw
      code &quot;some_sw.rb&quot;
   end

   inner :priority  # 0: priority in hw access, 1: priority in sw access.

   # The arbiter, sharing the memory between software and hardware giving
   # priority to software. It uses a round-robin approach.
   par(clk.negedge) do
      hif(rst) { priority &lt;= 0 }
      ack_sw &lt;= 0    # By default no access granted to software.
      ack_hw &lt;= 0    # Nor to hardware.
      ce     &lt;= 0
      hif(req_sw &amp; (priority | ~req_hw)) do
         ce     &lt;= 1
         ack_sw &lt;= 1
         rwb    &lt;= rwb_sw
         addr   &lt;= addr_sw
         din    &lt;= dout_sw
         din_sw &lt;= dout
         priority &lt;= ~priority
      end
      if(req_hw &amp; (~priority | ~req_sw)) do
         ce     &lt;= 1
         ack_hw &lt;= 1
         rwb    &lt;= rwb_hw
         addr   &lt;= addr_hw
         din    &lt;= dout_hw
         din_hw &lt;= dout
         priority &lt;= ~priority
      end
   end

   # Some hardware code accessing the memory.
   sequencer(clk,rst) do
      # At first, fill the memory with 0.
      req_hw &lt;= 1; rwb_hw &lt;= 0
      swhile(~ack_hw) # Wait for the access grant to memory.
      dout_hw &lt;= 0
      256.stimes { |i| addr_hw &lt;= i }
      req_hw &lt;= 0 # End the transactions.
      # Now, do infinitely some arbitrary computations with the content
      # of the memory.
      sloop do
         128.stimes do |i|
            [8].inner :tmp
            req_hw &lt;= 1
            rwb_hw &lt;= 1
            addr_hw &lt;= i
            swhile(~ack_hw)
            tmp &lt;= din_hw
            step
            rwb_hw  &lt;= 0
            addr_hw &lt;= i + 128
            dout_hw &lt;= tmp * tmp   # Just some senseless data.
            step
            req_hw &lt;= 0
         end
      end
   end
</code></pre>
<p>This example contains four parts:</p>
<ul>
<li>A hardware description of a memory, described as an inline instance. It has an address input <code>addr</code>, a data input <code>din</code> a data outpout <code>dout</code> (it is common in FPGA nowadays to avoid three-state buses), a signal <code>rwb</code> indicating if a read (1) or a write (0) access is performed, and a chip enable signal <code>ce</code>.</li>
</ul>
<p><em>NOTE:</em> an inline <code>instance</code> is a construct that both describe a module (like <code>system</code>) and instantiates it in place. When a component is to be used only once, it is a convenient way to have fast access to the description of the module where it is used, while keeping the hierarchy.</p>
<ul>
<li><p>A hardware description of an arbiter for granting access to this memory to alternatively a software component and a hardware component using round-robin. Both the software part and the hardware part have their signals for accessing the memory (e.g., resp. <code>rwb_sw</code> and <code>rwb_hw</code> for <code>rwb</code>), and the arbiter will transmit them to the corresponding memory signal when their access is granted. For requiring access, both have to raise a memory request signal, resp. <code>req_sw</code> and <code>req_hw</code>, and will know they have access when the corresponding acknowledge signals are raised, resp., <code>ack_sw</code> and <code>ack_hw</code>.</p>
</li>
<li><p>A software component described with a sequencer reading and writing the memory and performing arbitrary computations. This code is activated on each rising edge of signal <code>tick</code>.</p>
</li>
<li><p>A hardware component described with a sequencer reading and writing the memory and performing arbitrary computations.</p>
</li>
</ul>
<p>Then, the code of the software component in the file <code>some_sw.rb</code> can be as follows:</p>
<pre><code class="language-ruby">require 'rubyHDL.rb'

$addr = 0
$state = 0
$tmp = 0

def some_sw
   if(RubyHDL.ack == 0) then
      RubyHDL.req = 1
   else
      case($state)
      when 0:
         RubyHDL.addr = 128+$addr
         RubyHDL.rwb  = 1
         $state = 1
      when 1:
         $tmp = RubyHDL.din
         puts &quot;Read: #{$tmp}&quot;
         $state = 2
      when 2:
         RubyHDL.rwb = 0
         RubyHDL.addr = $addr
         puts &quot;Write: #{$tmp + 1}&quot;
         RubyHDL.dout = $tmp + 1    # Write some random computation result from
         $state = 0                 # the previously read data. 
         $addr  = ($addr + 1) &amp; 255 # Next address.
      end
   end
end
</code></pre>
<p>This program simply writes in the first half of the memory the result of some arbitrary computation from the data read from the first half. That is to say that it does the opposite of the hardware component described in the HDLRuby code. This code makes sense only if the process has access to the memory via explicit access to address and data registers, which is the case for some embedded architectures. If the memory is directly accessible by the processor, the access procedure must be encapsulated by Ruby methods (or C functions) that are meant to be replaced by standard memory accesses in the final code. Moreover, since a software code is fully executed by the HDLRuby simulator before giving back the hand to the simulation, this code has been written like a state machine whose state is a global variable updated at each code, so that it simulates an interaction with the hardware. This is valid if the software code is meant to be a handler of interrupt for example, but not for more conventional software. For the second case, a model of an operating system will have to be described that handles the synchronizations. Such a model as well as the encapsulation of the hardware accesses will presented in section <a href="#7-5-2-modeling-an-operating-system">7.5.2</a>.</p>
<h5>7.4.1.1 Memory described as a software component</h5>
<p>Usually, CPUs have privileged access to the main memory and give direct access to it to software through a pointer, or an array. Moreover, memories are usually IP components that are instantiated as black boxes in HDL. For such cases, it is preferable to describe a memory as a program construct whose code is a simulation of its behavior described in software. This description is to be used when simulating, but it can be ignored when synthesizing the final hardware. With this approach, the previous HDLRuby code can be rewritten as follows:</p>
<pre><code class="language-ruby">system :hw_sw_with_sw_memory do
   [8].inner :addr
   [8].inner :din, :dout
   inner     :rwb
   inner     :req, :ack

   inner :clk, :rst

   # Description of the memory as a black box simulated in software.
   program(:ruby,:memory) do
      actport clk.posedge
      inport  addr: addr
      inport  din:  din
      outport dout: dout
      inport  rwb:  rwb
      inport  req:  req
      outport ack:  ack
      code &quot;some_sw.rb&quot;
   end

   # The hw generating the tick activating the software part (e.g., an OS tick):
   # one tick every 10 clock cycles.
   inner :tick
   (tick &lt;= ~rst &amp; ~tick).at(clk.posedge * 5)

   # Description of the software part.
   program(:ruby,:some_sw) do
      actport tick
      code &quot;some_sw.rb&quot;
   end

   # Some hardware code accessing the memory.
   sequencer(clk,rst) do
      # At first, fill the memory with 0.
      req &lt;= 1
      rwb &lt;= 0
      swhile(~ack) # Wait for the access grant to memory.
      dout &lt;= 0
      256.stimes { |i| addr_hw &lt;= i }
      req &lt;= 0 # End the transactions.
      # Now, do infinitively some arbitrary computations with the content
      # of the memory.
      sloop do
         128.stimes do |i|
            [8].inner :tmp
            req &lt;= 1
            rwb &lt;= 1
            addr &lt;= i
            swhile(~ack)
            tmp &lt;= din
            step
            rwb  &lt;= 0
            addr &lt;= i + 128
            dout &lt;= tmp *tmp   # Just some senseless data.
            step
            req &lt;= 0
         end
      end
   end
</code></pre>
<p>This time the arbiter has been integrated into the black box modeling the memory so that the hardware part only has to use the direct memory signals <code>addr</code>, <code>din</code>, <code>dout</code>, <code>rwb</code>, <code>req</code> and <code>ack</code>.
The code of the software part contains two functions, one for modeling the memory <code>memory</code>, and the previous software function <code>some_sw</code>. For the sake of concision, both are included in the same file given below, but for a real design, it would be better to put them in different files so that the real software is separated from the black box simulation code.</p>
<pre><code class="language-ruby">require 'rubyHDL.rb'

MEM = [0] * 256

$priority = 0

def memory
    # Is there an access request from the HW?
    if(RubyHDL.req == 1) then
       # Is it being processed?
       if (RubyHDL.ack == 1) then
          # Yes, go on processing.
          if (RubyHDL.rwb == 1) then
             # Read access.
             RubyHDL.dout = MEM[RubyHDL.addr]
          else
             # Write access.
             MEM[RubyHDL.addr] = RubyHDL.din
          end
       elsif ($priority == 0)
          # Grant the access.
          RubyHDL.ack = 1
          $priority = 1
       end
    end
    else
       # No, ensure the access grant is removed.
       RubyHDL.ack = 0
    end
end

$addr = 0
$state = 0
$tmp = 0

def some_sw
   if(RubyHDL.ack == 0) then
      # The access from HW to memory not granted, can go an.
      case($state)
      when 0:
         if ($priority == 1) then
            $state = 1
         end
      when 1:
         $tmp = MEM[$addr+128]
         puts &quot;Read: #{$tmp}&quot;
         $state = 2
      when 2:
         puts &quot;Write: #{$tmp + 1}&quot;
         MEM[$addr] = $tmp + 1      # Write some random computation result from
         $state = 0                 # the previously read data. 
         $addr  = ($addr + 1) &amp; 255 # Next address.
         $priority = 0
      end
   end
end
</code></pre>
<p>In this example, the memory is modeled by a simple array. The function <code>memory</code> handles the accesses from the hardware and the arbitration between software and hardware access using a round-robin algorithm. The software program given by function <code>some_sw</code> is identical to the previous one, apart from the memory access which is a direct array access, and the check of the memory grant, since this time no software-specific signal is used for the arbitration.</p>
<h5>7.4.2 Modeling an operating system</h5>
<p>Usually, software is executed on top of an operating system, or a minimal runtime, e.g., even the plainest C runs on top of <code>crt0</code>. This low-level software is usually fixed and highly target-dependent. Hence, it is usually enough to simulate this behavior. Since the HDLRuby simulator supports any compiled C (or other compatible compiled language), or Ruby, all the techniques that can be used in these languages for abstract low-level software can be used. Here, we will use Ruby threads as an illustration for modeling a simple multitask system with an interrupt handler. In the example, there will be two tasks, one reading data from a dummy hardware device described in HDLRuby, transmitting it using a pipe to another one which writes its data to the standard output every second.</p>
<pre><code class="language-ruby">system :hw_sw_with_os do
   inner :clk,:rst

   # The OS tick
   inner :tick
   (tick &lt;= ~rst &amp; ~tick).at(clk.posedge * 5)

   # The general interrupt signal: interrupt request, acknowledge, and number
   inner :irq, :iak

   # A register that 

   # The os model.
   program(:ruby, :os) do
      actport tick: tick
      inport register: register     # Some register direcly acessible by software
      code &quot;sw_with_os.rb&quot;
   end

   # The interrupt handler.
   program(:ruby,:handler) do
      actport irq: irq
      outport iak: iak
      code &quot;sw_with_os.rb&quot;
   end


   # Some dummy hardware generating data (counting clocks) and raising an
   # interrupt when the data is ready on a software-accessible register.
   par(clk.posedge) do
      hif(rst) { register &lt;= 0 }
      helse do
         # Increase the value of the register.
         register &lt;= register + 1
         # Handle the interrupts.
         hif(irq == 0) do
            # Is the prevous irq have been processed?
            hif (iak == 0) do
               # Yes, raise an interrupt.
               irq &lt;= 1
            end
         else
            # Wait for the irq to be acknowledge.
            if (iak == 1) { irq &lt;= 0 }
         end
      end
   end
end
</code></pre>
<p>The software code <code>sw_with_os.rb</code> is as follows:</p>
<pre><code class="language-ruby">require 'rubyHDL.rb'

$register = 0

$start = true

# The os simulation function. Initialize the tasks and the communication pipe
# for the first call, then update the value of the $register variable.
def os
   if($start) then
      # Create the communication pipe.
      $pout, $pin = IO.pipe
      $tasks = []
      # Create the first task reading the values.
      $tasks &lt;&lt; Thread.new(&amp;Kernel.method(:read_task))
      # Create the second task displaying the values.
      $tasks &lt;&lt; Thread.new(&amp;Kernel.method(:show_task))
      $start = false
   else
      # Update $register.
      $register = RubyHDL.register
   end
end

# The interrupt handler: acknowledge the interrupt, wakes up the read task.
def handler
   RubyHDL.iak = 1
   $tasks[0].run
end

# Waits an interrupt: sleep and when waked up tell another interrupt can come.
def wait_irq
   sleep
   RubyHDL.iak = 0
end

# The reading task: wait an interrupt then get a value and add it to the pipe.
def read_task
   loop do
      wait_irq
      $pin &lt;&lt; $register.to_s
   end
end

# The displaying task: write in stdout the data obtained from the pipe each
# second.
def show_task
   loop do
      sleep(1)
      puts $pout.readline
   end
end
</code></pre>
<h3>7.5. Hardware-software co-synthesis</h3>
<p>The HDLRuby compiler can be applied to HDLRuby description containing program. However, when producing Verilog HDL or VHDL files, the compiler will ignore the prorgam session. The reason is because the integration of hardware and software is highly target dependent and often licensed. However, you can use the HDLRuby integration of programs using ports for decribing the integration specific to a given target.</p>
<p>As an illustration, let us assume that we want to design an application for a very basic SoC system including a CPU and a FPGA where a set of 8-bit FPGA registers are memory-mapped to the CPU through a set of predefined addresses: input with <code>fi0</code> to <code>fi3</code> for respective addresses <code>0xC000</code> to <code>0xC009</code>, and output with <code>fo0</code> to <code>fo3</code> for respective addresses <code>0xC010</code> to <code>0xC020</code>.
For this case, the HDLRuby module representing the target system and the corresponding program construct can be written as follows:</p>
<pre><code class="language-ruby">system :soc_basic do
  input :clk
  [8].input  :fi0, :fi1, :fi2, :fi3
  [8].output :fo0, :fo1, :fo2, :fo3
  ...

  program(:c, :my_func) do
    actport clk.posedge
    outport fi0: fi0, fi1: fi1, fi2: fi2, fi3: fi3
    inport  fo0: fo0, fo1: fo1, fo2: fo2, fo3: fo3
    code &quot;my_soft.c&quot;
  end

  &lt; Some HDLRuby code describing the hardware part of the application &gt;
end
</code></pre>
<p>And the C program <code>my_soft.c</code> can be written as follows using functions like <code>read_fo0()</code> for reading register <code>fo0</code> and <code>write_fi1(val)</code> for writing to register <code>fi1</code>, and calling only once <code>init_soclib</code> for initializing the API library:</p>
<pre><code class="language-c">#include &quot;soclib.h&quot;

void my_func() {
    static int start = 1;
    if(start) { init_scolib(); start = 0; }
  
    char fo0 = read_fo0();
    ...
    write_fi1(val);
    ...
}
</code></pre>
<p>Alternatively, the initialisation can be delegated to another program construct in the HDLRuby code, activated on a reset signal. Then, the respective hardware and software code becomes as follows:</p>
<pre><code class="language-ruby">system :soc_basic do
  input :clk, :rst
  [8].input  :fi0, :fi1, :fi2, :fi3
  [8].output :fo0, :fo1, :fo2, :fo3
  ...

  program(:c, :init_soclib) do
    actport rst.posedge
  end

  program(:c, :my_func) do
    actport clk.posedge
    outport fi0: fi0, fi1: fi1, fi2: fi2, fi3: fi3
    inport  fo0: fo0, fo1: fo1, fo2: fo2, fo3: fo3
    code &quot;my_soft.c&quot;
  end

  &lt; Some HDLRuby code describing the hardware part of the application &gt;
end
</code></pre>
<pre><code class="language-c">#include &quot;soclib.h&quot;

void my_func() {
    char fo0 = read_fo0();
    ...
    write_fi1(val);
    ...
}
</code></pre>
<p>Whatever the approach being used for the initialization, the read and write functions are defined in the <code>soclib.h</code> file. Two versions of this file are to be provided, one for running with the HDLRuby simulator, and one for running for the target SoC. These two files, with possible additional target constraints files (e.g., xcd file for Xilinx platforms) are the sole additional file that are to be provided by the user to have an application which can be both simulated on the HDLRuby simulator, and synthesized for the target SoC. For the example above, the HDLRuby version of <code>soclib.h</code> is as follows:</p>
<pre><code class="language-c">#include &quot;cHDL.h&quot;

static void *fo0, *fo1, *fo2, *fo3;
static void *fi1, *fi1, *fi2, *fi3;

soclib_init() {
     fo0 = c_get_port(&quot;fo0&quot;);
     ...
}


#define read_fo0() c_read_port(fo0)
...
#define write_fi1(val) c_write_port(fi1,(val))
...
</code></pre>
<p>And the SoC specific version could look as follows, where <code>target_soc_API.h</code> represents whatever include files required for using the target SoC API:</p>
<pre><code class="language-c">#include &quot;target_soc_API.h&quot;

soclib_init() {
   &lt;Some initialization code if required by the target SoC API&gt;
}

#defined read_fo0() (*0xC010)
...
#define write_fi1(val) (*0xC001 = (val))
...
</code></pre>
<h2>8. How to interact with the simulator.</h2>
<h3>8.1. Do-It-Yourself interaction.</h3>
<p>Using the program construct presented in the prevous section, it easy add basic interactions to the simulation of your module. For example, you can read and write values from the standard input and map them to HDLRuby signals using the following Ruby program (<code>stdrw.rb</code>):</p>
<pre><code class="language-ruby">require 'RubyHDL'

def stdrw
  RubyHDL.sigI = $stdin.read.to_i
  $stdout.puts(RubyHDL.sigO)
end
</code></pre>
<p>Then, a corresponding HDLRuby module that accumulates the read inputs could be writen as follows:</p>
<pre><code class="language-ruby">system :accum do
  inner :clk
  [32].inner :sigI, :sigO

  program(:ruby,:stdrw) do
    actport clk.posedge
    outport sigI: sigI
    inport  sigO: sigO
    code &quot;stdrw.rb&quot;
  end

  (sigO &lt;= sigO+sigI).at(clk.posedge)

  timed do
    clk &lt;= 0
    sigO &lt;= 0
    sigI &lt;= 0
    repeat(1000) do
       !10.ns
       clk &lt;= ~clk
    end
  end
end
</code></pre>
<p><strong>Note</strong>: The input method used in the Ruby program requires to input a number with the keyboard, press <code>&lt;ENTER&gt;</code> then <code>&lt;CTRL&gt;-D</code> for validating it.</p>
<p>Since a Ruby (or C) code can be used for the program construct, more complex interactive interface can be made, for example, you can consult the sample code <code>with_program_ruby_cpu.rb</code> which utilizes the <code>curses</code> interface for simulating a UART keyboard and CRT monitor.</p>
<h3>8.2. Using the web browser-based GUI</h3>
<p>HDLRuby also provides a construct derivated for the programs for easily building a web browser-based GUI. This GUI is described using a <code>board</code> construct as follows:</p>
<pre><code class="language-ruby">board(:&lt;board name&gt;,&lt;server port&gt;) do
  actport &lt;event&gt;
  &lt;description of the GUI&gt;
end
</code></pre>
<p>This construct can be declared within any module, and contains the following elements as given in the code above:</p>
<ul>
<li><p><code>board name</code>: the name of the board.</p>
</li>
<li><p><code>server port</code>: the web port the GUI can be accessed through, by default, it is <code>8000</code>.</p>
</li>
<li><p><code>event</code>: the event (edge of a signal) indicating when the GUI is synchronized with the simulator. <strong>Note</strong>: the more frequent the event is, the slower the simulation will be.</p>
</li>
<li><p><code>description of the GUI</code>: a set of statements describing the content of the GUI.</p>
</li>
</ul>
<p>There are two types of statements for describing the GUI: the active ones, that are connected to a HDLRuby signal, and the passive ones that configure the shape of the GUI. The statements of the first type are declared as follows:</p>
<pre><code class="language-ruby">&lt;element&gt; &lt;element name&gt;: &lt;HDLRuby signal&gt;
</code></pre>
<p>And the comprise the following:</p>
<ul>
<li><p><code>sw</code>: represents a set of slide switches, their number is set to match the bit-width of the attached signal.</p>
</li>
<li><p><code>bt</code>: represents a set of push buttons, their number is set to match the bit-width of the attached signal.</p>
</li>
<li><p><code>led</code>: represents a set of LEDs, their number is set to match the bit-width of the attached signal.</p>
</li>
<li><p><code>slider</code>: represents an horizontal slider.</p>
</li>
<li><p><code>text</code>: represents a text input box whose content is interpreted as an expression. The syntax of the expression follows Ruby, and the available variables include the board's display objects. For example, if a set of LEDs is named <code>leds</code>, it will be accessible as a variable.</p>
</li>
<li><p><code>hook</code>: attaches a signal to the board without displaying. It can be used as a variable in <code>text</code> expressions, similar to display objects.</p>
</li>
<li><p><code>hexa</code>: represents a hexadecimal number display, its character width is set to match the width of the largest possible value of the attached signal.</p>
</li>
<li><p><code>digit</code>: represents a decimal number display, its character width is set to match the width of the largest possible positive or the smallest possible negative value of the attached signal.</p>
</li>
<li><p><code>scope</code>: represents an oscilloscope display, the vertical axis represents the value of the attached signal, its range is determined by its data type, and the horizontal axis represents the time is number of synchronization of the GUI.</p>
</li>
</ul>
<p>There is for now only one statement of the second type: <code>row</code>. This statement is used without any argument and adds a new row to the GUI for placing components.</p>
<p>For example, we can use a GUI instead of the basic standard input and output for the example given in <a href="#8-1-do-it-yourself-interaction">the previous section</a>. The code could be as follows, for having one slide switch for setting the value to add, and LEDs for displaying the accumulation result (<code>accum.rb</code>):</p>
<pre><code class="language-ruby">system :accum do
  inner :clk
  [32].inner :sigI, :sigO

  board(:boardrw) do
    actport clk.posedge
    sw  sigI: sigI
    row
    led sigO: sigO
  end

  (sigO &lt;= sigO+sigI).at(clk.posedge)

  timed do
    clk &lt;= 0
    sigO &lt;= 0
    sigI &lt;= 0
    repeat(1000) do
       !10.ns
       clk &lt;= ~clk
    end
  end
end
</code></pre>
<p>This code is simulated exactly like any other HDLRuby description, e.g.:</p>
<pre><code class="language-bash">hdrcc --sim --vcd accum.rb accum
</code></pre>
<p>However, the simulator will wait until a browser connects to it. For that, you can open a web browser, and go to the local url: <code>http://localhost:8000</code>. The simulation will then start and you can interact with the GUI which should look as follows:</p>
<p align="center">
<img src="gui_accum.png"  width="80%">
</p>
<p>A more complete example can be found among the HDLRuby samples: <code>with_board.rb</code>, which when simulated will use the following GUI:</p>
<p align="center">
<img src="gui_board.png"  width="80%">
</p>
<h2>9. What about using Verilog HDL instead?</h2>
<p>I won’t claim how good HDLRuby is, but it’s clear that Verilog HDL (/ SystemVerilog) and VHDL are currently the leading languages in hardware design, and it would be unrealistic to expect this to change anytime soon. This means that for HDLRuby to offer any real benefit, the framework must be able to support one or both of these languages in some way. This is no easy task, but as a starting point, we now provide a tool for converting Verilog HDL files into HDLRuby files.
For that please use the following command:</p>
<pre><code class="language-bash">v2hdr &lt;input Verilog HDL file&gt; &lt;output HDLRuby file&gt;
</code></pre>
<p>For example, assuming that you have a Verilog ddHDL named 'adder.v' describing and adder circuit, you can convert it to HDLRuby as follows:</p>
<pre><code class="language-bash">v2hdr adder.v adder.v.rb
</code></pre>
<p>Another possibility is to directly load the Verilog HDL file from a HDLRuby description using the command <code>require_verilog</code>.
For example, assuming <code>adder.v</code> contains the following code:</p>
<pre><code class="language-verilog">module adder(x,y,z);
  input[7:0] x,y;
  output[7:0] z;
  
  assign z = x + y;
endmodule
</code></pre>
<p>It can be loaded the be instantiated like any other module in HDLRuby as follows:</p>
<pre><code class="language-ruby">require_verilog &quot;adder.v&quot;

system :my_IC do
   [8].inner :a, :b, :c

   adder(:my_adder).(a,b,c)

   ...
end
</code></pre>
<p><strong>Notes</strong>:</p>
<ul>
<li><p>Verilog HDL accepts signal and module names in any letter case, while HDLRuby reserves identifiers starting with a capital letter for constants. To avoid conflicts, Verilog HDL names that begin with a capital letter are prefixed with an underscore (<code>_</code>) in HDLRuby. For example, if the Verilog HDL module name in the previous example were <code>ADDER</code>, it would be renamed to <code>_ADDER</code> in HDLRuby. Instantiating such a module would be done as follows:</p>
<pre><code class="language-ruby">_ADDER(:my_add).(a,b,c)
</code></pre>
</li>
<li><p>With the current version of HDLRuby, the Verilog HDL files are first converted to HDLRuby before being loaded using the standalone <code>v2hdr</code> tool.</p>
</li>
</ul>
<h2>10. What next?</h2>
<p>There are still many aspects of HDLRuby that have not been addressed in this tutorial. For example, finite state machines (FSM) and decoders are crucial hardware components that you should learn about, and HDLRuby provides specific constructs for easier design. So from now on, please consult the main documentation of HDLRuby, and have a look at the code samples provided in the HDLRuby distribution. They can be copied to your working directory using the following command:</p>
<pre><code class="language-bash">hdrcc --get-samples
</code></pre>

<h1
id="hdlruby-tutorial-for-software-people-and-hardware-people-too">HDLRuby
Tutorial for software people (<em>and hardware people too</em>)</h1>
<p>In this tutorial, you will learn the basics about the description of
digital circuits using HDLRuby from the software point of view. In
detail you will learn:</p>
<ol type="1">
<li><p><a href="#1-what-is-hdlruby-and-how-to-use-its-framework">What is
HDLRuby and how to use its framework.</a></p></li>
<li><p><a href="#2-how-to-represent-a-circuit-in-hdlruby">How to
represent a circuit.</a></p></li>
<li><p><a
href="#3-how-to-describe-an-algorithm-to-be-implemented-by-a-circuit">How
to describe an algorithm to be implemented by a circuit.</a></p></li>
<li><p><a href="#4-how-to-add-parallelism-to-your-algorithms">How to add
parallelism to your algorithms.</a></p></li>
</ol>
<p>Then, the following section will introduce advanced concepts about
hardware design and HDLruby:</p>
<ol start="5" type="1">
<li><p><a
href="#5-toward-lower-level-hardware-design-the-processes">Toward lower
level hardware design: the processes.</a></p></li>
<li><p><a
href="#6-not-enough-what-about-genericity-object-orientation-metaprogramming-and-reflection">Not
enough? What about genericity, object orientation, metaprogramming, and
reflection?</a></p></li>
<li><p><a href="#7-how-to-mix-hardware-and-softwware">How to mix
hardware and software.</a></p></li>
<li><p><a href="#8-how-to-interact-with-the-simulator">How to interact
with the simulator.</a></p></li>
</ol>
<p>Within these topics, you will also have an explanation of how the
following high-level concepts can be used in HDLRuby:</p>
<ul>
<li><p>Object-oriented programming</p></li>
<li><p>Reflection</p></li>
<li><p>Genericity</p></li>
<li><p>Metaprogramming</p></li>
</ul>
<p>But, before going further, here are a few…</p>
<h2 id="prerequisites">Prerequisites</h2>
<p>Since this tutorial is aimed at software people, it is assumed you
have a good understanding of programming and the relevant tools (e.g.,
editor, compiler). However, it is not assumed that you have any
knowledge about digital hardware design. Otherwise, knowing the Ruby
programming language is recommended but not mandatory.</p>
<p>To use HDLRuby the following software is required:</p>
<ul>
<li><p>A distribution of the Ruby language.</p></li>
<li><p>A text editor. If you like syntax highlighting or other fancy
features, please choose one supporting Ruby.</p></li>
<li><p>A command line interface (e.g., command prompt, terminal
emulator.)</p></li>
</ul>
<p>The following software is also recommended:</p>
<ul>
<li>A wave viewer supporting <em>vcd</em> files (e.g., <a
href="https://gtkwave.sourceforge.net/">GTKWave</a>.)</li>
</ul>
<h2 id="what-is-hdlruby-and-how-to-use-its-framework">1. What is HDLRuby
and how to use its framework</h2>
<p>HDLRuby is a hardware description language (HDL) based on the Ruby
programming language. It is implemented as a Ruby library so that, by
construction, any Ruby code can be used and executed within the HDLRuby
description.</p>
<p>Before going further, let us briefly explain what is a <a
href="#11-what-is-a-hardware-description-language-hdl">HDL</a>. Then,
more details will be given about how to <a
href="#12-installing-hdlruby">install HDLRuby</a> and how to <a
href="#13-using-hdlruby">use it</a>.</p>
<h3 id="what-is-a-hardware-description-language-hdl">1.1. What is a
hardware description language (HDL)</h3>
<p>A hardware description language (HDL) is a formal language that is
used for describing electronic circuits. Such circuits can be divided
into two categories: analog circuits and digital circuits. While there
exists HDL for describing the first category of circuits, a large
majority of them only support the second one. Hence, in practice, HDL
usually means language for describing digital circuits only. Among the
multiple HDL, two became de-facto standards: Verilog HDL and VHDL.</p>
<p>Nowadays, there exist powerful software tools that can automatically
produce circuits from HDL descriptions. However, like in software, there
may be errors in the descriptions, or they may be sub-optimal, so that
the final circuit does not work, or does not meet some constraints.
Unfortunately, in hardware, producing a circuit is very time-consuming
and expensive so contrary to software, errors or low-performance results
must be avoided as early as possible. This is why it is common in
hardware to <strong>simulate</strong> your circuit description before
starting to produce it. In other words, while in software it is common
to perform the following loop:</p>
<p align="center">
<img src="sw_flow.png"  width="50%">
</p>
<p>In hardware, the design loop is more like as follows:</p>
<p align="center">
<img src="hw_flow.png"  width="50%">
</p>
<p>At first, an HDL has the same look and feel compared to classical
programming languages like C or Java: it includes expressions, control
statements, and kinds of variables. However, the underlying model of
computation is quite different, especially because circuits are
inherently parallel devices. This will be explained progressively during
this tutorial, but for now, it is enough to remember the following:</p>
<ul>
<li><p>HDL are used for describing digital circuits and the most common
ones are Verilog HDL and VHDL.</p></li>
<li><p>Using software tools called synthesis tools, you can produce real
digital circuits from HDL description. But before that, you will need to
simulate your description.</p></li>
<li><p>An HDL looks like a common programming language but does not work
the same.</p></li>
</ul>
<h4 id="and-what-about-hdlruby">And what about HDLRuby?</h4>
<p>Well, HDLRuby is an HDL for describing digital circuits like Verilog
HDL or VHDL but aims at being more flexible and productive than them by
relying on many concepts inherited from the Ruby programming language.
So everything said earlier about HDL applies to HDLRuby, but we try to
make it much easier for the designers. Furthermore, HDLRuby includes
constructs for describing and simulating software modules so that you
can design a full hardware-software device using the same framework
(there is a fancy word for that: hardware-software co-design).</p>
<h3 id="installing-hdlruby">1.2. Installing HDLRuby</h3>
<p>HDLRuby is distributed as a RubyGems package. It can therefore be
installed using the following command:</p>
<div class="sourceCode" id="cb1"><pre
class="sourceCode bash"><code class="sourceCode bash"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="ex">gem</span> install HDLRuby</span></code></pre></div>
<p>If everything is OK, the following should be displayed:</p>
<pre><code>Fetching HDLRuby-&lt;version&gt;.gem
Building native extensions. This could take a while...
Successfully installed HDLRuby-&lt;version&gt;
Parsing documentation for HDLRuby-&lt;version&gt;
Done installing documentation for HDLRuby after &lt;x&gt; seconds.</code></pre>
<p>The <code>version</code> number should be the latest version of
HDLRuby.</p>
<p>You can then check if HDLRuby is properly installed by using the
following command:</p>
<div class="sourceCode" id="cb3"><pre
class="sourceCode bash"><code class="sourceCode bash"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="ex">hdrcc</span> <span class="at">--version</span></span></code></pre></div>
<p>And the result should be:</p>
<pre><code>&lt;version&gt;</code></pre>
<p>If the resulting <code>version</code> number does not match the
install number, there may have been a problem somewhere. It may be a
good idea to close the terminal or command prompt and try again the
command in a new one.</p>
<h3 id="using-hdlruby">1.3. Using HDLRuby</h3>
<p>Up to now, we said that HDLRuby is a language, it is in truth a
complete framework for designing and simulating digital circuits. It
includes several compilers, simulators, and libraries that are all
accessible through a single command: <code>hdrcc</code>.</p>
<p>Basically, <code>hdrcc</code> is used as follows:</p>
<div class="sourceCode" id="cb5"><pre
class="sourceCode bash"><code class="sourceCode bash"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="ex">hdrcc</span> <span class="op">&lt;</span>options<span class="op">&gt;</span> <span class="op">&lt;</span>input file<span class="op">&gt;</span> <span class="op">&lt;</span>output directory<span class="op">&gt;</span></span></code></pre></div>
<p>Where <code>options</code> specifies the action to be performed,
<code>input file</code> specifies the input HDLRuby file, and
<code>output directory</code> specifies the directory where the command
results will be saved. As a general rule, when an input file is
specified, an output directory must also be specified.</p>
<p>Several actions are possible using <code>hdrcc</code>, the main ones
being the following:</p>
<ul>
<li>Simulate a circuit description:</li>
</ul>
<div class="sourceCode" id="cb6"><pre
class="sourceCode bash"><code class="sourceCode bash"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="ex">hdrcc</span> <span class="at">--sim</span> <span class="op">&lt;</span>input file<span class="op">&gt;</span> <span class="op">&lt;</span>output directory<span class="op">&gt;</span></span></code></pre></div>
<ul>
<li>Generate the equivalent Verilog HDL code:</li>
</ul>
<div class="sourceCode" id="cb7"><pre
class="sourceCode bash"><code class="sourceCode bash"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="ex">hdrcc</span> <span class="at">--verilog</span> <span class="op">&lt;</span>input file<span class="op">&gt;</span> <span class="op">&lt;</span>output directory<span class="op">&gt;</span></span></code></pre></div>
<p>This second action is necessary if you want to produce a real circuit
since HDLRuby is not yet supported by synthesis tools.</p>
<p><strong>Note</strong>: VHDL generation is also possible using the
following command.</p>
<div class="sourceCode" id="cb8"><pre
class="sourceCode bash"><code class="sourceCode bash"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="ex">hdrcc</span> <span class="at">--vhdl</span> <span class="op">&lt;</span>input file<span class="op">&gt;</span> <span class="op">&lt;</span>output directory<span class="op">&gt;</span></span></code></pre></div>
<p>And that’s it! For details about all the actions that can be
performed, how to write an input file, and what kind of output can be
produced, let us see the remaining of the tutorial.</p>
<h2 id="how-to-represent-a-circuit-in-hdlruby">2. How to represent a
circuit in HDLRuby</h2>
<p>In this section we will see:</p>
<ul>
<li><p><a href="#21-declaring-a-circuit">How to declare a
circuit.</a></p></li>
<li><p><a href="#22-how-to-reuse-a-circuit-already-declared">How to
reuse a circuit already declared.</a></p></li>
</ul>
<h3 id="declaring-a-circuit">2.1. Declaring a circuit</h3>
<p>In HDLRuby as well as in other HDL, a circuit is viewed as a box that
communicates with its environment with ports. The following charts
illustrate such a view with a circuit including 5 ports:</p>
<p align="center">
<img src="circuit_view.png"  width="35%">
</p>
<p>Ports are not simple entry points though, because they also have a
data type and a direction that can be one of the following:</p>
<ul>
<li><p><code>input</code>: such a port can be used for transmitting data
from the outside of the circuit to its inside.</p></li>
<li><p><code>output</code>: such a port can only be used for
transmitting data from the inside of the circuit to its
outside.</p></li>
<li><p><code>inout</code>: such a port can only be used both as an
<code>input</code> port and as an <code>output</code> port. Due to
physical limitations, these ports are difficult to use though, and will
therefore be ignored until the <a href="#tri-state">advance part of this
tutorial</a>.</p></li>
</ul>
<h4 id="thats-all-very-well-but-when-do-i-write-hdlruby-code">That’s all
very well, but when do I write HDLRuby code?</h4>
<p>With that in mind, declaring a circuit consists of specifying its
name and its ports. In HDLRuby this is done as follows:</p>
<div class="sourceCode" id="cb9"><pre
class="sourceCode ruby"><code class="sourceCode ruby"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="fu">system</span> <span class="wa">:my_circuit</span> <span class="cf">do</span></span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a>   input <span class="wa">:clk</span>, <span class="wa">:rst</span></span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a>   <span class="kw">[</span><span class="dv">16</span><span class="kw">]</span><span class="at">.input</span> <span class="wa">:addr</span></span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a>   input <span class="wa">:ce</span></span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true" tabindex="-1"></a>   <span class="kw">[</span><span class="dv">8</span><span class="kw">]</span><span class="at">.input</span>  <span class="wa">:data_in</span></span>
<span id="cb9-6"><a href="#cb9-6" aria-hidden="true" tabindex="-1"></a>   <span class="kw">[</span><span class="dv">8</span><span class="kw">]</span><span class="at">.output</span> <span class="wa">:data_out</span></span>
<span id="cb9-7"><a href="#cb9-7" aria-hidden="true" tabindex="-1"></a><span class="cf">end</span></span></code></pre></div>
<p>So please write the code above in a file called (for example)
<code>my_circuit.rb</code>, and let us explain its meaning.</p>
<ul>
<li><p>In the first line, the keyword <code>system</code> indicates a
new circuit will be described. Its name is given after the colon,
<code>my_circuit</code> here.</p></li>
<li><p>The <code>do</code> → <code>end</code> block contains the
description of the circuit. Here, only the ports are specified as
follows:</p>
<ul>
<li><p>On the second line, <code>input</code> specifies two one-bit
input ports named respectively <code>clk</code> and
<code>rst</code>.</p></li>
<li><p>The third line specifies a 16-bit input port named
<code>addr</code>.</p></li>
<li><p>The fourth line specifies a one-bit input port named
<code>ce</code>.</p></li>
<li><p>The fifth line specifies an eight-bit input port named
<code>data_in</code>.</p></li>
<li><p>The sixth line specifies an 8-bit output port named
<code>data_out</code>.</p></li>
</ul></li>
</ul>
<p>And here is a diagram of this circuit:</p>
<p align="center">
<img src="circuit_hdr.png"  width="50%">
</p>
<p>To sum up things:</p>
<ul>
<li><p><code>system</code> declares a new circuit description.</p></li>
<li><p><code>input</code> specifies one or several input ports,
<code>output</code> one or several output ports, and <code>inout</code>
one or several input-output ports.</p></li>
<li><p>The data type of the port is given before the direction as
follows:</p></li>
</ul>
<div class="sourceCode" id="cb10"><pre
class="sourceCode ruby"><code class="sourceCode ruby"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="kw">&lt;</span>type<span class="kw">&gt;</span><span class="at">.input</span> <span class="kw">&lt;</span>list of ports names<span class="kw">&gt;</span></span></code></pre></div>
<p>We will give later more details about data types in HDLRuby.</p>
<p>Now let us see if your circuit description is all right with the
following command:</p>
<div class="sourceCode" id="cb11"><pre
class="sourceCode bash"><code class="sourceCode bash"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="ex">hdrcc</span> my_circuit.rb work</span></code></pre></div>
<p>…Nothing happened? Great, that means that there was no syntax error
in your description. Now let us try something else:</p>
<div class="sourceCode" id="cb12"><pre
class="sourceCode bash"><code class="sourceCode bash"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a><span class="ex">hdrcc</span> <span class="at">--hdr</span> my_circuit.rb work</span></code></pre></div>
<p>If everything was OK, a file named <code>my_circuit.rb</code> should
have appeared in the <code>work</code> directory. Open it with a text
editor, its content should be the following:</p>
<div class="sourceCode" id="cb13"><pre
class="sourceCode ruby"><code class="sourceCode ruby"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a><span class="fu">system</span> :<span class="st">&quot;__:T:0:1&quot;</span> <span class="cf">do</span></span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a>   bit<span class="kw">.</span> input <span class="wa">:clk</span></span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true" tabindex="-1"></a>   bit<span class="at">.input</span> <span class="wa">:rst</span></span>
<span id="cb13-4"><a href="#cb13-4" aria-hidden="true" tabindex="-1"></a>   bit<span class="kw">[</span><span class="dv">15</span><span class="kw">..</span><span class="dv">0</span><span class="kw">]</span><span class="at">.input</span> <span class="wa">:addr</span></span>
<span id="cb13-5"><a href="#cb13-5" aria-hidden="true" tabindex="-1"></a>   bit<span class="at">.input</span> <span class="wa">:ce</span></span>
<span id="cb13-6"><a href="#cb13-6" aria-hidden="true" tabindex="-1"></a>   bit<span class="kw">[</span><span class="dv">7</span><span class="kw">..</span><span class="dv">0</span><span class="kw">]</span><span class="at">.input</span> <span class="wa">:data_in</span></span>
<span id="cb13-7"><a href="#cb13-7" aria-hidden="true" tabindex="-1"></a>   bit<span class="kw">[</span><span class="dv">7</span><span class="kw">..</span><span class="dv">0</span><span class="kw">]</span><span class="at">.output</span> <span class="wa">:data_out</span></span>
<span id="cb13-8"><a href="#cb13-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-9"><a href="#cb13-9" aria-hidden="true" tabindex="-1"></a><span class="cf">end</span></span></code></pre></div>
<p>It looks somewhat similar to the code you have just written. This is
because it is the internal representation (IR) of your circuit in
HDLRuby. You can see that the name of the circuit changed to some weird
character string and that the data types also changed. The weird string
is for avoiding name clashes, so you do not need to be concerned about
it. The data types are low-level representations of the same data types
that were used in the initial file. Still, this low-level representation
is very close to the original one, but that will be less and less the
case as the features are added to the circuit.</p>
<p>Now, out of curiosity, how will look the equivalent Verilog HDL code?
To check that just type the following command:</p>
<div class="sourceCode" id="cb14"><pre
class="sourceCode bash"><code class="sourceCode bash"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a><span class="ex">hdrcc</span> <span class="at">--verilog</span> my_circuit.rb work</span></code></pre></div>
<p>If everything was OK, a file named <code>my_circuit.v</code> should
have appeared in the <code>work</code> directory. Open it with a text
editor, its content should be the following:</p>
<div class="sourceCode" id="cb15"><pre
class="sourceCode verilog"><code class="sourceCode verilog"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a><span class="ot">`timescale 1ps/1ps</span></span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-3"><a href="#cb15-3" aria-hidden="true" tabindex="-1"></a><span class="kw">module</span> _v0_1<span class="op">(</span> clk<span class="op">,</span> rst<span class="op">,</span> addr<span class="op">,</span> data_in<span class="op">,</span> data_out <span class="op">);</span></span>
<span id="cb15-4"><a href="#cb15-4" aria-hidden="true" tabindex="-1"></a>   <span class="dt">input</span> clk<span class="op">;</span></span>
<span id="cb15-5"><a href="#cb15-5" aria-hidden="true" tabindex="-1"></a>   <span class="dt">input</span> rst<span class="op">;</span></span>
<span id="cb15-6"><a href="#cb15-6" aria-hidden="true" tabindex="-1"></a>   <span class="dt">input</span> <span class="op">[</span><span class="dv">15</span><span class="op">:</span><span class="dv">0</span><span class="op">]</span> addr<span class="op">;</span></span>
<span id="cb15-7"><a href="#cb15-7" aria-hidden="true" tabindex="-1"></a>   <span class="dt">input</span> ce<span class="op">;</span></span>
<span id="cb15-8"><a href="#cb15-8" aria-hidden="true" tabindex="-1"></a>   <span class="dt">input</span> <span class="op">[</span><span class="dv">7</span><span class="op">:</span><span class="dv">0</span><span class="op">]</span> data_in<span class="op">;</span></span>
<span id="cb15-9"><a href="#cb15-9" aria-hidden="true" tabindex="-1"></a>   <span class="dt">output</span> <span class="op">[</span><span class="dv">7</span><span class="op">:</span><span class="dv">0</span><span class="op">]</span> data_out<span class="op">;</span></span>
<span id="cb15-10"><a href="#cb15-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-11"><a href="#cb15-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-12"><a href="#cb15-12" aria-hidden="true" tabindex="-1"></a><span class="kw">endmodule</span></span></code></pre></div>
<p>The syntax looks indeed a little bit different from HDLRuby, but you
should be able to recognize the description of the circuit. The name of
the module is different though, this is because HDLRuby supports any
Unicode character for names and to avoid compatibility problems, it
recreates the names when generating Verilog. But, just for the fun,
please replace <code>:addr</code> in the HDLRuby file with
<code>:☺</code> and regenerate Verilog HDL from it… It works! And the
result is:</p>
<div class="sourceCode" id="cb16"><pre
class="sourceCode verilog"><code class="sourceCode verilog"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a><span class="ot">`timescale 1ps/1ps</span></span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-3"><a href="#cb16-3" aria-hidden="true" tabindex="-1"></a><span class="kw">module</span> _v0_1<span class="op">(</span> clk<span class="op">,</span> rst<span class="op">,</span> _v1_<span class="op">,</span> data_in<span class="op">,</span> data_out <span class="op">);</span></span>
<span id="cb16-4"><a href="#cb16-4" aria-hidden="true" tabindex="-1"></a>   <span class="dt">input</span> clk<span class="op">;</span></span>
<span id="cb16-5"><a href="#cb16-5" aria-hidden="true" tabindex="-1"></a>   <span class="dt">input</span> rst<span class="op">;</span></span>
<span id="cb16-6"><a href="#cb16-6" aria-hidden="true" tabindex="-1"></a>   <span class="dt">input</span> <span class="op">[</span><span class="dv">15</span><span class="op">:</span><span class="dv">0</span><span class="op">]</span> _v1_<span class="op">;</span></span>
<span id="cb16-7"><a href="#cb16-7" aria-hidden="true" tabindex="-1"></a>   <span class="dt">input</span> ce<span class="op">;</span></span>
<span id="cb16-8"><a href="#cb16-8" aria-hidden="true" tabindex="-1"></a>   <span class="dt">input</span> <span class="op">[</span><span class="dv">7</span><span class="op">:</span><span class="dv">0</span><span class="op">]</span> data_in<span class="op">;</span></span>
<span id="cb16-9"><a href="#cb16-9" aria-hidden="true" tabindex="-1"></a>   <span class="dt">output</span> <span class="op">[</span><span class="dv">7</span><span class="op">:</span><span class="dv">0</span><span class="op">]</span> data_out<span class="op">;</span></span>
<span id="cb16-10"><a href="#cb16-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-11"><a href="#cb16-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-12"><a href="#cb16-12" aria-hidden="true" tabindex="-1"></a><span class="kw">endmodule</span></span></code></pre></div>
<p>Unfortunately, there is no more smiling face. This is because Verilog
HDL only supports a subset of ASCII for names. But even without smiling,
the code is valid because the HDLRuby framework did recreate Verilog
HDL-friendly names.</p>
<h3 id="how-to-reuse-a-circuit-already-declared">2.2. How to reuse a
circuit already declared</h3>
<p>Like with functions in software, a circuit is often used as part of
one or several larger circuits. Contrary to the software, however, the
circuit must be physically copied to be reused. This copy is called an
<em>instance</em> and the act of copying an <em>instantiation</em>. In
HDLRuby, an instantiation is done as follows:</p>
<div class="sourceCode" id="cb17"><pre
class="sourceCode ruby"><code class="sourceCode ruby"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a><span class="kw">&lt;</span>circuit name<span class="kw">&gt;</span>(:<span class="kw">&lt;</span>copy name<span class="kw">&gt;</span>)</span></code></pre></div>
<p>For example, if you want to use copies of the previously defined
circuit <code>my_circuit</code> in a new circuit called
<code>another_circuit</code> you can do as follows:</p>
<div class="sourceCode" id="cb18"><pre
class="sourceCode ruby"><code class="sourceCode ruby"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a><span class="fu">system</span> <span class="wa">:another_circuit</span> <span class="cf">do</span></span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true" tabindex="-1"></a>   input <span class="wa">:clk</span>, <span class="wa">:rst</span></span>
<span id="cb18-3"><a href="#cb18-3" aria-hidden="true" tabindex="-1"></a>   <span class="kw">[</span><span class="dv">16</span><span class="kw">]</span><span class="at">.input</span> <span class="wa">:addr</span></span>
<span id="cb18-4"><a href="#cb18-4" aria-hidden="true" tabindex="-1"></a>   input <span class="wa">:ce0</span>, <span class="wa">:ce1</span></span>
<span id="cb18-5"><a href="#cb18-5" aria-hidden="true" tabindex="-1"></a>   <span class="kw">[</span><span class="dv">8</span><span class="kw">]</span><span class="at">.input</span> <span class="wa">:data_in</span></span>
<span id="cb18-6"><a href="#cb18-6" aria-hidden="true" tabindex="-1"></a>   <span class="kw">[</span><span class="dv">8</span><span class="kw">]</span><span class="at">.output</span> <span class="wa">:data_out</span></span>
<span id="cb18-7"><a href="#cb18-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-8"><a href="#cb18-8" aria-hidden="true" tabindex="-1"></a>   my_circuit(<span class="wa">:my_circuit0</span>)</span>
<span id="cb18-9"><a href="#cb18-9" aria-hidden="true" tabindex="-1"></a>   my_circuit(<span class="wa">:my_circuit1</span>)</span>
<span id="cb18-10"><a href="#cb18-10" aria-hidden="true" tabindex="-1"></a><span class="cf">end</span></span></code></pre></div>
<p>For testing purposes, write the code above into another file called
<code>another_circuit.rb</code>, and try to generate Verilog HDL from
it:</p>
<div class="sourceCode" id="cb19"><pre
class="sourceCode bash"><code class="sourceCode bash"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a><span class="ex">hdrcc</span> <span class="at">--verilog</span> another_circuit.rb work</span></code></pre></div>
<p>Oh, it appears that something went wrong since the following should
have appeared:</p>
<pre><code>another_circuit.rb:8:in `block in &lt;main&gt;&#39;: undefined HDLRuby construct, local variable or method `my_circuit&#39;.</code></pre>
<p>This error message indicates that <code>my_circuit</code> is not
known. This is because, like the Ruby language, in HDLRuby you must
specify the files you are using. Please add as the first line in your
<code>another_circuit.rb</code> file the following code:</p>
<div class="sourceCode" id="cb21"><pre
class="sourceCode ruby"><code class="sourceCode ruby"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true" tabindex="-1"></a><span class="fu">require_relative</span> <span class="st">&quot;my_circuit.rb&quot;</span></span></code></pre></div>
<p>Then retry the Verilog HDL generation command:</p>
<div class="sourceCode" id="cb22"><pre
class="sourceCode bash"><code class="sourceCode bash"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true" tabindex="-1"></a><span class="ex">hdrcc</span> <span class="at">--verilog</span> another_circuit.rb work</span></code></pre></div>
<p>Three new files should have appeared in the <code>work</code>
directory: <code>_v10_5.v</code>, <code>_v8_4.v</code> and
<code>another_circuit.v</code>. If you open the third file you should
see:</p>
<div class="sourceCode" id="cb23"><pre
class="sourceCode verilog"><code class="sourceCode verilog"><span id="cb23-1"><a href="#cb23-1" aria-hidden="true" tabindex="-1"></a><span class="ot">`timescale 1ps/1ps</span></span>
<span id="cb23-2"><a href="#cb23-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-3"><a href="#cb23-3" aria-hidden="true" tabindex="-1"></a><span class="kw">module</span> _v0_3<span class="op">(</span> clk<span class="op">,</span> rst<span class="op">,</span> addr<span class="op">,</span> ce0<span class="op">,</span> ce1<span class="op">,</span> data_in<span class="op">,</span> data_out <span class="op">);</span></span>
<span id="cb23-4"><a href="#cb23-4" aria-hidden="true" tabindex="-1"></a>   <span class="dt">input</span> clk<span class="op">;</span></span>
<span id="cb23-5"><a href="#cb23-5" aria-hidden="true" tabindex="-1"></a>   <span class="dt">input</span> rst<span class="op">;</span></span>
<span id="cb23-6"><a href="#cb23-6" aria-hidden="true" tabindex="-1"></a>   <span class="dt">input</span> <span class="op">[</span><span class="dv">15</span><span class="op">:</span><span class="dv">0</span><span class="op">]</span> addr<span class="op">;</span></span>
<span id="cb23-7"><a href="#cb23-7" aria-hidden="true" tabindex="-1"></a>   <span class="dt">input</span> ce0<span class="op">;</span></span>
<span id="cb23-8"><a href="#cb23-8" aria-hidden="true" tabindex="-1"></a>   <span class="dt">input</span> ce1<span class="op">;</span></span>
<span id="cb23-9"><a href="#cb23-9" aria-hidden="true" tabindex="-1"></a>   <span class="dt">input</span> <span class="op">[</span><span class="dv">7</span><span class="op">:</span><span class="dv">0</span><span class="op">]</span> data_in<span class="op">;</span></span>
<span id="cb23-10"><a href="#cb23-10" aria-hidden="true" tabindex="-1"></a>   <span class="dt">output</span> <span class="op">[</span><span class="dv">7</span><span class="op">:</span><span class="dv">0</span><span class="op">]</span> data_out<span class="op">;</span></span>
<span id="cb23-11"><a href="#cb23-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-12"><a href="#cb23-12" aria-hidden="true" tabindex="-1"></a>   _v8_4 my_circuit0<span class="op">();</span></span>
<span id="cb23-13"><a href="#cb23-13" aria-hidden="true" tabindex="-1"></a>   _v10_5 my_circuit1<span class="op">();</span></span>
<span id="cb23-14"><a href="#cb23-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-15"><a href="#cb23-15" aria-hidden="true" tabindex="-1"></a><span class="kw">endmodule</span></span></code></pre></div>
<p>Again, we can see similarities between the resulting Verilog HDL code
and the original HDLRuby one. Still, what are <code>_v8_4</code> and
<code>_v10_5</code>? You can see them by opening the corresponding files
<code>_v8_4.rb</code> and <code>_v10_5.rb</code>, those are the
descriptions of <code>my_circuit</code> in Verilog HDL.</p>
<blockquote>
<p><strong>But why two of them?</strong> I would like to answer that
this is because of a limitation of Verilog HDL, but this is not the
case. It is because HDLRuby’s instantiation mechanism is very different
from the Verilog HDL (and the VHDL) one, so for the moment, and only for
easing the coding work of the HDLRuby compiler, one description of
<code>my_circuit</code> is generated per instance.</p>
</blockquote>
<p>Copying a circuit is easy, but it achieves no purpose if the copied
circuit is not in a relationship with its environment. It is where the
ports become useful: they are the communication points between a circuit
and its outside world. Concretely, to interact with a circuit, its ports
must be connected to something that will interact with them. How this
interaction works is a story for the other sections of this tutorial.
For now, let us focus on connections: in HDLRuby this is done using the
assignment operator <code>&lt;=</code> as follows:</p>
<ul>
<li>For an input port of the current circuit:<br />
</li>
</ul>
<div class="sourceCode" id="cb24"><pre
class="sourceCode ruby"><code class="sourceCode ruby"><span id="cb24-1"><a href="#cb24-1" aria-hidden="true" tabindex="-1"></a><span class="kw">&lt;</span>something<span class="kw">&gt;</span> <span class="kw">&lt;=</span> <span class="kw">&lt;</span>input port<span class="kw">&gt;</span></span></code></pre></div>
<ul>
<li>For an output port of the current circuit:</li>
</ul>
<div class="sourceCode" id="cb25"><pre
class="sourceCode ruby"><code class="sourceCode ruby"><span id="cb25-1"><a href="#cb25-1" aria-hidden="true" tabindex="-1"></a><span class="kw">&lt;</span>output port<span class="kw">&gt;</span> <span class="kw">&lt;=</span> <span class="kw">&lt;</span>something<span class="kw">&gt;</span></span></code></pre></div>
<p>Many things can be connected to a port, but right now, we only know
about ports, so let us do the connection in <code>another_circuit</code>
with them. So here is the new code of <code>another_circuit.rb</code>,
please modify the file accordingly:</p>
<div class="sourceCode" id="cb26"><pre
class="sourceCode ruby"><code class="sourceCode ruby"><span id="cb26-1"><a href="#cb26-1" aria-hidden="true" tabindex="-1"></a><span class="fu">require_relative</span> <span class="st">&quot;my_circuit.rb&quot;</span></span>
<span id="cb26-2"><a href="#cb26-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-3"><a href="#cb26-3" aria-hidden="true" tabindex="-1"></a><span class="fu">system</span> <span class="wa">:another_circuit</span> <span class="cf">do</span></span>
<span id="cb26-4"><a href="#cb26-4" aria-hidden="true" tabindex="-1"></a>   input <span class="wa">:clk</span>, <span class="wa">:rst</span></span>
<span id="cb26-5"><a href="#cb26-5" aria-hidden="true" tabindex="-1"></a>   <span class="kw">[</span><span class="dv">16</span><span class="kw">]</span><span class="at">.input</span> <span class="wa">:addr</span></span>
<span id="cb26-6"><a href="#cb26-6" aria-hidden="true" tabindex="-1"></a>   input <span class="wa">:ce0</span>, <span class="wa">:ce1</span></span>
<span id="cb26-7"><a href="#cb26-7" aria-hidden="true" tabindex="-1"></a>   <span class="kw">[</span><span class="dv">8</span><span class="kw">]</span><span class="at">.input</span> <span class="wa">:data_in</span></span>
<span id="cb26-8"><a href="#cb26-8" aria-hidden="true" tabindex="-1"></a>   <span class="kw">[</span><span class="dv">8</span><span class="kw">]</span><span class="at">.output</span> <span class="wa">:data_out</span></span>
<span id="cb26-9"><a href="#cb26-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-10"><a href="#cb26-10" aria-hidden="true" tabindex="-1"></a>   my_circuit(<span class="wa">:my_circuit0</span>)</span>
<span id="cb26-11"><a href="#cb26-11" aria-hidden="true" tabindex="-1"></a>   my_circuit(<span class="wa">:my_circuit1</span>)</span>
<span id="cb26-12"><a href="#cb26-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-13"><a href="#cb26-13" aria-hidden="true" tabindex="-1"></a>   my_circuit0<span class="at">.clk</span>  <span class="kw">&lt;=</span> clk</span>
<span id="cb26-14"><a href="#cb26-14" aria-hidden="true" tabindex="-1"></a>   my_circuit0<span class="at">.rst</span>  <span class="kw">&lt;=</span> rst</span>
<span id="cb26-15"><a href="#cb26-15" aria-hidden="true" tabindex="-1"></a>   my_circuit0<span class="at">.addr</span> <span class="kw">&lt;=</span> addr</span>
<span id="cb26-16"><a href="#cb26-16" aria-hidden="true" tabindex="-1"></a>   my_circuit0<span class="at">.ce</span>   <span class="kw">&lt;=</span> ce0</span>
<span id="cb26-17"><a href="#cb26-17" aria-hidden="true" tabindex="-1"></a>   my_circuit0<span class="at">.data_in</span> <span class="kw">&lt;=</span> data_in</span>
<span id="cb26-18"><a href="#cb26-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-19"><a href="#cb26-19" aria-hidden="true" tabindex="-1"></a>   my_circuit1<span class="at">.clk</span>  <span class="kw">&lt;=</span> clk</span>
<span id="cb26-20"><a href="#cb26-20" aria-hidden="true" tabindex="-1"></a>   my_circuit1<span class="at">.rst</span>  <span class="kw">&lt;=</span> rst</span>
<span id="cb26-21"><a href="#cb26-21" aria-hidden="true" tabindex="-1"></a>   my_circuit1<span class="at">.addr</span> <span class="kw">&lt;=</span> addr</span>
<span id="cb26-22"><a href="#cb26-22" aria-hidden="true" tabindex="-1"></a>   my_circuit1<span class="at">.ce</span>   <span class="kw">&lt;=</span> ce1</span>
<span id="cb26-23"><a href="#cb26-23" aria-hidden="true" tabindex="-1"></a>   my_circuit1<span class="at">.data_in</span> <span class="kw">&lt;=</span> data_in</span>
<span id="cb26-24"><a href="#cb26-24" aria-hidden="true" tabindex="-1"></a><span class="cf">end</span></span></code></pre></div>
<p>If you are familiar with object-oriented or structured software
programming, this code should be straightforward: the dot <code>.</code>
operator is used to access a sub-element and in this case the ports of
<code>my_circuit0</code> and <code>my_circuit1</code>. For example, the
first connection line (line 10) connects the <code>clk</code> port of
<code>another_circuit</code> to the one of <code>my_circuit0</code>, so
that any data that goes through the former port will also go through the
latter.</p>
<p>Now, the <code>data_out</code> ports are still not connected. It may
be tempting to connect them like <code>data_in</code> as follows:</p>
<div class="sourceCode" id="cb27"><pre
class="sourceCode ruby"><code class="sourceCode ruby"><span id="cb27-1"><a href="#cb27-1" aria-hidden="true" tabindex="-1"></a>  data_out <span class="kw">&lt;=</span> circuit0<span class="at">.data_out</span></span>
<span id="cb27-2"><a href="#cb27-2" aria-hidden="true" tabindex="-1"></a>  data_out <span class="kw">&lt;=</span> circuit1<span class="at">.data_out</span></span></code></pre></div>
<p>This will work indeed, but not the way you may think: in hardware,
you cannot normally connect to one port several different objects. It is
like assigning several values at the <strong>same</strong> time to a
single variable. What will happen in HDLRuby, is that only the last
statement will be kept, i.e., port <code>data_out</code> of
<code>circuit0</code> will not be connected.</p>
<p>With such kind of cases, what we often want to do is to connect to
<code>data_out</code> some computation result between the output of
<code>circuit0</code> and <code>circuit1</code>. This is the opportunity
to see another kind of construct that can be connected to a port: an
expression. Like in software, an expression represents an arithmetic and
logic computation. For example, let us consider the following
connection:</p>
<div class="sourceCode" id="cb28"><pre
class="sourceCode ruby"><code class="sourceCode ruby"><span id="cb28-1"><a href="#cb28-1" aria-hidden="true" tabindex="-1"></a>  data_out <span class="kw">&lt;=</span> my_circuit0<span class="at">.data_out</span> <span class="kw">+</span> my_circuit1<span class="at">.data_out</span></span></code></pre></div>
<p>With this connection, the sum of the outputs <code>my_circuit0</code>
and <code>my_circuit1</code> is transmitted through the output port
<code>data_out</code> of <code>another_circuit</code>.</p>
<blockquote>
<p><strong>But when is this computation performed?</strong> This is a
very good question: while in software, programs are executed one
instruction after the other, in hardware, there is no such thing as the
execution of instructions. The expression connected to
<code>data_out</code> is not an instruction at all! It is a description
of a part of the circuit that specifies that an adder (a circuit that
does addition) must be instantiated with the output ports
<code>data_out</code> of <code>my_circuit0</code> and
<code>my_circuit1</code> connected to its inputs and its output
connected to the output port <code>data_out</code> of
<code>another_circuit</code>. The following figures show the schematic
of this hardware portion:</p>
</blockquote>
<p align="center">
<img src="circuit_hie.png"  width="40%">
</p>
<blockquote>
<p><strong>So, when this expression is executed?</strong> It is
continuously executed, i.e., as soon as one of the outputs
<code>data_out</code> of <code>my_circuit0</code> or
<code>my_circuit1</code> changes, so does the output
<code>data_out</code> of <code>another_circuit</code>.</p>
</blockquote>
<p>For trying this new circuit, please update the code of
<code>another_circuit.rb</code> as follows:</p>
<div class="sourceCode" id="cb29"><pre
class="sourceCode ruby"><code class="sourceCode ruby"><span id="cb29-1"><a href="#cb29-1" aria-hidden="true" tabindex="-1"></a><span class="fu">require_relative</span> <span class="st">&quot;my_circuit.rb&quot;</span></span>
<span id="cb29-2"><a href="#cb29-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb29-3"><a href="#cb29-3" aria-hidden="true" tabindex="-1"></a><span class="fu">system</span> <span class="wa">:another_circuit</span> <span class="cf">do</span></span>
<span id="cb29-4"><a href="#cb29-4" aria-hidden="true" tabindex="-1"></a>   input <span class="wa">:clk</span>, <span class="wa">:rst</span></span>
<span id="cb29-5"><a href="#cb29-5" aria-hidden="true" tabindex="-1"></a>   <span class="kw">[</span><span class="dv">16</span><span class="kw">]</span><span class="at">.input</span> <span class="wa">:addr</span></span>
<span id="cb29-6"><a href="#cb29-6" aria-hidden="true" tabindex="-1"></a>   input <span class="wa">:ce0</span>, <span class="wa">:ce1</span></span>
<span id="cb29-7"><a href="#cb29-7" aria-hidden="true" tabindex="-1"></a>   <span class="kw">[</span><span class="dv">8</span><span class="kw">]</span><span class="at">.input</span> <span class="wa">:data_in</span></span>
<span id="cb29-8"><a href="#cb29-8" aria-hidden="true" tabindex="-1"></a>   <span class="kw">[</span><span class="dv">8</span><span class="kw">]</span><span class="at">.output</span> <span class="wa">:data_out</span></span>
<span id="cb29-9"><a href="#cb29-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb29-10"><a href="#cb29-10" aria-hidden="true" tabindex="-1"></a>   my_circuit(<span class="wa">:my_circuit0</span>)</span>
<span id="cb29-11"><a href="#cb29-11" aria-hidden="true" tabindex="-1"></a>   my_circuit(<span class="wa">:my_circuit1</span>)</span>
<span id="cb29-12"><a href="#cb29-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb29-13"><a href="#cb29-13" aria-hidden="true" tabindex="-1"></a>   my_circuit0<span class="at">.clk</span>  <span class="kw">&lt;=</span> clk</span>
<span id="cb29-14"><a href="#cb29-14" aria-hidden="true" tabindex="-1"></a>   my_circuit0<span class="at">.rst</span>  <span class="kw">&lt;=</span> rst</span>
<span id="cb29-15"><a href="#cb29-15" aria-hidden="true" tabindex="-1"></a>   my_circuit0<span class="at">.addr</span> <span class="kw">&lt;=</span> addr</span>
<span id="cb29-16"><a href="#cb29-16" aria-hidden="true" tabindex="-1"></a>   my_circuit0<span class="at">.ce</span>   <span class="kw">&lt;=</span> ce0</span>
<span id="cb29-17"><a href="#cb29-17" aria-hidden="true" tabindex="-1"></a>   my_circuit0<span class="at">.data_in</span> <span class="kw">&lt;=</span> data_in</span>
<span id="cb29-18"><a href="#cb29-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb29-19"><a href="#cb29-19" aria-hidden="true" tabindex="-1"></a>   my_circuit1<span class="at">.clk</span>  <span class="kw">&lt;=</span> clk</span>
<span id="cb29-20"><a href="#cb29-20" aria-hidden="true" tabindex="-1"></a>   my_circuit1<span class="at">.rst</span>  <span class="kw">&lt;=</span> rst</span>
<span id="cb29-21"><a href="#cb29-21" aria-hidden="true" tabindex="-1"></a>   my_circuit1<span class="at">.addr</span> <span class="kw">&lt;=</span> addr</span>
<span id="cb29-22"><a href="#cb29-22" aria-hidden="true" tabindex="-1"></a>   my_circuit1<span class="at">.ce</span>   <span class="kw">&lt;=</span> ce1</span>
<span id="cb29-23"><a href="#cb29-23" aria-hidden="true" tabindex="-1"></a>   my_circuit1<span class="at">.data_in</span> <span class="kw">&lt;=</span> data_in</span>
<span id="cb29-24"><a href="#cb29-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb29-25"><a href="#cb29-25" aria-hidden="true" tabindex="-1"></a>   data_out <span class="kw">&lt;=</span> my_circuit0<span class="at">.data_out</span> <span class="kw">+</span> my_circuit1<span class="at">.data_out</span></span>
<span id="cb29-26"><a href="#cb29-26" aria-hidden="true" tabindex="-1"></a><span class="cf">end</span></span></code></pre></div>
<p>Then, let us generate again Verilog HDL from it:</p>
<div class="sourceCode" id="cb30"><pre
class="sourceCode bash"><code class="sourceCode bash"><span id="cb30-1"><a href="#cb30-1" aria-hidden="true" tabindex="-1"></a><span class="ex">hdrcc</span> <span class="at">--verilog</span> another_circuit.rb work</span></code></pre></div>
<p>Oh! If you get the following error message:</p>
<pre><code>another_circuit.rb:15:in `block in &lt;main&gt;&#39;: undefined method `addr&#39; for #&lt;HDLRuby::High::Namespace:&lt;whatever number&gt;&gt;</code></pre>
<p>Do not forget to replace the smiling face with <code>addr</code> in
<code>my_circuit.rb</code>.</p>
<p>When the compile succeeds (no error message), two new files appear in
<code>work</code>, namely <code>_v20_4.v</code> and
<code>_v23_5.v</code>. Those are the new descriptions of
<code>my_circuit</code>, they did not change, but since new hardware has
been added their name changed. For the interesting part, let us open
again <code>another_circuit.v</code>, the result should be as
follows:</p>
<div class="sourceCode" id="cb32"><pre
class="sourceCode verilog"><code class="sourceCode verilog"><span id="cb32-1"><a href="#cb32-1" aria-hidden="true" tabindex="-1"></a><span class="ot">`timescale 1ps/1ps</span></span>
<span id="cb32-2"><a href="#cb32-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-3"><a href="#cb32-3" aria-hidden="true" tabindex="-1"></a><span class="kw">module</span> _v0_3<span class="op">(</span> clk<span class="op">,</span> rst<span class="op">,</span> addr<span class="op">,</span> ce0<span class="op">,</span> ce1<span class="op">,</span> data_in<span class="op">,</span> data_out <span class="op">);</span></span>
<span id="cb32-4"><a href="#cb32-4" aria-hidden="true" tabindex="-1"></a>   <span class="dt">input</span> _v1_clk<span class="op">;</span></span>
<span id="cb32-5"><a href="#cb32-5" aria-hidden="true" tabindex="-1"></a>   <span class="dt">input</span> _v2_rst<span class="op">;</span></span>
<span id="cb32-6"><a href="#cb32-6" aria-hidden="true" tabindex="-1"></a>   <span class="dt">input</span> <span class="op">[</span><span class="dv">15</span><span class="op">:</span><span class="dv">0</span><span class="op">]</span> addr<span class="op">;</span></span>
<span id="cb32-7"><a href="#cb32-7" aria-hidden="true" tabindex="-1"></a>   <span class="dt">input</span> ce0<span class="op">;</span></span>
<span id="cb32-8"><a href="#cb32-8" aria-hidden="true" tabindex="-1"></a>   <span class="dt">input</span> ce1<span class="op">;</span></span>
<span id="cb32-9"><a href="#cb32-9" aria-hidden="true" tabindex="-1"></a>   <span class="dt">input</span> <span class="op">[</span><span class="dv">7</span><span class="op">:</span><span class="dv">0</span><span class="op">]</span> data_in<span class="op">;</span></span>
<span id="cb32-10"><a href="#cb32-10" aria-hidden="true" tabindex="-1"></a>   <span class="dt">output</span> <span class="op">[</span><span class="dv">7</span><span class="op">:</span><span class="dv">0</span><span class="op">]</span> data_out<span class="op">;</span></span>
<span id="cb32-11"><a href="#cb32-11" aria-hidden="true" tabindex="-1"></a>   <span class="dt">wire</span> _v8_0<span class="op">;</span></span>
<span id="cb32-12"><a href="#cb32-12" aria-hidden="true" tabindex="-1"></a>   <span class="dt">wire</span> _v9_1<span class="op">;</span></span>
<span id="cb32-13"><a href="#cb32-13" aria-hidden="true" tabindex="-1"></a>   <span class="dt">wire</span> <span class="op">[</span><span class="dv">15</span><span class="op">:</span><span class="dv">0</span><span class="op">]</span> _v10_2<span class="op">;</span></span>
<span id="cb32-14"><a href="#cb32-14" aria-hidden="true" tabindex="-1"></a>   <span class="dt">wire</span> _v11_3<span class="op">;</span></span>
<span id="cb32-15"><a href="#cb32-15" aria-hidden="true" tabindex="-1"></a>   <span class="dt">wire</span> <span class="op">[</span><span class="dv">7</span><span class="op">:</span><span class="dv">0</span><span class="op">]</span> _v12_4<span class="op">;</span></span>
<span id="cb32-16"><a href="#cb32-16" aria-hidden="true" tabindex="-1"></a>   <span class="dt">wire</span> _v13_5<span class="op">;</span></span>
<span id="cb32-17"><a href="#cb32-17" aria-hidden="true" tabindex="-1"></a>   <span class="dt">wire</span> _v14_6<span class="op">;</span></span>
<span id="cb32-18"><a href="#cb32-18" aria-hidden="true" tabindex="-1"></a>   <span class="dt">wire</span> <span class="op">[</span><span class="dv">15</span><span class="op">:</span><span class="dv">0</span><span class="op">]</span> _v15_7<span class="op">;</span></span>
<span id="cb32-19"><a href="#cb32-19" aria-hidden="true" tabindex="-1"></a>   <span class="dt">wire</span> _v16_8<span class="op">;</span></span>
<span id="cb32-20"><a href="#cb32-20" aria-hidden="true" tabindex="-1"></a>   <span class="dt">wire</span> <span class="op">[</span><span class="dv">7</span><span class="op">:</span><span class="dv">0</span><span class="op">]</span> _v17_9<span class="op">;</span></span>
<span id="cb32-21"><a href="#cb32-21" aria-hidden="true" tabindex="-1"></a>   <span class="dt">wire</span> <span class="op">[</span><span class="dv">7</span><span class="op">:</span><span class="dv">0</span><span class="op">]</span> _v18_10<span class="op">;</span></span>
<span id="cb32-22"><a href="#cb32-22" aria-hidden="true" tabindex="-1"></a>   <span class="dt">wire</span> <span class="op">[</span><span class="dv">7</span><span class="op">:</span><span class="dv">0</span><span class="op">]</span> _v19_11<span class="op">;</span></span>
<span id="cb32-23"><a href="#cb32-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-24"><a href="#cb32-24" aria-hidden="true" tabindex="-1"></a>      _v20_4 my_circuit0<span class="op">(</span>.clk<span class="op">(</span>_v8_0<span class="op">),</span>.rst<span class="op">(</span>_v9_1<span class="op">),</span>.addr<span class="op">(</span>_v10_2<span class="op">),</span>.ce<span class="op">(</span>_v11_3<span class="op">),</span>.data_in<span class="op">(</span>_v12_4<span class="op">),</span>.data_out<span class="op">(</span>_v18_10<span class="op">));</span></span>
<span id="cb32-25"><a href="#cb32-25" aria-hidden="true" tabindex="-1"></a>   _v23_5 my_circuit1<span class="op">(</span>.clk<span class="op">(</span>_v13_5<span class="op">),</span>.rst<span class="op">(</span>_v14_6<span class="op">),</span>.addr<span class="op">(</span>_v15_7<span class="op">),</span>.ce<span class="op">(</span>_v16_8<span class="op">),</span>.data_in<span class="op">(</span>_v17_9<span class="op">),</span>.data_out<span class="op">(</span>_v19_11<span class="op">));</span></span>
<span id="cb32-26"><a href="#cb32-26" aria-hidden="true" tabindex="-1"></a>   <span class="kw">assign</span> _v8_0 <span class="op">=</span> clk<span class="op">;</span></span>
<span id="cb32-27"><a href="#cb32-27" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-28"><a href="#cb32-28" aria-hidden="true" tabindex="-1"></a>   <span class="kw">assign</span> _v9_1 <span class="op">=</span> rst<span class="op">;</span></span>
<span id="cb32-29"><a href="#cb32-29" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-30"><a href="#cb32-30" aria-hidden="true" tabindex="-1"></a>   <span class="kw">assign</span> _v10_2 <span class="op">=</span> addr<span class="op">;</span></span>
<span id="cb32-31"><a href="#cb32-31" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-32"><a href="#cb32-32" aria-hidden="true" tabindex="-1"></a>   <span class="kw">assign</span> _v11_3 <span class="op">=</span> ce0<span class="op">;</span></span>
<span id="cb32-33"><a href="#cb32-33" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-34"><a href="#cb32-34" aria-hidden="true" tabindex="-1"></a>   <span class="kw">assign</span> _v12_4 <span class="op">=</span> data_in<span class="op">;</span></span>
<span id="cb32-35"><a href="#cb32-35" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-36"><a href="#cb32-36" aria-hidden="true" tabindex="-1"></a>   <span class="kw">assign</span> _v13_5 <span class="op">=</span> clk<span class="op">;</span></span>
<span id="cb32-37"><a href="#cb32-37" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-38"><a href="#cb32-38" aria-hidden="true" tabindex="-1"></a>   <span class="kw">assign</span> _v14_6 <span class="op">=</span> rst<span class="op">;</span></span>
<span id="cb32-39"><a href="#cb32-39" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-40"><a href="#cb32-40" aria-hidden="true" tabindex="-1"></a>   <span class="kw">assign</span> _v15_7 <span class="op">=</span> addr<span class="op">;</span></span>
<span id="cb32-41"><a href="#cb32-41" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-42"><a href="#cb32-42" aria-hidden="true" tabindex="-1"></a>   <span class="kw">assign</span> _v16_8 <span class="op">=</span> ce1<span class="op">;</span></span>
<span id="cb32-43"><a href="#cb32-43" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-44"><a href="#cb32-44" aria-hidden="true" tabindex="-1"></a>   <span class="kw">assign</span> _v17_9 <span class="op">=</span> data_in<span class="op">;</span></span>
<span id="cb32-45"><a href="#cb32-45" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-46"><a href="#cb32-46" aria-hidden="true" tabindex="-1"></a>   <span class="kw">assign</span> data_out <span class="op">=</span> <span class="op">(</span>_v18_10 <span class="op">+</span> _v19_11<span class="op">);</span></span>
<span id="cb32-47"><a href="#cb32-47" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-48"><a href="#cb32-48" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-49"><a href="#cb32-49" aria-hidden="true" tabindex="-1"></a><span class="kw">endmodule</span></span></code></pre></div>
<p>The code is starting to get complicated and seems to be much
different from the HDLRuby description than before. This is because this
time, real syntactic limitations of Verilog HDL compared to HDLRuby have
to be bypassed. Here, the limitation is that while in HDLRuby, ports can
be connected wherever we want, in Verilog HDL, this must be done only
while instantiating.</p>
<p>In fact, in HDLRuby too you can do the connection while
instantiating, this is even recommended for better readability of the
code. There are two ways to do so: by position (like for the arguments
of a function call) or by name. Let us see both by editing again
<code>another_circuit.rb</code>: please just replace both instantiation
lines with the following:</p>
<div class="sourceCode" id="cb33"><pre
class="sourceCode ruby"><code class="sourceCode ruby"><span id="cb33-1"><a href="#cb33-1" aria-hidden="true" tabindex="-1"></a>my_circuit(<span class="wa">:my_circuit0</span>)<span class="kw">.</span>(clk,rst,addr,ce0,data_in,data_out)</span>
<span id="cb33-2"><a href="#cb33-2" aria-hidden="true" tabindex="-1"></a>my_circuit(<span class="wa">:my_circuit1</span>)<span class="kw">.</span>(<span class="wa">clk: </span>clk, <span class="wa">rst: </span>rst, <span class="wa">addr: </span>addr, <span class="wa">ce: </span>ce1,</span>
<span id="cb33-3"><a href="#cb33-3" aria-hidden="true" tabindex="-1"></a>                          <span class="wa">data_in: </span>data_in, <span class="wa">data_out: </span>data_out)</span></code></pre></div>
<p>The instantiation for <code>my_circuit0</code> does the connection by
position, that is to say, that each port given between the second
parenthesis is connected in the order of declaration of in ports of
<code>my_circuit.rb</code>. For <code>my_circuit1P</code> the connection
is done by name: then syntax
<code>&lt;name&gt;: &lt;something&gt;</code> connects ports named
<code>name</code> of the instance of <code>my_circuit</code> to
<code>something</code>. For example <code>clk: clk</code> connects port
<code>clk</code> of <code>my_circuit0</code> to port <code>clk</code> of
<code>another_circuit</code>.</p>
<h4 id="thats-all-for-this-section">That’s all for this section!</h4>
<hr />
<p>Now you know:</p>
<ul>
<li><p>How to declare a new circuit with its name and ports in
HDLRuby.</p></li>
<li><p>How to check it with hdrcc.</p></li>
<li><p>How to convert it to Verilog HDL.</p></li>
<li><p>How to reuse it into another circuit.</p></li>
<li><p>And even, how to describe the computation of some expressions and
connect them to an output port.</p></li>
</ul>
<p>But you still do not know: how to describe more complex computations,
e.g., controls, and how to simulate a circuit. Let us start slowly (from
the software person’s point of view) with how to describe an algorithm
the simple way in HDLRuby.</p>
<h2 id="how-to-describe-an-algorithm-to-be-implemented-by-a-circuit">3.
How to describe an algorithm to be implemented by a circuit</h2>
<p>In this section we will see:</p>
<ul>
<li><p><a href="#31-how-to-handle-values-in-a-circuit">How to handle
values in a circuit.</a></p></li>
<li><p><a
href="#32-how-to-describe-an-algorithm-that-a-circuit-can-implement">How
to describe an algorithm that a circuit can implement.</a></p></li>
</ul>
<h3 id="how-to-handle-values-in-a-circuit">3.1. How to handle values in
a circuit</h3>
<p>In software, handling values looks straightforward enough: they are
computed with expressions and stored in variables. In hardware it is
slightly different since two kinds of components handle values: the
wires and the storage components:</p>
<ul>
<li><p>The wires are abstractions of physical wires or sets of wires
that transmit data to the hardware component they are connected to. A
wire cannot hold a value: if a component drives a value to a wire, this
wire takes this value, and it will last as soon as this drive
stops.</p></li>
<li><p>The storage components are abstractions of registers or memories
that can hold values. Depending on how they are described, the value
they hold can be changed on specific events like the rising edge of a
clock. Hence, the storage components are closer to the software variable
than the wires are.</p></li>
</ul>
<p>With HDL like Verilog HDL, there is a real distinction between wires
and storage components. However, with other HDL like VHDL, or here with
HDLRuby, both are abstracted by a single concept: the signal.
Specifically, when a signal is only driven on a given event, it becomes
a storage element, otherwise, it will remain a wire.</p>
<p><strong>Note</strong>: one may ask what about the
<code>variable</code> construct in VHDL: those are syntactic
intermediates used for simplifying the descriptions. HDLRuby also
supports such a <code>variable</code> construct, but those are simply
the variables of the Ruby language. Therefore, these variables can hold
not only values but any Ruby or HDLRuby constructs.</p>
<p>In HDLRuby, there are four kinds of signals: the input ports, the
output ports, the inout ports, and the inner signals. The first three
kinds of signals have already been described in the section about
declaring a <a href="#circuit-declare">circuit</a>. At that time they
were called ports because it is what such constructs are called in
common HDL. However, in HDLRuby there is no distinction at all between
ports and signals, hence from now on, we will use the term
<code>signal</code> in general, and the term <code>port</code> when we
only want to refer to the interface of a circuit. The inner signals can
be used inside a circuit and are usually used as an intermediate for
internal computations. They are declared like the ports, but using
<code>inner</code> instead of <code>input</code>, <code>output</code>,
or <code>inout</code>. For example, the following code declares a module
named <code>a_circuit</code> with two 1-bit inputs, one 8-bit output,
and one 4-bit inner signal.</p>
<div class="sourceCode" id="cb34"><pre
class="sourceCode ruby"><code class="sourceCode ruby"><span id="cb34-1"><a href="#cb34-1" aria-hidden="true" tabindex="-1"></a><span class="fu">system</span>(<span class="wa">:a_circuit</span>) <span class="cf">do</span></span>
<span id="cb34-2"><a href="#cb34-2" aria-hidden="true" tabindex="-1"></a>   input <span class="wa">:u</span>, <span class="wa">:v</span></span>
<span id="cb34-3"><a href="#cb34-3" aria-hidden="true" tabindex="-1"></a>   <span class="kw">[</span><span class="dv">8</span><span class="kw">]</span><span class="at">.output</span> <span class="wa">:z</span></span>
<span id="cb34-4"><a href="#cb34-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb34-5"><a href="#cb34-5" aria-hidden="true" tabindex="-1"></a>   <span class="kw">[</span><span class="dv">4</span><span class="kw">]</span><span class="at">.inner</span> <span class="wa">:sig</span></span>
<span id="cb34-6"><a href="#cb34-6" aria-hidden="true" tabindex="-1"></a><span class="cf">end</span></span></code></pre></div>
<p><strong>Note</strong>: the inner signals as well as the ports can be
declared anywhere within the body of a module. It is however recommended
to declare the ports at the beginning, and the inner signal when
relevant, e.g., it may not be a good idea to declare an inner signal at
the beginning of a circuit description if it is only used at the
end.</p>
<h4 id="what-about-the-data-types">What about the data types?</h4>
<p>For now, we only used positive integer values, e.g.,
<code>[8].inner</code> declares an 8-bit positive integer. To tell the
truth, <code>[8]</code> is not the designation of the 8-bit positive
integer data type, but a syntactic sugar that stands for:
<code>bit[8]</code>. As a general rule, in HDLRuby, the designation of a
data type is as follows:</p>
<div class="sourceCode" id="cb35"><pre
class="sourceCode ruby"><code class="sourceCode ruby"><span id="cb35-1"><a href="#cb35-1" aria-hidden="true" tabindex="-1"></a><span class="kw">&lt;</span>base<span class="kw">&gt;[&lt;</span>range<span class="kw">&gt;]</span></span></code></pre></div>
<p>Where <code>base</code> is another data type and <code>range</code>
describes the range of indexes used for accessing its elements
individually. In addition, there are three root data types used for
building all the other ones:</p>
<ul>
<li><p><code>bit</code>: for boolean or 1-bit unsigned values, i.e., the
only possible values are 0 and 1.</p></li>
<li><p><code>signed</code>: for 1-bit signed values in 2’s complement,
i.e., the only possible values are 0 and -1.</p></li>
<li><p><code>float</code>: for 1-bit floating point values, but,
<strong>WARNING</strong>: this data type is not supported yet!</p></li>
</ul>
<p>For example, a 32-bit input signed integer signal and an inner array
of eight 24-bit integers are declared respectively as follows:</p>
<div class="sourceCode" id="cb36"><pre
class="sourceCode ruby"><code class="sourceCode ruby"><span id="cb36-1"><a href="#cb36-1" aria-hidden="true" tabindex="-1"></a>signed<span class="kw">[</span><span class="dv">32</span><span class="kw">]</span><span class="at">.input</span> <span class="wa">:sig</span></span>
<span id="cb36-2"><a href="#cb36-2" aria-hidden="true" tabindex="-1"></a>bit<span class="kw">[</span><span class="dv">24</span><span class="kw">][</span><span class="dv">8</span><span class="kw">]</span><span class="at">.inner</span> <span class="wa">:ar</span></span></code></pre></div>
<blockquote>
<p>Unfortunately, the following is not valid:<br />
<code>[24][8].inner :ar</code><br />
This is because it conflicts with other constructs in the language.</p>
</blockquote>
<p>When the code above is declared, you can access one element of array
<code>ar</code> using the brackets like before, e.g., its first element
is <code>ar[0]</code>, its second one <code>ar[1]</code>, and so on. But
you can also access its last element as follows: <code>ar[-1]</code>,
its element before the last one as follows <code>ar[-2]</code>, and so
on. Moreover, since an integer is just an array of bits, it is possible
to access its bits individually in the same way. For example, accessing
the first bit of the last element of ar can be done as follows:
<code>ar[-1][0]</code>.</p>
<p>But compared to the software you can do even more than that: you can
also access to sub-range of elements of a signal. For example, assigning
bits from index 4 to 27 of signal <code>sig</code> to element 1 of array
<code>ar</code> can be written as follows using <em>range</em>:</p>
<div class="sourceCode" id="cb37"><pre
class="sourceCode ruby"><code class="sourceCode ruby"><span id="cb37-1"><a href="#cb37-1" aria-hidden="true" tabindex="-1"></a>ar<span class="kw">[</span><span class="dv">1</span><span class="kw">]</span> <span class="kw">&lt;=</span> sig<span class="kw">[</span><span class="dv">27</span><span class="kw">..</span><span class="dv">4</span><span class="kw">]</span></span></code></pre></div>
<p>A range is noted as follows:
<code>&lt;start value&gt;..&lt;end value&gt;</code>, and indicates
respectively the value of the first and the last indexes. Convenient, is
not it? But wait… Why <code>27..4</code> and not <code>4..27</code>?</p>
<h4 id="let-us-talk-about-endianness.">Let us talk about
endianness.</h4>
<p>If you are familiar with hardware or with low-level software, you may
be aware of this topic. There are two possible ways for reading a value
or the content of an array: from the most significant bit or index to
the least significant one (big-endian) and the opposite (little-endian).
Since big-endian is more natural for reading numbers it is the default
mode in HDL, including HDLRuby. However, for an array, software
programming usually does the opposite. In HDLRuby, using little-endian
instead of big-endian is declared by using a negative number for the
size instead of a positive one.</p>
<p>As a general rule, code will be much easier to understand if integer
values are big-endian and the array accesses little-endian. That is to
say that the following declaration is the best for <code>ar</code>:</p>
<div class="sourceCode" id="cb38"><pre
class="sourceCode ruby"><code class="sourceCode ruby"><span id="cb38-1"><a href="#cb38-1" aria-hidden="true" tabindex="-1"></a>bit<span class="kw">[</span><span class="dv">24</span><span class="kw">][-</span><span class="dv">8</span><span class="kw">]</span><span class="at">.inner</span> <span class="wa">:ar</span></span></code></pre></div>
<blockquote>
<p>One last thing: it is also possible to set the numbering of each bit
of a signal using again a <em>range</em> instead of an integer
indicating the size. For example, with the following declaration,
<code>a</code> is an 8-bit big-endian integer with its bits numbered
from 0 to 7, and <code>b</code> is a 9-bit little-endian integer with
its bits numbered from 1 to 9:<br />
<code>[7..0].inner :a</code><br />
<code>[1..9].inner :b</code></p>
</blockquote>
<p>So now you know about basic types in HDLRuby, but what happens when
we make operations between signals of different types?</p>
<h4 id="about-casting-and-auto-casting">About casting and
auto-casting</h4>
<p>First, you can convert the type of a signal using the cast operator
<code>as</code>. For example, in the following code, the result of a
16-bit unsigned addition is performed between the 8-bit signal
<code>x</code> converted to 16-bit and the 16-bit signal
<code>y</code>:</p>
<div class="sourceCode" id="cb39"><pre
class="sourceCode ruby"><code class="sourceCode ruby"><span id="cb39-1"><a href="#cb39-1" aria-hidden="true" tabindex="-1"></a><span class="kw">[</span><span class="dv">8</span><span class="kw">]</span><span class="at">.inner</span> <span class="wa">:x</span></span>
<span id="cb39-2"><a href="#cb39-2" aria-hidden="true" tabindex="-1"></a><span class="kw">[</span><span class="dv">16</span><span class="kw">]</span><span class="at">.inner</span> <span class="wa">:y</span>, <span class="wa">:z</span></span>
<span id="cb39-3"><a href="#cb39-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb39-4"><a href="#cb39-4" aria-hidden="true" tabindex="-1"></a><span class="kw">&lt;</span>some code<span class="kw">&gt;</span></span>
<span id="cb39-5"><a href="#cb39-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb39-6"><a href="#cb39-6" aria-hidden="true" tabindex="-1"></a>z <span class="kw">&lt;=</span> x<span class="at">.as</span>(bit<span class="kw">[</span><span class="dv">16</span><span class="kw">]</span>) <span class="kw">+</span> y</span></code></pre></div>
<p>However, if you do not use the cast operator, HDLRuby will do it
automatically for you and cast the operands to the largest of their
types. That is to say that for the following code the result is
identical to the previous one:</p>
<div class="sourceCode" id="cb40"><pre
class="sourceCode ruby"><code class="sourceCode ruby"><span id="cb40-1"><a href="#cb40-1" aria-hidden="true" tabindex="-1"></a><span class="kw">[</span><span class="dv">8</span><span class="kw">]</span><span class="at">.inner</span> <span class="wa">:x</span></span>
<span id="cb40-2"><a href="#cb40-2" aria-hidden="true" tabindex="-1"></a><span class="kw">[</span><span class="dv">16</span><span class="kw">]</span><span class="at">.inner</span> <span class="wa">:y</span>, <span class="wa">:z</span></span>
<span id="cb40-3"><a href="#cb40-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb40-4"><a href="#cb40-4" aria-hidden="true" tabindex="-1"></a><span class="kw">&lt;</span>some code<span class="kw">&gt;</span></span>
<span id="cb40-5"><a href="#cb40-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb40-6"><a href="#cb40-6" aria-hidden="true" tabindex="-1"></a>z <span class="kw">&lt;=</span> x <span class="kw">+</span> y</span></code></pre></div>
<p>This rule means that for the following code, <code>z</code> will have
the result of an 8-bit addition since both operands <code>x</code> and
<code>y</code> are 8-bit:</p>
<div class="sourceCode" id="cb41"><pre
class="sourceCode ruby"><code class="sourceCode ruby"><span id="cb41-1"><a href="#cb41-1" aria-hidden="true" tabindex="-1"></a><span class="kw">[</span><span class="dv">8</span><span class="kw">]</span><span class="at">.inner</span> <span class="wa">:x</span>, <span class="wa">:y</span></span>
<span id="cb41-2"><a href="#cb41-2" aria-hidden="true" tabindex="-1"></a><span class="kw">[</span><span class="dv">16</span><span class="kw">]</span><span class="at">.inner</span> <span class="wa">:z</span></span>
<span id="cb41-3"><a href="#cb41-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb41-4"><a href="#cb41-4" aria-hidden="true" tabindex="-1"></a><span class="kw">&lt;</span>some code<span class="kw">&gt;</span></span>
<span id="cb41-5"><a href="#cb41-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb41-6"><a href="#cb41-6" aria-hidden="true" tabindex="-1"></a>z <span class="kw">&lt;=</span> x <span class="kw">+</span> y</span></code></pre></div>
<p>If you want a 16-bit addition, you must add a cast to at least one of
the operands, e.g.:</p>
<div class="sourceCode" id="cb42"><pre
class="sourceCode ruby"><code class="sourceCode ruby"><span id="cb42-1"><a href="#cb42-1" aria-hidden="true" tabindex="-1"></a><span class="kw">[</span><span class="dv">8</span><span class="kw">]</span><span class="at">.inner</span> <span class="wa">:x</span>, <span class="wa">:y</span></span>
<span id="cb42-2"><a href="#cb42-2" aria-hidden="true" tabindex="-1"></a><span class="kw">[</span><span class="dv">16</span><span class="kw">]</span><span class="at">.inner</span> <span class="wa">:z</span></span>
<span id="cb42-3"><a href="#cb42-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-4"><a href="#cb42-4" aria-hidden="true" tabindex="-1"></a><span class="kw">&lt;</span>some code<span class="kw">&gt;</span></span>
<span id="cb42-5"><a href="#cb42-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-6"><a href="#cb42-6" aria-hidden="true" tabindex="-1"></a>z <span class="kw">&lt;=</span> x<span class="at">.as</span>(bit<span class="kw">[</span><span class="dv">16</span><span class="kw">]</span>) <span class="kw">+</span> y</span></code></pre></div>
<hr />
<p>These explanations about data types may have been not so fun, be we
should better get over with them first so that now we can start the real
fun with actual “programming”…</p>
<p><strong>Note</strong>: “Programming” is put between quotes because
this is not programming since there is no program, but instead, a
description of a physical circuit.</p>
<h3 id="how-to-describe-an-algorithm-that-a-circuit-can-implement">3.2.
How to describe an algorithm that a circuit can implement</h3>
<p>So now you know how to declare a circuit, use it, connect it, and
declare variable-like constructs that are called signals. We will see
later that signals are definitive <strong>not</strong> software
variables, but let us go on with the illusion for a little while and see
how you can describe an algorithm in HDLRuby. As a side note, the
features described in this section are unique to HDLRuby so do not
expect to be able to do the same with Verilog HDL or VHDL.</p>
<p>With software languages, when you want to describe an algorithm you
use assignments but also control statements like <code>if</code>,
<code>for</code>, or <code>while</code>. If you know higher-level
languages like <code>Java</code> or <code>Ruby</code> you may also use
design patterns like <code>iterators</code> (or
<code>enumerators</code>). You can do the same in HDLRuby with
constructs called <em>sequencers</em>. At first glance, a sequencer can
be seen as the description of a hardware component implementing a
software algorithm. Hence, a sequencer may look like a processor, but
there are differences:</p>
<ul>
<li><p>It is not possible to change the algorithm implemented by a
sequencer (you cannot “load” a new program).</p></li>
<li><p>A sequencer starts execution according to a given start signal,
and from there advances execution at each cycle of a given
clock.</p></li>
<li><p>You have control of the algorithm at the clock cycle level, and
incidentally, a sequencer is much more efficient than a processor
executing a program.</p></li>
</ul>
<p>This section will explain the following about sequencers:</p>
<ul>
<li><p><a href="#321-how-to-declare-and-control-a-sequencer">How to
declare and control a sequencer.</a></p></li>
<li><p><a
href="#322-how-to-write-a-structured-programming-algorithm-in-a-sequencer">How
to write a structured programming algorithm in a sequencer.</a></p></li>
<li><p><a href="#323-how-to-write-and-use-a-sequencer-function">How to
write and use a sequencer function.</a></p></li>
<li><p><a href="#324-how-to-use-enumerators-in-a-sequencer">How to use
enumerators in a sequencer.</a></p></li>
<li><p><a
href="#325-what-happens-when-there-are-several-sequencers">What happens
when there are several sequencers?</a></p></li>
</ul>
<h4 id="how-to-declare-and-control-a-sequencer">3.2.1 How to declare and
control a sequencer</h4>
<p>As said in the previous section, a sequencer advances execution
according to a clock and starts execution according to a start signal. A
clock is a single-bit signal that alternates from 0 to 1, and it is the
transition from 0 to 1, or from 1 to 0 of this signal that will make a
sequencer progress execution. Let us see two examples of sequencers to
understand better:</p>
<div class="sourceCode" id="cb43"><pre
class="sourceCode ruby"><code class="sourceCode ruby"><span id="cb43-1"><a href="#cb43-1" aria-hidden="true" tabindex="-1"></a><span class="fu">system</span> <span class="wa">:the_counter</span> <span class="cf">do</span></span>
<span id="cb43-2"><a href="#cb43-2" aria-hidden="true" tabindex="-1"></a>   inner <span class="wa">:clk</span>, <span class="wa">:start</span></span>
<span id="cb43-3"><a href="#cb43-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb43-4"><a href="#cb43-4" aria-hidden="true" tabindex="-1"></a>   sequencer(clk,start) <span class="cf">do</span></span>
<span id="cb43-5"><a href="#cb43-5" aria-hidden="true" tabindex="-1"></a>   <span class="cf">end</span></span>
<span id="cb43-6"><a href="#cb43-6" aria-hidden="true" tabindex="-1"></a><span class="cf">end</span></span></code></pre></div>
<p>In the code above, a module containing one sequencer is described.
The sequencer is controlled by the start signal <code>start</code> and
clock signal <code>clk</code>, which means that:</p>
<ul>
<li><p>it will advance execution every time <code>clk</code> switches
from 0 to 1 - we call such an event a <em>positive edge</em> of
<code>clk</code>;</p></li>
<li><p>it will start when signal <code>start</code> switches from 1 to 0
- we call such an event a <em>negative edge</em> of
<code>start</code>.</p></li>
</ul>
<p>Why a positive edge for <code>clk</code> and a negative one for
<code>start</code>? It does not matter much, and you can specify the
edges you want using the <code>posedge</code> and <code>negedge</code>
methods. For example, the following sequencer advances execution on a
negative edge of <code>clk</code> and starts on a positive edge of
<code>start</code>:</p>
<div class="sourceCode" id="cb44"><pre
class="sourceCode ruby"><code class="sourceCode ruby"><span id="cb44-1"><a href="#cb44-1" aria-hidden="true" tabindex="-1"></a>sequencer(clk<span class="at">.negedge</span>,start<span class="at">.posedge</span>) <span class="kw">{</span> <span class="kw">}</span></span></code></pre></div>
<p><strong>Note</strong>: the curly brackets used here are equivalent to
the <code>do</code> and <code>end</code> keywords we used until now.</p>
<blockquote>
<p><strong>WARNING</strong>: there is a caveat though, since a sequencer
advances execution according to a clock signal, it will not be able to
start properly unless the start signal is strictly slower than the
clock.</p>
</blockquote>
<p>But now, what will this sequencer do? … Nothing right now since its
body is empty. So let us start small and make it count the number of a
few clock cycles:</p>
<div class="sourceCode" id="cb45"><pre
class="sourceCode ruby"><code class="sourceCode ruby"><span id="cb45-1"><a href="#cb45-1" aria-hidden="true" tabindex="-1"></a><span class="fu">system</span> <span class="wa">:the_counter</span> <span class="cf">do</span></span>
<span id="cb45-2"><a href="#cb45-2" aria-hidden="true" tabindex="-1"></a>   inner <span class="wa">:clk</span>, <span class="wa">:start</span></span>
<span id="cb45-3"><a href="#cb45-3" aria-hidden="true" tabindex="-1"></a>   <span class="kw">[</span><span class="dv">8</span><span class="kw">]</span><span class="at">.inner</span> <span class="wa">:count</span></span>
<span id="cb45-4"><a href="#cb45-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-5"><a href="#cb45-5" aria-hidden="true" tabindex="-1"></a>   sequencer(clk,start) <span class="cf">do</span></span>
<span id="cb45-6"><a href="#cb45-6" aria-hidden="true" tabindex="-1"></a>      count <span class="kw">&lt;=</span> <span class="dv">0</span></span>
<span id="cb45-7"><a href="#cb45-7" aria-hidden="true" tabindex="-1"></a>      step</span>
<span id="cb45-8"><a href="#cb45-8" aria-hidden="true" tabindex="-1"></a>      count <span class="kw">&lt;=</span> count <span class="kw">+</span> <span class="dv">1</span></span>
<span id="cb45-9"><a href="#cb45-9" aria-hidden="true" tabindex="-1"></a>      step</span>
<span id="cb45-10"><a href="#cb45-10" aria-hidden="true" tabindex="-1"></a>      count <span class="kw">&lt;=</span> count <span class="kw">+</span> <span class="dv">1</span></span>
<span id="cb45-11"><a href="#cb45-11" aria-hidden="true" tabindex="-1"></a>      step</span>
<span id="cb45-12"><a href="#cb45-12" aria-hidden="true" tabindex="-1"></a>      count <span class="kw">&lt;=</span> count <span class="kw">+</span> <span class="dv">1</span></span>
<span id="cb45-13"><a href="#cb45-13" aria-hidden="true" tabindex="-1"></a>   <span class="cf">end</span></span>
<span id="cb45-14"><a href="#cb45-14" aria-hidden="true" tabindex="-1"></a><span class="cf">end</span></span></code></pre></div>
<p>The first line of the body of the counter looks like the connection
of ports we described <a href="#circuit-use">previously</a>. However, it
is inside the body of a sequencer and will therefore be
<em>executed</em> by it, that is to say, before this statement is
executed, <code>count</code> may not be 0. More generally:</p>
<ul>
<li><p>Every assignment statement outside sequencers (and later
processes) is a connection: the signal will <em>always</em> and
<em>continuously</em> have the value that is assigned to it.</p></li>
<li><p>The other assignment statements, e.g., the ones inside a
sequencer, are called <em>transmission</em> in HDLRuby and happen only
when “executed.”</p></li>
</ul>
<p>In our example, the count is set to 0 when the sequencer starts
execution. But before that, no one knows the value of count: it is said
to be <em>undefined</em>.</p>
<p>Just after this initial line, there is the <code>step</code> keyword.
There we go from the software world to the hardware one: this keyword
indicates that the sequencer ends execution here until the next clock
cycle. Looking at the subsequent line you may understand why we waited:
this line increases the value of <code>count</code> by one, i.e., the
sequencer counted one clock cycle. Again, a <code>step</code> is
inserted, and <code>count</code> is increased, and so on, so that this
is indeed the code of a sequencer that counts the clock cycles. However
the code ends after 3 clock cycles, and like with software, when the
code of a sequencer is over, it stops execution.</p>
<p>This may look abstract, so let us try to simulate this circuit. For
that purpose, write the code into a file named
<code>the_counter.rb</code> (for example) and try the following command
that will simulate the circuit:</p>
<div class="sourceCode" id="cb46"><pre
class="sourceCode bash"><code class="sourceCode bash"><span id="cb46-1"><a href="#cb46-1" aria-hidden="true" tabindex="-1"></a><span class="ex">hdrcc</span> <span class="at">--sim</span> the_counter.rb the_counter</span></code></pre></div>
<p>If everything was all right the following text will appear:</p>
<pre><code>__:T:0:::2: 000</code></pre>
<p>It indicates that a signal named <code>__: T:0:::2</code> has been
initialized to 0 (000), and that’s all… Why is that, and why only that?
First, this signal with a strange name has been generated by HDLRuby for
the internal processing of the sequencer and is required to be
initialized to 0. So, ok, the simulation did some initialization, but it
did not seem to do any execution. This is because we did not give any
description of the physical environment of the circuit, and especially,
we did not say that the clock and the start signal need to change value.
For describing the behavior of the environment of a circuit, we use a
construct called, in HDLRuby, the <em>timed process</em>. They are
somewhat close to sequencers but are not controlled by a clock signal
but by physical time. So let us add the following code just after the
sequencer (but still inside the module <code>the_counter</code>:</p>
<div class="sourceCode" id="cb48"><pre
class="sourceCode ruby"><code class="sourceCode ruby"><span id="cb48-1"><a href="#cb48-1" aria-hidden="true" tabindex="-1"></a>   timed <span class="cf">do</span></span>
<span id="cb48-2"><a href="#cb48-2" aria-hidden="true" tabindex="-1"></a>      clk <span class="kw">&lt;=</span> <span class="dv">0</span></span>
<span id="cb48-3"><a href="#cb48-3" aria-hidden="true" tabindex="-1"></a>      start <span class="kw">&lt;=</span> <span class="dv">0</span></span>
<span id="cb48-4"><a href="#cb48-4" aria-hidden="true" tabindex="-1"></a>      !<span class="dv">10</span><span class="at">.ns</span></span>
<span id="cb48-5"><a href="#cb48-5" aria-hidden="true" tabindex="-1"></a>      clk <span class="kw">&lt;=</span> <span class="dv">1</span></span>
<span id="cb48-6"><a href="#cb48-6" aria-hidden="true" tabindex="-1"></a>      !<span class="dv">10</span><span class="at">.ns</span></span>
<span id="cb48-7"><a href="#cb48-7" aria-hidden="true" tabindex="-1"></a>      clk <span class="kw">&lt;=</span> <span class="dv">0</span></span>
<span id="cb48-8"><a href="#cb48-8" aria-hidden="true" tabindex="-1"></a>      start <span class="kw">&lt;=</span> <span class="dv">1</span></span>
<span id="cb48-9"><a href="#cb48-9" aria-hidden="true" tabindex="-1"></a>      !<span class="dv">10</span><span class="at">.ns</span></span>
<span id="cb48-10"><a href="#cb48-10" aria-hidden="true" tabindex="-1"></a>      clk <span class="kw">&lt;=</span> <span class="dv">1</span></span>
<span id="cb48-11"><a href="#cb48-11" aria-hidden="true" tabindex="-1"></a>      !<span class="dv">10</span><span class="at">.ns</span></span>
<span id="cb48-12"><a href="#cb48-12" aria-hidden="true" tabindex="-1"></a>      clk <span class="kw">&lt;=</span> <span class="dv">0</span></span>
<span id="cb48-13"><a href="#cb48-13" aria-hidden="true" tabindex="-1"></a>      start <span class="kw">&lt;=</span> <span class="dv">0</span></span>
<span id="cb48-14"><a href="#cb48-14" aria-hidden="true" tabindex="-1"></a>      !<span class="dv">10</span><span class="at">.ns</span></span>
<span id="cb48-15"><a href="#cb48-15" aria-hidden="true" tabindex="-1"></a>      clk <span class="kw">&lt;=</span> <span class="dv">1</span></span>
<span id="cb48-16"><a href="#cb48-16" aria-hidden="true" tabindex="-1"></a>      !<span class="dv">10</span><span class="at">.ns</span></span>
<span id="cb48-17"><a href="#cb48-17" aria-hidden="true" tabindex="-1"></a>      clk <span class="kw">&lt;=</span> <span class="dv">0</span></span>
<span id="cb48-18"><a href="#cb48-18" aria-hidden="true" tabindex="-1"></a>      !<span class="dv">10</span><span class="at">.ns</span></span>
<span id="cb48-19"><a href="#cb48-19" aria-hidden="true" tabindex="-1"></a>      clk <span class="kw">&lt;=</span> <span class="dv">1</span></span>
<span id="cb48-20"><a href="#cb48-20" aria-hidden="true" tabindex="-1"></a>      !<span class="dv">10</span><span class="at">.ns</span></span>
<span id="cb48-21"><a href="#cb48-21" aria-hidden="true" tabindex="-1"></a>      clk <span class="kw">&lt;=</span> <span class="dv">0</span></span>
<span id="cb48-22"><a href="#cb48-22" aria-hidden="true" tabindex="-1"></a>      !<span class="dv">10</span><span class="at">.ns</span></span>
<span id="cb48-23"><a href="#cb48-23" aria-hidden="true" tabindex="-1"></a>      clk <span class="kw">&lt;=</span> <span class="dv">1</span></span>
<span id="cb48-24"><a href="#cb48-24" aria-hidden="true" tabindex="-1"></a>      !<span class="dv">10</span><span class="at">.ns</span></span>
<span id="cb48-25"><a href="#cb48-25" aria-hidden="true" tabindex="-1"></a>      clk <span class="kw">&lt;=</span> <span class="dv">0</span></span>
<span id="cb48-26"><a href="#cb48-26" aria-hidden="true" tabindex="-1"></a>      !<span class="dv">10</span><span class="at">.ns</span></span>
<span id="cb48-27"><a href="#cb48-27" aria-hidden="true" tabindex="-1"></a>      clk <span class="kw">&lt;=</span> <span class="dv">1</span></span>
<span id="cb48-28"><a href="#cb48-28" aria-hidden="true" tabindex="-1"></a>      !<span class="dv">10</span><span class="at">.ns</span></span>
<span id="cb48-29"><a href="#cb48-29" aria-hidden="true" tabindex="-1"></a>      clk <span class="kw">&lt;=</span> <span class="dv">0</span></span>
<span id="cb48-30"><a href="#cb48-30" aria-hidden="true" tabindex="-1"></a>      !<span class="dv">10</span><span class="at">.ns</span></span>
<span id="cb48-31"><a href="#cb48-31" aria-hidden="true" tabindex="-1"></a>      clk <span class="kw">&lt;=</span> <span class="dv">1</span></span>
<span id="cb48-32"><a href="#cb48-32" aria-hidden="true" tabindex="-1"></a>      !<span class="dv">10</span><span class="at">.ns</span></span>
<span id="cb48-33"><a href="#cb48-33" aria-hidden="true" tabindex="-1"></a>   <span class="cf">end</span></span></code></pre></div>
<p>Sorry, this code is a little bit long… Did you add it to the file
<code>the_counter.rb</code>? now please try again the simulation
command:</p>
<div class="sourceCode" id="cb49"><pre
class="sourceCode bash"><code class="sourceCode bash"><span id="cb49-1"><a href="#cb49-1" aria-hidden="true" tabindex="-1"></a><span class="ex">hdrcc</span> <span class="at">--sim</span> the_counter.rb the_counter</span></code></pre></div>
<p>You should have the following result:</p>
<pre><code>__:T:0:::2: 000
__:T:0::clk: 0
__:T:0::start: 0
# 10000ps
__:T:0::clk: 1
__:T:0:::1: 000
# 20000ps
__:T:0::clk: 0
__:T:0::start: 1
# 30000ps
__:T:0::clk: 1
__:T:0:::2: 001
# 40000ps
__:T:0::start: 0
__:T:0::clk: 0
# 50000ps
__:T:0::clk: 1
__:T:0:::1: 001
__:T:0::count: 00000000
__:T:0:::2: 010
# 60000ps
__:T:0::clk: 0
# 70000ps
__:T:0::clk: 1
__:T:0:::1: 010
__:T:0::count: 00000001
__:T:0:::2: 011
# 80000ps
__:T:0::clk: 0
# 90000ps
__:T:0::clk: 1
__:T:0:::1: 011
__:T:0::count: 00000010
__:T:0:::2: 100
# 100000ps
__:T:0::clk: 0
# 110000ps
__:T:0::clk: 1
__:T:0:::1: 100
__:T:0::count: 00000011
__:T:0:::2: 101
# 120000ps
__:T:0::clk: 0
# 130000ps
__:T:0::clk: 1
__:T:0:::1: 101
__:T:0:::2: 000
# 140000ps</code></pre>
<p>If you look at the last line of the simulation result you should have
<code># 140000ps</code>, which means that final the simulation time was
140000 picoseconds (140 nanoseconds). If you look at the result in
totality, you will see an alternation of signal names followed by a
value in binary (e.g., <code>__:T:0::clk: 1</code> means that the
<code>clk</code> signal is 1) and an indication of the time of the
simulation. The names look indeed messy, but please only focus on their
last parts: that will be the names of the signals you defined in your
HDLRuby file. You will also notice some signals that you did not declare
(e.g., <code>__:T:0:::1</code> and <code>__:T:0:::2</code>, but those
are only signals generated by HDLRuby.</p>
<p>Now, let us see what happened, and what was the meaning of the
<code>timed</code> construct we added. As explained before,
<code>timed</code> constructs are like sequencers, but controlled by
physical time instead of a clock signal. Inside, you can put assignments
but also statements that advance the time. For instance:
<code>!10.ns</code> is a statement that advances time by 10 nanoseconds
(i.e., 10000 picoseconds). Hence, with such a construct you can declare
that a signal will take a given value at a given time. For this example,
it is enough to tell how the <code>clk</code> and <code>start</code>
signal change over time to make the sequencer run by itself. Hence, the
<code>clk</code> signal is made to switch from 0 to 1 then from 1 to 0
every 10 nanoseconds, which simulates a 50 MHz clock, and the start
signal is set to 1 and then to 0 so that the sequencer starts execution.
The first thing it does is set <code>counter</code> to 0, and then the
following cycles this counter is increased until its execution
completes. Even when the sequencer completes execution, the simulation
goes on though, until the timed process also completes.</p>
<blockquote>
<p><strong>WARNING</strong>: in HDLRuby, everything is synthesizable,
i.e., it can be turned into a real circuit, <strong>apart</strong> from
the timed processes. These constructs are only there for simulating the
physical environment of a circuit.</p>
</blockquote>
<h4 id="ugh-the-simulation-result-is-ugly">Ugh! The simulation result is
ugly!</h4>
<p>Indeed, the text output of the simulator is hard to read, and
therefore we highly recommend generating a graphical one using the
following command:</p>
<div class="sourceCode" id="cb51"><pre
class="sourceCode bash"><code class="sourceCode bash"><span id="cb51-1"><a href="#cb51-1" aria-hidden="true" tabindex="-1"></a><span class="ex">hdrcc</span> <span class="at">--sim</span> <span class="at">--vcd</span> the_counter.rb the_counter</span></code></pre></div>
<p>The new option <code>--vcd</code> makes the simulator produce a
<em>Value Change Dump</em> file (VCD) that can be visualized graphically
by many HW design tools. If you do not have any such tool you can get <a
href="https://gtkwave.sourceforge.net/">GTKWave</a> which is under GNU
General Public License v2.0, or <a
href="https://github.com/civol/htmlwave">HTMLWave</a> by the author of
HDLRuby (link of interest!) and which is under the MIT License (also
available as web application at this <a
href="https://civol.github.io/htmlwave/htmlwave.html">link</a>.)</p>
<p>The resulting vcd file can be found in the <code>the_counter</code>
directory with the name <code>hruby_simulator.vcd</code>. If you open it
and select the <code>clk</code>, <code>start</code>, and
<code>counter</code> signals you will see something like the following
picture:</p>
<p align="center">
<img data-name="hruby_simulator.vcd" src="the_counter_vcd.png"  width="80%">
</p>
<p>Such a graph is called a time chart and displays the evolution of
signals with time on the X-axis. You can see that <code>clk</code> is
indeed alternating from 0 to 1, and that <code>start</code> is set to 1
for one clock cycle only. After this later signal becomes 0 again, the
sequencer starts. This can be verified by looking at the value of
<code>counter</code>: at first, it is undefined, that it is set to 0,
then increased by 1 at each clock cycle until it reaches 3.</p>
<hr />
<p>So now, you know:</p>
<ul>
<li><p>How to describe an algorithm in HDLRuby.</p></li>
<li><p>How to simulate it.</p></li>
<li><p>How to display a cool graph showing the simulation results
(maybe?)</p></li>
</ul>
<p>Hum, the algorithm part is quite limited, and the timed processes
seem to be real pains to write. So let us see how to do better in the
following section.</p>
<h4
id="how-to-write-a-structured-programming-algorithm-in-a-sequencer">3.2.2.
How to write a structured programming algorithm in a sequencer</h4>
<p>Now, when we speak about algorithms, we often think about software
constructs like <code>if</code> for conditional executions and
<code>for</code> for loops. Unfortunately, in HW design this is usually
not that simple at all… But for the HDLRuby sequencers, it is indeed
that simple: all these control statements are supported without any
limitation. The only thing you have to be careful about is their name:
to avoid confusion with the Ruby language, their names are all prefixed
with an <code>s</code> (for <em>sequencer</em>), e.g., you have to use
<code>sif</code> for doing an <em>if</em>.</p>
<p>In detail here is a list of the control statements you can use within
a sequencer:</p>
<ul>
<li><p><code>sif(&lt;condition&gt;) &lt;block&gt;</code>: executes
<code>block</code> if <code>condition</code> is true (i.e., different
from 0).</p></li>
<li><p><code>selsif(&lt;condition&gt;) &lt;block&gt;</code>: executes
<code>block</code> if the previous <code>sif</code> and
<code>selsif</code> conditions are false and if the current
<code>condition</code> is true.</p></li>
<li><p><code>selse &lt;block&gt;</code>: executes <code>block</code> if
the conditions of the previous <code>sif</code> and <code>selsif</code>
are false (i.e., equals 0). It is also used for giving the default block
for the <code>scase</code> statements (see below).</p></li>
<li><p><code>scase(&lt;choice&gt;)</code>: initializes a multiple case
statement.</p></li>
<li><p><code>swhen(&lt;value&gt;) &lt;block&gt;</code>: executes block
if <code>value</code> is equal to the <code>choice</code> of the
previous <code>scase</code> statement.</p></li>
<li><p><code>sloop &lt;block&gt;</code>: loops infinitely repeating the
execution of <code>block</code> (yes, like Ruby, if you want to do an
infinite loop, do it explicitly, not with constructs like
<code>while(true)</code>… even if you can).</p></li>
<li><p><code>swhile(&lt;condition&gt;) &lt;block&gt;</code>: repeats the
execution of <code>block</code> as long as <code>condition</code> is
true.</p></li>
<li><p><code>sfor(&lt;enumerable&gt;) &lt;block&gt;</code>: executes
<code>block</code> on each element of <code>enumerable</code>.</p></li>
<li><p><code>sbreak</code>: ends the current loop (even if it is a
<code>sloop</code>).</p></li>
<li><p><code>scontinue</code>: ends the current iteration.</p></li>
<li><p><code>steps(&lt;num&gt;)</code>: performs <code>num</code> times
<code>step</code> (<code>num</code> can be any expression). Useful for
waiting a certain number of cycles.</p></li>
</ul>
<blockquote>
<p><strong>IMPORTANT</strong>: each control statement requires one clock
cycle for each branch they perform, independently of what their block
contains. For example, in the following code, the value of
<code>y</code> will be set one cycle after <code>x</code> is set to 0,
and one cycle before <code>z</code> is set to 1.</p>
</blockquote>
<div class="sourceCode" id="cb52"><pre
class="sourceCode ruby"><code class="sourceCode ruby"><span id="cb52-1"><a href="#cb52-1" aria-hidden="true" tabindex="-1"></a>x <span class="kw">&lt;=</span> <span class="dv">0</span></span>
<span id="cb52-2"><a href="#cb52-2" aria-hidden="true" tabindex="-1"></a>sif(<span class="kw">~</span>x) <span class="kw">{</span> y <span class="kw">&lt;=</span> <span class="dv">2</span> <span class="kw">}</span></span>
<span id="cb52-3"><a href="#cb52-3" aria-hidden="true" tabindex="-1"></a>z <span class="kw">&lt;=</span> <span class="dv">1</span></span></code></pre></div>
<p>Let us see the details about these constructs with a few examples.
First, let us make a circuit that computes the factorial of an input
value when asked for:</p>
<div class="sourceCode" id="cb53"><pre
class="sourceCode ruby"><code class="sourceCode ruby"><span id="cb53-1"><a href="#cb53-1" aria-hidden="true" tabindex="-1"></a><span class="fu">system</span> <span class="wa">:fact</span> <span class="cf">do</span></span>
<span id="cb53-2"><a href="#cb53-2" aria-hidden="true" tabindex="-1"></a>   input <span class="wa">:clk</span>, <span class="wa">:start</span>, <span class="wa">:req</span></span>
<span id="cb53-3"><a href="#cb53-3" aria-hidden="true" tabindex="-1"></a>   <span class="kw">[</span><span class="dv">5</span><span class="kw">]</span><span class="at">.input</span> <span class="wa">:data_in</span></span>
<span id="cb53-4"><a href="#cb53-4" aria-hidden="true" tabindex="-1"></a>   output <span class="wa">:ack</span></span>
<span id="cb53-5"><a href="#cb53-5" aria-hidden="true" tabindex="-1"></a>   <span class="kw">[</span><span class="dv">32</span><span class="kw">]</span><span class="at">.output</span> <span class="wa">:data_out</span></span>
<span id="cb53-6"><a href="#cb53-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb53-7"><a href="#cb53-7" aria-hidden="true" tabindex="-1"></a>   <span class="kw">[</span><span class="dv">4</span><span class="kw">]</span><span class="at">.inner</span> <span class="wa">:val</span></span>
<span id="cb53-8"><a href="#cb53-8" aria-hidden="true" tabindex="-1"></a>   <span class="kw">[</span><span class="dv">24</span><span class="kw">]</span><span class="at">.inner</span> <span class="wa">:res</span></span>
<span id="cb53-9"><a href="#cb53-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb53-10"><a href="#cb53-10" aria-hidden="true" tabindex="-1"></a>   sequencer(clk,start) <span class="cf">do</span></span>
<span id="cb53-11"><a href="#cb53-11" aria-hidden="true" tabindex="-1"></a>      sloop <span class="cf">do</span></span>
<span id="cb53-12"><a href="#cb53-12" aria-hidden="true" tabindex="-1"></a>         ack <span class="kw">&lt;=</span> <span class="dv">0</span></span>
<span id="cb53-13"><a href="#cb53-13" aria-hidden="true" tabindex="-1"></a>         swhile(req !<span class="kw">=</span> <span class="dv">1</span>)</span>
<span id="cb53-14"><a href="#cb53-14" aria-hidden="true" tabindex="-1"></a>         val <span class="kw">&lt;=</span> data_in</span>
<span id="cb53-15"><a href="#cb53-15" aria-hidden="true" tabindex="-1"></a>         res <span class="kw">&lt;=</span> <span class="dv">1</span></span>
<span id="cb53-16"><a href="#cb53-16" aria-hidden="true" tabindex="-1"></a>         swhile(val<span class="kw">&gt;</span><span class="dv">1</span>) <span class="cf">do</span></span>
<span id="cb53-17"><a href="#cb53-17" aria-hidden="true" tabindex="-1"></a>             res <span class="kw">&lt;=</span> res<span class="kw">*</span>val</span>
<span id="cb53-18"><a href="#cb53-18" aria-hidden="true" tabindex="-1"></a>             val <span class="kw">&lt;=</span> val <span class="kw">-</span> <span class="dv">1</span></span>
<span id="cb53-19"><a href="#cb53-19" aria-hidden="true" tabindex="-1"></a>         <span class="cf">end</span></span>
<span id="cb53-20"><a href="#cb53-20" aria-hidden="true" tabindex="-1"></a>         data_out <span class="kw">&lt;=</span> res</span>
<span id="cb53-21"><a href="#cb53-21" aria-hidden="true" tabindex="-1"></a>         ack <span class="kw">&lt;=</span> <span class="dv">1</span></span>
<span id="cb53-22"><a href="#cb53-22" aria-hidden="true" tabindex="-1"></a>      <span class="cf">end</span></span>
<span id="cb53-23"><a href="#cb53-23" aria-hidden="true" tabindex="-1"></a>   <span class="cf">end</span></span>
<span id="cb53-24"><a href="#cb53-24" aria-hidden="true" tabindex="-1"></a><span class="cf">end</span></span></code></pre></div>
<p>The code is more complex than what we have seen up to now, so let us
study it progressively:</p>
<ul>
<li><p>The circuit is named <code>fact</code> (for factorial).</p></li>
<li><p>It has four inputs:</p>
<ul>
<li><p><code>clk</code> and <code>start</code>: the signals that control
the execution of the sequencer (nothing new here).</p></li>
<li><p><code>req</code>: the signal that will ask for a factorial
computation (<em>req</em> stands for require).</p></li>
<li><p><code>data_in</code>: the signal that will provide the input
value. It is a 4-bit unsigned integer.</p></li>
</ul></li>
<li><p>It has two outputs:</p>
<ul>
<li><p><code>ack</code>: the signal that will tell that the current
computation of factorial is over. Such a signal is necessary for the
environment to know if the output result is valid or not since the
computation time of a factorial depends on the input value.</p></li>
<li><p><code>data_out</code>: the signal that will hold the computation
result. It is a 24-bit unsigned integer, much larger than the input, but
we are computing factorials here! (This is not enough yet: 15! equals
1307674368000 which requires 41 bits… But 24-bit was the largest that
could fit in the picture of the time chart that is shown
after.)</p></li>
</ul></li>
<li><p>The sequencer includes an infinite loop (<code>sloop</code>) so
that it does not stop after one computation. Within this loop:</p>
<ul>
<li><p>It first sets <code>ack</code> to 0 to tell that currently, its
output is not valid (no computation is done yet).</p></li>
<li><p>Then it waits for a request, i.e., it waits for that signal
<code>req</code> is 1. This loop (<code>swhile(req != 1)</code>) does
not have any block to execute, it will therefore loop without doing
anything.</p></li>
<li><p>When <code>req</code> becomes 1, it loads the input value into an
internal temporary signal (<code>val</code>) and initializes the
computed value (<code>res</code>) to one.</p></li>
<li><p>Finally, it loops by multiplying <code>res</code> by
<code>val</code> and decreasing <code>val</code> until 1 is reached
before assigning the computation result to <code>data_out</code> and
setting <code>ack</code> to 1 for telling the computation is
over.</p></li>
</ul></li>
</ul>
<h4 id="does-it-work">Does it work?</h4>
<p>Now let us simulate this circuit. For that, you now know that we must
describe the environment using a timed process. But this time, let us do
this properly by putting the description of the environment in a
different module to separate the circuit description from the
simulation: please write in a file named <code>fact.rb</code> the code
of module <code>fact</code>, and then the following code:</p>
<div class="sourceCode" id="cb54"><pre
class="sourceCode ruby"><code class="sourceCode ruby"><span id="cb54-1"><a href="#cb54-1" aria-hidden="true" tabindex="-1"></a><span class="fu">system</span> <span class="wa">:fact_bench</span> <span class="cf">do</span></span>
<span id="cb54-2"><a href="#cb54-2" aria-hidden="true" tabindex="-1"></a>   inner <span class="wa">:clk</span>, <span class="wa">:start</span>, <span class="wa">:req</span>, <span class="wa">:ack</span></span>
<span id="cb54-3"><a href="#cb54-3" aria-hidden="true" tabindex="-1"></a>   <span class="kw">[</span><span class="dv">4</span><span class="kw">]</span><span class="at">.inner</span> <span class="wa">:x</span></span>
<span id="cb54-4"><a href="#cb54-4" aria-hidden="true" tabindex="-1"></a>   <span class="kw">[</span><span class="dv">24</span><span class="kw">]</span><span class="at">.inner</span> <span class="wa">:z</span></span>
<span id="cb54-5"><a href="#cb54-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb54-6"><a href="#cb54-6" aria-hidden="true" tabindex="-1"></a>   fact(<span class="wa">:factI</span>)<span class="kw">.</span>(clk,start,req,x,ack,z)</span>
<span id="cb54-7"><a href="#cb54-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb54-8"><a href="#cb54-8" aria-hidden="true" tabindex="-1"></a>   <span class="cf">def</span> clk!</span>
<span id="cb54-9"><a href="#cb54-9" aria-hidden="true" tabindex="-1"></a>       clk <span class="kw">&lt;=</span> <span class="dv">0</span></span>
<span id="cb54-10"><a href="#cb54-10" aria-hidden="true" tabindex="-1"></a>       !<span class="dv">10</span><span class="at">.ns</span></span>
<span id="cb54-11"><a href="#cb54-11" aria-hidden="true" tabindex="-1"></a>       clk <span class="kw">&lt;=</span> <span class="dv">1</span></span>
<span id="cb54-12"><a href="#cb54-12" aria-hidden="true" tabindex="-1"></a>       !<span class="dv">10</span><span class="at">.ns</span></span>
<span id="cb54-13"><a href="#cb54-13" aria-hidden="true" tabindex="-1"></a>   <span class="cf">end</span></span>
<span id="cb54-14"><a href="#cb54-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb54-15"><a href="#cb54-15" aria-hidden="true" tabindex="-1"></a>   timed <span class="cf">do</span></span>
<span id="cb54-16"><a href="#cb54-16" aria-hidden="true" tabindex="-1"></a>      start <span class="kw">&lt;=</span> <span class="dv">0</span></span>
<span id="cb54-17"><a href="#cb54-17" aria-hidden="true" tabindex="-1"></a>      !<span class="dv">10</span><span class="at">.ns</span></span>
<span id="cb54-18"><a href="#cb54-18" aria-hidden="true" tabindex="-1"></a>      clk!</span>
<span id="cb54-19"><a href="#cb54-19" aria-hidden="true" tabindex="-1"></a>      start <span class="kw">&lt;=</span> <span class="dv">1</span></span>
<span id="cb54-20"><a href="#cb54-20" aria-hidden="true" tabindex="-1"></a>      req   <span class="kw">&lt;=</span> <span class="dv">0</span></span>
<span id="cb54-21"><a href="#cb54-21" aria-hidden="true" tabindex="-1"></a>      clk!</span>
<span id="cb54-22"><a href="#cb54-22" aria-hidden="true" tabindex="-1"></a>      start <span class="kw">&lt;=</span> <span class="dv">0</span></span>
<span id="cb54-23"><a href="#cb54-23" aria-hidden="true" tabindex="-1"></a>      repeat(<span class="dv">2</span>) <span class="cf">do</span></span>
<span id="cb54-24"><a href="#cb54-24" aria-hidden="true" tabindex="-1"></a>          clk!</span>
<span id="cb54-25"><a href="#cb54-25" aria-hidden="true" tabindex="-1"></a>      <span class="cf">end</span></span>
<span id="cb54-26"><a href="#cb54-26" aria-hidden="true" tabindex="-1"></a>      req   <span class="kw">&lt;=</span> <span class="dv">1</span></span>
<span id="cb54-27"><a href="#cb54-27" aria-hidden="true" tabindex="-1"></a>      x     <span class="kw">&lt;=</span> <span class="dv">10</span></span>
<span id="cb54-28"><a href="#cb54-28" aria-hidden="true" tabindex="-1"></a>      clk!</span>
<span id="cb54-29"><a href="#cb54-29" aria-hidden="true" tabindex="-1"></a>      req   <span class="kw">&lt;=</span> <span class="dv">0</span></span>
<span id="cb54-30"><a href="#cb54-30" aria-hidden="true" tabindex="-1"></a>      repeat(<span class="dv">20</span>) <span class="cf">do</span></span>
<span id="cb54-31"><a href="#cb54-31" aria-hidden="true" tabindex="-1"></a>          clk!</span>
<span id="cb54-32"><a href="#cb54-32" aria-hidden="true" tabindex="-1"></a>      <span class="cf">end</span></span>
<span id="cb54-33"><a href="#cb54-33" aria-hidden="true" tabindex="-1"></a>   <span class="cf">end</span></span>
<span id="cb54-34"><a href="#cb54-34" aria-hidden="true" tabindex="-1"></a><span class="cf">end</span></span></code></pre></div>
<p>This module introduces the <code>repeat</code> construct. It can be
used within a timed process only and has the following syntax:</p>
<div class="sourceCode" id="cb55"><pre
class="sourceCode ruby"><code class="sourceCode ruby"><span id="cb55-1"><a href="#cb55-1" aria-hidden="true" tabindex="-1"></a>repeat(<span class="kw">&lt;</span>number<span class="kw">&gt;</span>) <span class="kw">&lt;</span>block<span class="kw">&gt;</span></span></code></pre></div>
<p>It executes the <code>block</code> <code>number</code> times with the
number of iterations as an argument.</p>
<p><strong>WARNING</strong>: the repeat construct cannot be used outside
a timed process. Inside a sequencer, you can use instead
<code>swhile</code> or <code>sfor</code>.</p>
<blockquote>
<p>There seems to be another new kind of command in the timed process:
<code>clk!</code>. This is not a command though, but it is a Ruby
function defined just before with the <code>def</code> block. If you are
not familiar with Ruby, <code>def</code> is used for defining a new
function (actually a method), also, it is not necessary to put
parenthesis when calling a function. Hence, <code>clk!</code> is simply
the call of this previously defined function (in Ruby, function names
can terminate with characters like <code>!</code> or <code>?</code>). If
you look at the body of this function, you will see not plain Ruby code,
but again HDLRuby code:</p>
</blockquote>
<div class="sourceCode" id="cb56"><pre
class="sourceCode ruby"><code class="sourceCode ruby"><span id="cb56-1"><a href="#cb56-1" aria-hidden="true" tabindex="-1"></a>clk <span class="kw">&lt;=</span> <span class="dv">0</span></span>
<span id="cb56-2"><a href="#cb56-2" aria-hidden="true" tabindex="-1"></a>!<span class="dv">10</span><span class="at">.ns</span></span>
<span id="cb56-3"><a href="#cb56-3" aria-hidden="true" tabindex="-1"></a>clk <span class="kw">&lt;=</span> <span class="dv">1</span></span>
<span id="cb56-4"><a href="#cb56-4" aria-hidden="true" tabindex="-1"></a>!<span class="dv">10</span><span class="at">.ns</span></span></code></pre></div>
<blockquote>
<p><strong>IMPORTANT</strong>: as said when presenting HDLRuby, this
language is implemented on top of the Ruby language, and is fully
compatible with it. For instance, you can write any Ruby code within
HDLRuby constructs (e.g., <code>def</code>), and you can write HDLRuby
code within Ruby constructs. However, there is an important difference:
Ruby code is executed at compile time (i.e., when hdrcc runs) and does
not produce any hardware, whereas HDLRuby code is the description of the
hardware that will be produced and will be then executed either through
simulation or after production physically. Then, what calling
<code>clk!</code> does is paste the HDLRuby code in place. Here it is
used to shorten the code: instead of each time setting the clock to 0,
advancing time, then setting it to 1 again, writing <code>clk!</code> is
enough to obtain the same result.<br />
It is from this capability to mix Ruby and HDLRuby that comes the
<em>meta programmability</em> of HDLRuby.</p>
</blockquote>
<p>Finally, when you simulate with the following command:</p>
<div class="sourceCode" id="cb57"><pre
class="sourceCode bash"><code class="sourceCode bash"><span id="cb57-1"><a href="#cb57-1" aria-hidden="true" tabindex="-1"></a><span class="ex">hdrcc</span> <span class="at">--sim</span> <span class="at">--vcd</span> fact.rb fact</span></code></pre></div>
<p>You should obtain the following kind of resulting VCD file:</p>
<p align="center">
<img data-name="hruby_simulator.vcd" src="fact_vcd.png"  width="80%">
</p>
<h4
id="but-in-structured-programming-it-is-better-to-use-local-variables">But
in structured programming, it is better to use local variables!</h4>
<p>Indeed, in the factorial program, signals <code>val</code> and
<code>res</code> are only used within the sequencer, so why declare them
outside it? The code would be more clear if they were declared more
locally, i.e., <em>inside</em> it, and even better, inside its main
loop. So let us modify it as follows:</p>
<div class="sourceCode" id="cb58"><pre
class="sourceCode ruby"><code class="sourceCode ruby"><span id="cb58-1"><a href="#cb58-1" aria-hidden="true" tabindex="-1"></a><span class="fu">system</span> <span class="wa">:fact</span> <span class="cf">do</span></span>
<span id="cb58-2"><a href="#cb58-2" aria-hidden="true" tabindex="-1"></a>   input <span class="wa">:clk</span>, <span class="wa">:start</span>, <span class="wa">:req</span></span>
<span id="cb58-3"><a href="#cb58-3" aria-hidden="true" tabindex="-1"></a>   <span class="kw">[</span><span class="dv">5</span><span class="kw">]</span><span class="at">.input</span> <span class="wa">:data_in</span></span>
<span id="cb58-4"><a href="#cb58-4" aria-hidden="true" tabindex="-1"></a>   output <span class="wa">:ack</span></span>
<span id="cb58-5"><a href="#cb58-5" aria-hidden="true" tabindex="-1"></a>   <span class="kw">[</span><span class="dv">32</span><span class="kw">]</span><span class="at">.output</span> <span class="wa">:data_out</span></span>
<span id="cb58-6"><a href="#cb58-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb58-7"><a href="#cb58-7" aria-hidden="true" tabindex="-1"></a>   sequencer(clk,start) <span class="cf">do</span></span>
<span id="cb58-8"><a href="#cb58-8" aria-hidden="true" tabindex="-1"></a>      sloop <span class="cf">do</span></span>
<span id="cb58-9"><a href="#cb58-9" aria-hidden="true" tabindex="-1"></a>         <span class="kw">[</span><span class="dv">4</span><span class="kw">]</span><span class="at">.inner</span> <span class="wa">:val</span></span>
<span id="cb58-10"><a href="#cb58-10" aria-hidden="true" tabindex="-1"></a>         <span class="kw">[</span><span class="dv">24</span><span class="kw">]</span><span class="at">.inner</span> <span class="wa">:res</span></span>
<span id="cb58-11"><a href="#cb58-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb58-12"><a href="#cb58-12" aria-hidden="true" tabindex="-1"></a>         ack <span class="kw">&lt;=</span> <span class="dv">0</span></span>
<span id="cb58-13"><a href="#cb58-13" aria-hidden="true" tabindex="-1"></a>         swhile(req !<span class="kw">=</span> <span class="dv">1</span>)</span>
<span id="cb58-14"><a href="#cb58-14" aria-hidden="true" tabindex="-1"></a>         val <span class="kw">&lt;=</span> data_in</span>
<span id="cb58-15"><a href="#cb58-15" aria-hidden="true" tabindex="-1"></a>         res <span class="kw">&lt;=</span> <span class="dv">1</span></span>
<span id="cb58-16"><a href="#cb58-16" aria-hidden="true" tabindex="-1"></a>         swhile(val<span class="kw">&gt;</span><span class="dv">1</span>) <span class="cf">do</span></span>
<span id="cb58-17"><a href="#cb58-17" aria-hidden="true" tabindex="-1"></a>             res <span class="kw">&lt;=</span> res<span class="kw">*</span>val</span>
<span id="cb58-18"><a href="#cb58-18" aria-hidden="true" tabindex="-1"></a>             val <span class="kw">&lt;=</span> val <span class="kw">-</span> <span class="dv">1</span></span>
<span id="cb58-19"><a href="#cb58-19" aria-hidden="true" tabindex="-1"></a>         <span class="cf">end</span></span>
<span id="cb58-20"><a href="#cb58-20" aria-hidden="true" tabindex="-1"></a>         data_out <span class="kw">&lt;=</span> res</span>
<span id="cb58-21"><a href="#cb58-21" aria-hidden="true" tabindex="-1"></a>         ack <span class="kw">&lt;=</span> <span class="dv">1</span></span>
<span id="cb58-22"><a href="#cb58-22" aria-hidden="true" tabindex="-1"></a>      <span class="cf">end</span></span>
<span id="cb58-23"><a href="#cb58-23" aria-hidden="true" tabindex="-1"></a>   <span class="cf">end</span></span>
<span id="cb58-24"><a href="#cb58-24" aria-hidden="true" tabindex="-1"></a><span class="cf">end</span></span></code></pre></div>
<p>You can simulate it again, and you should obtain the same result.
However, if you try to access <code>res</code> or <code>val</code>
outside the main loop, then an error will be raised.</p>
<h4 id="now-about-sfor">Now about <code>sfor</code></h4>
<p>With a for statement you may expect something like C with the
definition of an index, its initialization, and its increment. However,
the <code>sfor</code> of HDLRuby is simpler: it only takes as argument
an enumerable object and will iterate on each of its elements. An
enumerable object is any Ruby enumerable object as well as any signal.
For example, the following circuit outputs bit by bit the content of a
32-bit input value:</p>
<div class="sourceCode" id="cb59"><pre
class="sourceCode ruby"><code class="sourceCode ruby"><span id="cb59-1"><a href="#cb59-1" aria-hidden="true" tabindex="-1"></a><span class="fu">system</span> <span class="wa">:serializer</span> <span class="cf">do</span></span>
<span id="cb59-2"><a href="#cb59-2" aria-hidden="true" tabindex="-1"></a>   input <span class="wa">:clk</span>, <span class="wa">:start</span>, <span class="wa">:req</span></span>
<span id="cb59-3"><a href="#cb59-3" aria-hidden="true" tabindex="-1"></a>   <span class="kw">[</span><span class="dv">32</span><span class="kw">]</span><span class="at">.input</span> <span class="wa">:data_in</span></span>
<span id="cb59-4"><a href="#cb59-4" aria-hidden="true" tabindex="-1"></a>   output <span class="wa">:tx</span>, <span class="wa">:data_out</span></span>
<span id="cb59-5"><a href="#cb59-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb59-6"><a href="#cb59-6" aria-hidden="true" tabindex="-1"></a>   sequencer(clk,start) <span class="cf">do</span></span>
<span id="cb59-7"><a href="#cb59-7" aria-hidden="true" tabindex="-1"></a>      tx <span class="kw">&lt;=</span> <span class="dv">0</span></span>
<span id="cb59-8"><a href="#cb59-8" aria-hidden="true" tabindex="-1"></a>      data_out <span class="kw">&lt;=</span> <span class="dv">0</span></span>
<span id="cb59-9"><a href="#cb59-9" aria-hidden="true" tabindex="-1"></a>      sloop <span class="cf">do</span></span>
<span id="cb59-10"><a href="#cb59-10" aria-hidden="true" tabindex="-1"></a>         sif(req) <span class="cf">do</span></span>
<span id="cb59-11"><a href="#cb59-11" aria-hidden="true" tabindex="-1"></a>            tx <span class="kw">&lt;=</span> <span class="dv">1</span></span>
<span id="cb59-12"><a href="#cb59-12" aria-hidden="true" tabindex="-1"></a>            sfor(data_in) <span class="cf">do</span> <span class="kw">|</span>b<span class="kw">|</span></span>
<span id="cb59-13"><a href="#cb59-13" aria-hidden="true" tabindex="-1"></a>               data_out <span class="kw">&lt;=</span> b</span>
<span id="cb59-14"><a href="#cb59-14" aria-hidden="true" tabindex="-1"></a>            <span class="cf">end</span></span>
<span id="cb59-15"><a href="#cb59-15" aria-hidden="true" tabindex="-1"></a>            tx <span class="kw">&lt;=</span> <span class="dv">0</span></span>
<span id="cb59-16"><a href="#cb59-16" aria-hidden="true" tabindex="-1"></a>            data_out <span class="kw">&lt;=</span> <span class="dv">0</span></span>
<span id="cb59-17"><a href="#cb59-17" aria-hidden="true" tabindex="-1"></a>         <span class="cf">end</span></span>
<span id="cb59-18"><a href="#cb59-18" aria-hidden="true" tabindex="-1"></a>      <span class="cf">end</span></span>
<span id="cb59-19"><a href="#cb59-19" aria-hidden="true" tabindex="-1"></a>   <span class="cf">end</span></span>
<span id="cb59-20"><a href="#cb59-20" aria-hidden="true" tabindex="-1"></a><span class="cf">end</span></span></code></pre></div>
<p>This circuit takes as input <code>data_in</code> and sends its
content bit by bit to <code>data_out</code> when <code>req</code> is set
to 1. In detail, it first indicates the beginning of the transmission by
setting <code>tx</code> to 1, then from the next clock cycle will send
one bit of <code>data_in</code> per clock cycle. When the transmission
is over, it sets tx to 0 again. There are a few more details to
unwrap:</p>
<ul>
<li><p>By default both <code>tx</code> and <code>data_out</code> are set
to 0, this is done at the beginning of the sequencer but also just after
the <code>sfor</code>.</p></li>
<li><p><code>tx</code> is set to 1 just before the <code>sfor</code>
loop, i.e., one cycle before the actual transmission. As said in the
description of the <a href="#sequencer-structured">control
statements</a>, each of them requires one clock cycle before
branching.</p></li>
</ul>
<blockquote>
<p>This for loop could also have been implemented using an index as
follows:</p>
</blockquote>
<div class="sourceCode" id="cb60"><pre
class="sourceCode ruby"><code class="sourceCode ruby"><span id="cb60-1"><a href="#cb60-1" aria-hidden="true" tabindex="-1"></a>   sfor(<span class="dv">0</span><span class="kw">..</span><span class="dv">31</span>) <span class="cf">do</span> <span class="kw">|</span>i<span class="kw">|</span></span>
<span id="cb60-2"><a href="#cb60-2" aria-hidden="true" tabindex="-1"></a>      data_out <span class="kw">&lt;=</span> data_in<span class="kw">[</span>i<span class="kw">]</span></span>
<span id="cb60-3"><a href="#cb60-3" aria-hidden="true" tabindex="-1"></a>   <span class="cf">end</span></span></code></pre></div>
<blockquote>
<p>However, the advantage of the first version of the code is that it is
still valid when the data type of <code>data_in</code> is changed
whereas the second version must be rewritten to adjust the range of the
index.</p>
</blockquote>
<p>If you want, you can try this serializer, you need to add a module
representing the environment. For example:</p>
<div class="sourceCode" id="cb61"><pre
class="sourceCode ruby"><code class="sourceCode ruby"><span id="cb61-1"><a href="#cb61-1" aria-hidden="true" tabindex="-1"></a><span class="fu">system</span> <span class="wa">:serializer_bench</span> <span class="cf">do</span></span>
<span id="cb61-2"><a href="#cb61-2" aria-hidden="true" tabindex="-1"></a>   inner <span class="wa">:clk</span>, <span class="wa">:start</span>, <span class="wa">:req</span>, <span class="wa">:tx</span></span>
<span id="cb61-3"><a href="#cb61-3" aria-hidden="true" tabindex="-1"></a>   <span class="kw">[</span><span class="dv">8</span><span class="kw">]</span><span class="at">.inner</span> <span class="wa">:x</span></span>
<span id="cb61-4"><a href="#cb61-4" aria-hidden="true" tabindex="-1"></a>   inner <span class="wa">:z</span></span>
<span id="cb61-5"><a href="#cb61-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb61-6"><a href="#cb61-6" aria-hidden="true" tabindex="-1"></a>   serializer(<span class="wa">:serializerI</span>)<span class="kw">.</span>(clk,start,req,x,tx,z)</span>
<span id="cb61-7"><a href="#cb61-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb61-8"><a href="#cb61-8" aria-hidden="true" tabindex="-1"></a>   <span class="cf">def</span> clk!</span>
<span id="cb61-9"><a href="#cb61-9" aria-hidden="true" tabindex="-1"></a>       clk <span class="kw">&lt;=</span> <span class="dv">0</span></span>
<span id="cb61-10"><a href="#cb61-10" aria-hidden="true" tabindex="-1"></a>       !<span class="dv">10</span><span class="at">.ns</span></span>
<span id="cb61-11"><a href="#cb61-11" aria-hidden="true" tabindex="-1"></a>       clk <span class="kw">&lt;=</span> <span class="dv">1</span></span>
<span id="cb61-12"><a href="#cb61-12" aria-hidden="true" tabindex="-1"></a>       !<span class="dv">10</span><span class="at">.ns</span></span>
<span id="cb61-13"><a href="#cb61-13" aria-hidden="true" tabindex="-1"></a>   <span class="cf">end</span></span>
<span id="cb61-14"><a href="#cb61-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb61-15"><a href="#cb61-15" aria-hidden="true" tabindex="-1"></a>      timed <span class="cf">do</span></span>
<span id="cb61-16"><a href="#cb61-16" aria-hidden="true" tabindex="-1"></a>      start <span class="kw">&lt;=</span> <span class="dv">0</span></span>
<span id="cb61-17"><a href="#cb61-17" aria-hidden="true" tabindex="-1"></a>      !<span class="dv">10</span><span class="at">.ns</span></span>
<span id="cb61-18"><a href="#cb61-18" aria-hidden="true" tabindex="-1"></a>      clk!</span>
<span id="cb61-19"><a href="#cb61-19" aria-hidden="true" tabindex="-1"></a>      start <span class="kw">&lt;=</span> <span class="dv">1</span></span>
<span id="cb61-20"><a href="#cb61-20" aria-hidden="true" tabindex="-1"></a>      req   <span class="kw">&lt;=</span> <span class="dv">0</span></span>
<span id="cb61-21"><a href="#cb61-21" aria-hidden="true" tabindex="-1"></a>      clk!</span>
<span id="cb61-22"><a href="#cb61-22" aria-hidden="true" tabindex="-1"></a>      start <span class="kw">&lt;=</span> <span class="dv">0</span></span>
<span id="cb61-23"><a href="#cb61-23" aria-hidden="true" tabindex="-1"></a>      repeat(<span class="dv">2</span>) <span class="cf">do</span></span>
<span id="cb61-24"><a href="#cb61-24" aria-hidden="true" tabindex="-1"></a>          clk!</span>
<span id="cb61-25"><a href="#cb61-25" aria-hidden="true" tabindex="-1"></a>      <span class="cf">end</span></span>
<span id="cb61-26"><a href="#cb61-26" aria-hidden="true" tabindex="-1"></a>      req   <span class="kw">&lt;=</span> <span class="dv">1</span></span>
<span id="cb61-27"><a href="#cb61-27" aria-hidden="true" tabindex="-1"></a>      x     <span class="kw">&lt;=</span> _hAB</span>
<span id="cb61-28"><a href="#cb61-28" aria-hidden="true" tabindex="-1"></a>      clk!</span>
<span id="cb61-29"><a href="#cb61-29" aria-hidden="true" tabindex="-1"></a>      req   <span class="kw">&lt;=</span> <span class="dv">0</span></span>
<span id="cb61-30"><a href="#cb61-30" aria-hidden="true" tabindex="-1"></a>      repeat(<span class="dv">16</span>) <span class="cf">do</span></span>
<span id="cb61-31"><a href="#cb61-31" aria-hidden="true" tabindex="-1"></a>          clk!</span>
<span id="cb61-32"><a href="#cb61-32" aria-hidden="true" tabindex="-1"></a>      <span class="cf">end</span></span>
<span id="cb61-33"><a href="#cb61-33" aria-hidden="true" tabindex="-1"></a>   <span class="cf">end</span></span>
<span id="cb61-34"><a href="#cb61-34" aria-hidden="true" tabindex="-1"></a><span class="cf">end</span></span></code></pre></div>
<blockquote>
<p>There is a new notation: <code>_hAB</code>, this is used for
representing fixed bit-width hexadecimal. Since there are two digits, it
is an 8-bit value. You can also use binary representations as follows:
<code>_b10101011</code>.</p>
</blockquote>
<p>When everything is put in a file named: <code>serializer.rb</code>
and simulated as follows:</p>
<div class="sourceCode" id="cb62"><pre
class="sourceCode bash"><code class="sourceCode bash"><span id="cb62-1"><a href="#cb62-1" aria-hidden="true" tabindex="-1"></a><span class="ex">hdrcc</span> <span class="at">--sim</span> <span class="at">--vcd</span> serializer.rb serializer</span></code></pre></div>
<p>You should obtain the following time chart:</p>
<p align="center">
<img data-name="hruby_simulator.vcd" src="serializer_vcd.png"  width="80%">
</p>
<h4 id="how-to-write-and-use-a-sequencer-function.">3.2.3. How to write
and use a sequencer function.</h4>
<p>Why not necessarily associated with algorithmic, it is common in
software to define functions for code reuse and implementation of
recursive algorithms. HDLRuby also provided such kinds of functions,
with all the software features, including recursion, using the construct
<code>sdef</code>. Such a function is defined as follows:</p>
<div class="sourceCode" id="cb63"><pre
class="sourceCode ruby"><code class="sourceCode ruby"><span id="cb63-1"><a href="#cb63-1" aria-hidden="true" tabindex="-1"></a>sdef :<span class="kw">&lt;</span>name<span class="kw">&gt;</span> <span class="cf">do</span> <span class="kw">|&lt;</span>arguments<span class="kw">&gt;|</span></span>
<span id="cb63-2"><a href="#cb63-2" aria-hidden="true" tabindex="-1"></a>   <span class="kw">&lt;</span>body<span class="kw">&gt;</span></span>
<span id="cb63-3"><a href="#cb63-3" aria-hidden="true" tabindex="-1"></a><span class="cf">end</span></span></code></pre></div>
<p>In the code above, <code>name</code> is the name of the function,
<code>arguments</code> is a list of arguments and <code>body</code> is
the code of the function that can be any kind of HDLRuby sequencer code.
For returning a value from a function, the
<code>sreturn(&lt;value&gt;)</code> command is used. For example, the
following describes a function computing the factorial of its argument
<code>n</code>:</p>
<div class="sourceCode" id="cb64"><pre
class="sourceCode ruby"><code class="sourceCode ruby"><span id="cb64-1"><a href="#cb64-1" aria-hidden="true" tabindex="-1"></a>sdef <span class="wa">:fact</span> <span class="cf">do</span> <span class="kw">|</span>n<span class="kw">|</span></span>
<span id="cb64-2"><a href="#cb64-2" aria-hidden="true" tabindex="-1"></a>   sif(n<span class="kw">&gt;</span><span class="dv">1</span>) <span class="kw">{</span> sreturn(n<span class="kw">*</span>fact(n<span class="dv">-1</span>) <span class="kw">}</span></span>
<span id="cb64-3"><a href="#cb64-3" aria-hidden="true" tabindex="-1"></a>   selse    <span class="kw">{</span> sreturn(<span class="dv">1</span>) <span class="kw">}</span></span>
<span id="cb64-4"><a href="#cb64-4" aria-hidden="true" tabindex="-1"></a><span class="cf">end</span></span></code></pre></div>
<p>There is a lot to unpack from this small example:</p>
<ol type="1">
<li><p>Such a function can be defined outside or inside a module, but
can only be called within a sequencer.</p></li>
<li><p>The arguments of a function, here <code>n</code>, do not have any
defined type: their type, and consequently the final implementation of
the function, is determined by the data type of the actual arguments
when the function is called. For example, in the following code, the
data type of the actual argument <code>val</code> is 16-bit unsigned,
hence that will be the data type of <code>n</code>.</p>
<div class="sourceCode" id="cb65"><pre
class="sourceCode ruby"><code class="sourceCode ruby"><span id="cb65-1"><a href="#cb65-1" aria-hidden="true" tabindex="-1"></a><span class="kw">[</span><span class="dv">16</span><span class="kw">]</span><span class="at">.inner</span> <span class="wa">:val</span>, <span class="wa">:res</span></span>
<span id="cb65-2"><a href="#cb65-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb65-3"><a href="#cb65-3" aria-hidden="true" tabindex="-1"></a>sequencer <span class="cf">do</span></span>
<span id="cb65-4"><a href="#cb65-4" aria-hidden="true" tabindex="-1"></a>   val <span class="kw">&lt;=</span> <span class="dv">5</span></span>
<span id="cb65-5"><a href="#cb65-5" aria-hidden="true" tabindex="-1"></a>   res <span class="kw">&lt;=</span> fact(val)</span>
<span id="cb65-6"><a href="#cb65-6" aria-hidden="true" tabindex="-1"></a><span class="cf">end</span></span></code></pre></div></li>
<li><p>When a function is recursive, a stack is created to store the
arguments and the sequencer states for returning at each recursion. The
size of this stack is by default set to the bit width of the largest
argument, e.g., for <code>fact</code> it is set for supporting 16
recursions. In case of stack overflow, i.e., there were too many
recursive calls, the recursion is stopped, and the execution of the
sequencer proceeds from just after the last call.</p></li>
<li><p>The behavior of the stack can be controlled in two ways when
defining a function as follows:</p>
<div class="sourceCode" id="cb66"><pre
class="sourceCode ruby"><code class="sourceCode ruby"><span id="cb66-1"><a href="#cb66-1" aria-hidden="true" tabindex="-1"></a>sdef(:<span class="kw">&lt;</span>name<span class="kw">&gt;</span>,<span class="kw">&lt;</span>size<span class="kw">&gt;</span>, <span class="fu">proc</span> <span class="kw">&lt;</span>error_handler<span class="kw">&gt;</span>) <span class="cf">do</span> <span class="kw">|&lt;</span>arguments<span class="kw">&gt;|</span></span>
<span id="cb66-2"><a href="#cb66-2" aria-hidden="true" tabindex="-1"></a>   <span class="kw">&lt;</span>body<span class="kw">&gt;</span></span>
<span id="cb66-3"><a href="#cb66-3" aria-hidden="true" tabindex="-1"></a><span class="cf">end</span></span></code></pre></div>
<p>In the code above, <code>size</code> is the forced size of the stack,
and <code>error_handler</code> is a block of code that will be executed
when a stack overflow occurs. Both arguments are optional, but if the
error handler is provided, then the size must also be provided. For
example, the code of the factorial can be rewritten as follows to force
the stack to support 64 recursions:</p>
<div class="sourceCode" id="cb67"><pre
class="sourceCode ruby"><code class="sourceCode ruby"><span id="cb67-1"><a href="#cb67-1" aria-hidden="true" tabindex="-1"></a>sdef(<span class="wa">:fact</span>,<span class="dv">64</span>) <span class="cf">do</span> <span class="kw">|</span>n<span class="kw">|</span></span>
<span id="cb67-2"><a href="#cb67-2" aria-hidden="true" tabindex="-1"></a>   sif(n<span class="kw">&gt;</span><span class="dv">1</span>) <span class="kw">{</span> sreturn(n<span class="kw">*</span>fact(n<span class="dv">-1</span>) <span class="kw">}</span></span>
<span id="cb67-3"><a href="#cb67-3" aria-hidden="true" tabindex="-1"></a>   selse    <span class="kw">{</span> sreturn(<span class="dv">1</span>) <span class="kw">}</span></span>
<span id="cb67-4"><a href="#cb67-4" aria-hidden="true" tabindex="-1"></a><span class="cf">end</span></span></code></pre></div>
<p>It can also be defined as follows to support only 8 recursions but to
set a signal named <code>stack_overflow</code> to 1 when a stack
overflow happens:</p>
<div class="sourceCode" id="cb68"><pre
class="sourceCode ruby"><code class="sourceCode ruby"><span id="cb68-1"><a href="#cb68-1" aria-hidden="true" tabindex="-1"></a>sdef(<span class="wa">:fact</span>, <span class="dv">8</span>, <span class="fu">proc</span> <span class="kw">{</span> stack_overflow <span class="kw">&lt;=</span> <span class="dv">1</span> <span class="kw">}</span>) <span class="cf">do</span> <span class="kw">|</span>n<span class="kw">|</span></span>
<span id="cb68-2"><a href="#cb68-2" aria-hidden="true" tabindex="-1"></a>   sif(n<span class="kw">&gt;</span><span class="dv">1</span>) <span class="kw">{</span> sreturn(n<span class="kw">*</span>fact(n<span class="dv">-1</span>) <span class="kw">}</span></span>
<span id="cb68-3"><a href="#cb68-3" aria-hidden="true" tabindex="-1"></a>   selse    <span class="kw">{</span> sreturn(<span class="dv">1</span>) <span class="kw">}</span></span>
<span id="cb68-4"><a href="#cb68-4" aria-hidden="true" tabindex="-1"></a><span class="cf">end</span></span></code></pre></div></li>
</ol>
<p>Here is a full example using the factorial:</p>
<div class="sourceCode" id="cb69"><pre
class="sourceCode ruby"><code class="sourceCode ruby"><span id="cb69-1"><a href="#cb69-1" aria-hidden="true" tabindex="-1"></a>sdef(<span class="wa">:fact</span>,<span class="dv">8</span>,<span class="fu">proc</span> <span class="kw">{</span> stack_overflow_error <span class="kw">&lt;=</span> <span class="dv">1</span> <span class="kw">}</span>) <span class="cf">do</span> <span class="kw">|</span>n<span class="kw">|</span></span>
<span id="cb69-2"><a href="#cb69-2" aria-hidden="true" tabindex="-1"></a>    sif(n <span class="kw">&gt;</span> <span class="dv">1</span>) <span class="kw">{</span> sreturn(n<span class="kw">*</span>fact(n<span class="dv">-1</span>)) <span class="kw">}</span></span>
<span id="cb69-3"><a href="#cb69-3" aria-hidden="true" tabindex="-1"></a>    selse      <span class="kw">{</span> sreturn(<span class="dv">1</span>) <span class="kw">}</span></span>
<span id="cb69-4"><a href="#cb69-4" aria-hidden="true" tabindex="-1"></a><span class="cf">end</span></span>
<span id="cb69-5"><a href="#cb69-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb69-6"><a href="#cb69-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb69-7"><a href="#cb69-7" aria-hidden="true" tabindex="-1"></a><span class="co"># Checking the fact function.</span></span>
<span id="cb69-8"><a href="#cb69-8" aria-hidden="true" tabindex="-1"></a><span class="fu">system</span> <span class="wa">:module_with_fact</span> <span class="cf">do</span></span>
<span id="cb69-9"><a href="#cb69-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb69-10"><a href="#cb69-10" aria-hidden="true" tabindex="-1"></a>    inner <span class="wa">:clk</span>,<span class="wa">:rst</span></span>
<span id="cb69-11"><a href="#cb69-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb69-12"><a href="#cb69-12" aria-hidden="true" tabindex="-1"></a>    <span class="kw">[</span><span class="dv">16</span><span class="kw">]</span><span class="at">.inner</span> <span class="wa">:val</span></span>
<span id="cb69-13"><a href="#cb69-13" aria-hidden="true" tabindex="-1"></a>    <span class="kw">[</span><span class="dv">16</span><span class="kw">]</span><span class="at">.inner</span> <span class="wa">:res</span></span>
<span id="cb69-14"><a href="#cb69-14" aria-hidden="true" tabindex="-1"></a>    inner <span class="wa">stack_overflow_error: </span><span class="dv">0</span></span>
<span id="cb69-15"><a href="#cb69-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb69-16"><a href="#cb69-16" aria-hidden="true" tabindex="-1"></a>    sequencer(clk<span class="at">.posedge</span>,rst) <span class="cf">do</span></span>
<span id="cb69-17"><a href="#cb69-17" aria-hidden="true" tabindex="-1"></a>        <span class="dv">5</span><span class="at">.stimes</span> <span class="cf">do</span> <span class="kw">|</span>i<span class="kw">|</span></span>
<span id="cb69-18"><a href="#cb69-18" aria-hidden="true" tabindex="-1"></a>            val <span class="kw">&lt;=</span> i</span>
<span id="cb69-19"><a href="#cb69-19" aria-hidden="true" tabindex="-1"></a>            res <span class="kw">&lt;=</span> fact(val)</span>
<span id="cb69-20"><a href="#cb69-20" aria-hidden="true" tabindex="-1"></a>        <span class="cf">end</span></span>
<span id="cb69-21"><a href="#cb69-21" aria-hidden="true" tabindex="-1"></a>        hprint(<span class="st">&quot;stack_overflow_error=&quot;</span>,stack_overflow_error,<span class="st">&quot;\n&quot;</span>)</span>
<span id="cb69-22"><a href="#cb69-22" aria-hidden="true" tabindex="-1"></a>    <span class="cf">end</span></span>
<span id="cb69-23"><a href="#cb69-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb69-24"><a href="#cb69-24" aria-hidden="true" tabindex="-1"></a>    timed <span class="cf">do</span></span>
<span id="cb69-25"><a href="#cb69-25" aria-hidden="true" tabindex="-1"></a>        clk <span class="kw">&lt;=</span> <span class="dv">0</span></span>
<span id="cb69-26"><a href="#cb69-26" aria-hidden="true" tabindex="-1"></a>        rst <span class="kw">&lt;=</span> <span class="dv">0</span></span>
<span id="cb69-27"><a href="#cb69-27" aria-hidden="true" tabindex="-1"></a>        !<span class="dv">10</span><span class="at">.ns</span></span>
<span id="cb69-28"><a href="#cb69-28" aria-hidden="true" tabindex="-1"></a>        clk <span class="kw">&lt;=</span> <span class="dv">1</span></span>
<span id="cb69-29"><a href="#cb69-29" aria-hidden="true" tabindex="-1"></a>        !<span class="dv">10</span><span class="at">.ns</span></span>
<span id="cb69-30"><a href="#cb69-30" aria-hidden="true" tabindex="-1"></a>        clk <span class="kw">&lt;=</span> <span class="dv">0</span></span>
<span id="cb69-31"><a href="#cb69-31" aria-hidden="true" tabindex="-1"></a>        rst <span class="kw">&lt;=</span> <span class="dv">1</span></span>
<span id="cb69-32"><a href="#cb69-32" aria-hidden="true" tabindex="-1"></a>        !<span class="dv">10</span><span class="at">.ns</span></span>
<span id="cb69-33"><a href="#cb69-33" aria-hidden="true" tabindex="-1"></a>        clk <span class="kw">&lt;=</span> <span class="dv">1</span></span>
<span id="cb69-34"><a href="#cb69-34" aria-hidden="true" tabindex="-1"></a>        !<span class="dv">10</span><span class="at">.ns</span></span>
<span id="cb69-35"><a href="#cb69-35" aria-hidden="true" tabindex="-1"></a>        clk <span class="kw">&lt;=</span> <span class="dv">0</span></span>
<span id="cb69-36"><a href="#cb69-36" aria-hidden="true" tabindex="-1"></a>        rst <span class="kw">&lt;=</span> <span class="dv">0</span></span>
<span id="cb69-37"><a href="#cb69-37" aria-hidden="true" tabindex="-1"></a>        !<span class="dv">10</span><span class="at">.ns</span></span>
<span id="cb69-38"><a href="#cb69-38" aria-hidden="true" tabindex="-1"></a>        clk <span class="kw">&lt;=</span> <span class="dv">1</span></span>
<span id="cb69-39"><a href="#cb69-39" aria-hidden="true" tabindex="-1"></a>        repeat(<span class="dv">500</span>) <span class="cf">do</span></span>
<span id="cb69-40"><a href="#cb69-40" aria-hidden="true" tabindex="-1"></a>            !<span class="dv">10</span><span class="at">.ns</span></span>
<span id="cb69-41"><a href="#cb69-41" aria-hidden="true" tabindex="-1"></a>            clk <span class="kw">&lt;=</span> <span class="kw">~</span>clk</span>
<span id="cb69-42"><a href="#cb69-42" aria-hidden="true" tabindex="-1"></a>        <span class="cf">end</span></span>
<span id="cb69-43"><a href="#cb69-43" aria-hidden="true" tabindex="-1"></a>    <span class="cf">end</span></span>
<span id="cb69-44"><a href="#cb69-44" aria-hidden="true" tabindex="-1"></a><span class="cf">end</span></span></code></pre></div>
<hr />
<p>So now, you know:</p>
<ul>
<li>How to describe fully-fledged algorithms with sequencers using
conditional and control statements as well as functions, including
recursive ones.</li>
</ul>
<p>Also, if you are not familiar with languages like Ruby or Python, the
<code>sfor</code> may look great compared to what C can provide. But
this is just the beginning, HDLRuby can do better than that.</p>
<h4 id="how-to-use-enumerators-in-a-sequencer">3.2.4. How to use
enumerators in a sequencer</h4>
<p>If sometimes you program with Ruby, you may know about enumerators:
they are objects used for processing iteratively several elements of
objects. The HDLRuby’s sequencer provides the same concept: it is
possible to build hardware enumerators for any enumerable objects and
they will run like Ruby’s.</p>
<blockquote>
<p>We recommend before going on with this tutorial you study the Ruby
enumerable and enumerators. Indeed, since the HDLRuby enumerators and
enumerable objects do reproduce the functionalities of the Ruby ones, we
will only point out what is specific to the hardware.</p>
</blockquote>
<h4 id="first-what-is-an-enumerable">First, what is an enumerable?</h4>
<p>So, enumerators iterate over enumerable, but what is it? In HDLRuby,
an enumerable is either a Ruby enumerable object, an enumerator (Ruby or
HDLRuby), or a signal of any type. If the signal is an array, the
iteration will be over its elements, if it is a number, it will be done
over its bits. For example, <code>0..2</code> is an enumerable including
0, 1, and 2 as elements, <code>[3,6,7]</code> is one including 3, 6, and
7, and the following signal <code>sig</code> includes 0, 1, 1, 0, 1, 1,
1, 0:</p>
<div class="sourceCode" id="cb70"><pre
class="sourceCode ruby"><code class="sourceCode ruby"><span id="cb70-1"><a href="#cb70-1" aria-hidden="true" tabindex="-1"></a><span class="kw">[</span><span class="dv">8</span><span class="kw">]</span><span class="at">.inner</span> <span class="wa">sig: </span>_b01110110</span></code></pre></div>
<h4 id="let-us-build-hdlruby-enumerators.">Let us build HDLRuby
enumerators.</h4>
<p>Like Ruby builds enumerators using the <code>each</code> method and
its derivates (<code>each_with_index</code> and so on,) HDLRuby uses the
<code>seach</code> method to build its enumerator. For example, an
enumerator over the bits of signal <code>sig</code> will be built as
follows: <code>sig.seach</code>, and if you want an enumerator with
index, just like Ruby: <code>sig.seach_with_index</code>, and so on.
Then, an enumerator can be executed when created by providing the block
that will be applied on each element like in ruby, or executed later
using the <code>seach</code> method again. For example, the following
sequencer code first sums the bits of signal sig at once, then does it
again later with another enumerator previously stored in the Ruby
variable <code>another_enumerator</code>:</p>
<div class="sourceCode" id="cb71"><pre
class="sourceCode ruby"><code class="sourceCode ruby"><span id="cb71-1"><a href="#cb71-1" aria-hidden="true" tabindex="-1"></a>input <span class="wa">:clk</span>, <span class="wa">:start</span></span>
<span id="cb71-2"><a href="#cb71-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb71-3"><a href="#cb71-3" aria-hidden="true" tabindex="-1"></a><span class="kw">[</span><span class="dv">8</span><span class="kw">]</span><span class="at">.inner</span> <span class="wa">sig: </span>_b01110110</span>
<span id="cb71-4"><a href="#cb71-4" aria-hidden="true" tabindex="-1"></a><span class="kw">[</span><span class="dv">4</span><span class="kw">]</span><span class="at">.inner</span> num0, <span class="wa">:num1</span></span>
<span id="cb71-5"><a href="#cb71-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb71-6"><a href="#cb71-6" aria-hidden="true" tabindex="-1"></a>sequencer(clk,start) <span class="cf">do</span></span>
<span id="cb71-7"><a href="#cb71-7" aria-hidden="true" tabindex="-1"></a>   another_enum <span class="kw">=</span> sig<span class="at">.seach</span></span>
<span id="cb71-8"><a href="#cb71-8" aria-hidden="true" tabindex="-1"></a>   num0 <span class="kw">&lt;=</span> <span class="dv">0</span></span>
<span id="cb71-9"><a href="#cb71-9" aria-hidden="true" tabindex="-1"></a>   num1 <span class="kw">&lt;=</span> <span class="dv">0</span></span>
<span id="cb71-10"><a href="#cb71-10" aria-hidden="true" tabindex="-1"></a>   sig<span class="at">.seach</span> <span class="kw">{|</span>b<span class="kw">|</span> num0 <span class="kw">&lt;=</span> num0 <span class="kw">+</span> b <span class="kw">}</span></span>
<span id="cb71-11"><a href="#cb71-11" aria-hidden="true" tabindex="-1"></a>   sig <span class="kw">&lt;=</span> _hCD</span>
<span id="cb71-12"><a href="#cb71-12" aria-hidden="true" tabindex="-1"></a>   another_enum<span class="at">.seach</span> <span class="kw">{|</span>b<span class="kw">|</span> num1 <span class="kw">&lt;=</span> num1 <span class="kw">+</span> b <span class="kw">}</span></span>
<span id="cb71-13"><a href="#cb71-13" aria-hidden="true" tabindex="-1"></a><span class="cf">end</span></span></code></pre></div>
<p>That’s all that we will explain here, the remaining is exactly like
Ruby. Moreover, almost all the methods related to enumerable and
enumerator have been reimplemented in HDLRuby using the prefix
<code>s</code>, so please refer to the main documentation of HDLRuby
about <a href="README.md#enumerator">enumerators</a> for details. Let us
just see a few examples:</p>
<ul>
<li><p>Count the number of 1 bit of a signal - again - but within an
infinite loop, and with a much shorter code using the HDLRuby version of
the Ruby enumerator method <code>reduce</code>:</p>
<div class="sourceCode" id="cb72"><pre
class="sourceCode ruby"><code class="sourceCode ruby"><span id="cb72-1"><a href="#cb72-1" aria-hidden="true" tabindex="-1"></a>input <span class="wa">:clk</span>,<span class="wa">:start</span></span>
<span id="cb72-2"><a href="#cb72-2" aria-hidden="true" tabindex="-1"></a><span class="kw">[</span><span class="dv">8</span><span class="kw">]</span><span class="at">.input</span> <span class="wa">:sin</span></span>
<span id="cb72-3"><a href="#cb72-3" aria-hidden="true" tabindex="-1"></a><span class="kw">[</span><span class="dv">4</span><span class="kw">]</span><span class="at">.output</span> <span class="wa">:sout</span></span>
<span id="cb72-4"><a href="#cb72-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb72-5"><a href="#cb72-5" aria-hidden="true" tabindex="-1"></a>sequencer(clk,start) <span class="cf">do</span></span>
<span id="cb72-6"><a href="#cb72-6" aria-hidden="true" tabindex="-1"></a>   sloop <span class="cf">do</span></span>
<span id="cb72-7"><a href="#cb72-7" aria-hidden="true" tabindex="-1"></a>      sout <span class="kw">&lt;=</span> sin<span class="at">.sreduce</span>(_h0,<span class="kw">&amp;</span>:<span class="kw">+</span>)</span>
<span id="cb72-8"><a href="#cb72-8" aria-hidden="true" tabindex="-1"></a>   <span class="cf">end</span></span>
<span id="cb72-9"><a href="#cb72-9" aria-hidden="true" tabindex="-1"></a><span class="cf">end</span></span></code></pre></div>
<p>Here are a couple of remarks about this code:</p>
<ul>
<li><p>You may have noticed that the initial value of reduce is set to a
4-bit 0 (<code>_h0</code>, since a hexadecimal digit is 4-bit). If this
value is not set, the data type of the elements will be used for the
additions, in this case, 1-bit (and a 1-bit addition is actually an
exclusive or).</p></li>
<li><p>While the count of the bits is a single-line statement, it is
executed like a usual sequencer loop and therefore requires 8 clock
cycles to complete.</p></li>
</ul></li>
<li><p>Fill array <code>ar</code> from input <code>sin</code> one byte
per cycle then sort it and output its content one byte per cycle.</p>
<div class="sourceCode" id="cb73"><pre
class="sourceCode ruby"><code class="sourceCode ruby"><span id="cb73-1"><a href="#cb73-1" aria-hidden="true" tabindex="-1"></a>input <span class="wa">:clk</span>,<span class="wa">:start</span></span>
<span id="cb73-2"><a href="#cb73-2" aria-hidden="true" tabindex="-1"></a><span class="kw">[</span><span class="dv">8</span><span class="kw">]</span><span class="at">.input</span> <span class="wa">:sin</span></span>
<span id="cb73-3"><a href="#cb73-3" aria-hidden="true" tabindex="-1"></a><span class="kw">[</span><span class="dv">8</span><span class="kw">]</span><span class="at">.output</span> <span class="wa">:sout</span></span>
<span id="cb73-4"><a href="#cb73-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb73-5"><a href="#cb73-5" aria-hidden="true" tabindex="-1"></a>bit<span class="kw">[</span><span class="dv">8</span><span class="kw">][-</span><span class="dv">16</span><span class="kw">]</span><span class="at">.inner</span> <span class="wa">:ar</span></span>
<span id="cb73-6"><a href="#cb73-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb73-7"><a href="#cb73-7" aria-hidden="true" tabindex="-1"></a>sequencer(clk,start) <span class="cf">do</span></span>
<span id="cb73-8"><a href="#cb73-8" aria-hidden="true" tabindex="-1"></a>   <span class="dv">16</span><span class="at">.stimes</span> <span class="kw">{|</span>i<span class="kw">|</span> ar<span class="kw">[</span>i<span class="kw">]</span> <span class="kw">&lt;=</span> sin <span class="kw">}</span></span>
<span id="cb73-9"><a href="#cb73-9" aria-hidden="true" tabindex="-1"></a>   res <span class="kw">=</span> ar<span class="at">.ssort</span></span>
<span id="cb73-10"><a href="#cb73-10" aria-hidden="true" tabindex="-1"></a>   <span class="dv">16</span><span class="at">.stimes</span> <span class="kw">{|</span>i<span class="kw">|</span> sout <span class="kw">&lt;=</span> res<span class="kw">[</span>i<span class="kw">]</span> <span class="kw">}</span></span>
<span id="cb73-11"><a href="#cb73-11" aria-hidden="true" tabindex="-1"></a><span class="cf">end</span></span></code></pre></div>
<p>In this example, <code>16.stimes</code> generates an enumerator over
the <code>0..7</code> range, and is a way to build an enumerator from an
integer value. In addition, please notice the use of the Ruby variable
<code>res</code> for accessing the signal containing the sort
result.</p></li>
<li><p>Apply a 4-point FIR filter over an array obtained from input
signal <code>sin</code> with 0-padding at the beginning and output the
result to <code>sout</code></p>
<div class="sourceCode" id="cb74"><pre
class="sourceCode ruby"><code class="sourceCode ruby"><span id="cb74-1"><a href="#cb74-1" aria-hidden="true" tabindex="-1"></a>input <span class="wa">:clk</span>,<span class="wa">:start</span></span>
<span id="cb74-2"><a href="#cb74-2" aria-hidden="true" tabindex="-1"></a><span class="kw">[</span><span class="dv">8</span><span class="kw">]</span><span class="at">.input</span> <span class="wa">:sin</span></span>
<span id="cb74-3"><a href="#cb74-3" aria-hidden="true" tabindex="-1"></a><span class="kw">[</span><span class="dv">8</span><span class="kw">]</span><span class="at">.output</span> <span class="wa">:sout</span></span>
<span id="cb74-4"><a href="#cb74-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb74-5"><a href="#cb74-5" aria-hidden="true" tabindex="-1"></a>bit<span class="kw">[</span><span class="dv">8</span><span class="kw">][-</span><span class="dv">4</span><span class="kw">]</span><span class="at">.inner</span> <span class="wa">coefs: </span><span class="kw">[</span>_h01,_h05,_h0A,_hFE<span class="kw">]</span></span>
<span id="cb74-6"><a href="#cb74-6" aria-hidden="true" tabindex="-1"></a>bit<span class="kw">[</span><span class="dv">8</span><span class="kw">][-</span><span class="dv">16</span><span class="kw">]</span><span class="at">.inner</span> : ar</span>
<span id="cb74-7"><a href="#cb74-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb74-8"><a href="#cb74-8" aria-hidden="true" tabindex="-1"></a>sequencer(clk,start) <span class="cf">do</span></span>
<span id="cb74-9"><a href="#cb74-9" aria-hidden="true" tabindex="-1"></a>   <span class="dv">16</span><span class="at">.stime</span> <span class="kw">{|</span>i<span class="kw">|</span> ar<span class="kw">[</span>i<span class="kw">]</span> <span class="kw">&lt;=</span> sin <span class="kw">}</span></span>
<span id="cb74-10"><a href="#cb74-10" aria-hidden="true" tabindex="-1"></a>   sout <span class="kw">&lt;=</span> (<span class="kw">[</span>_h00<span class="kw">]*</span><span class="dv">3</span>)<span class="at">.seach</span> <span class="kw">+</span> ar<span class="at">.seach</span>)<span class="at">.seach_slice</span>(<span class="dv">4</span>)<span class="at">.sreduce</span>(_h00) <span class="cf">do</span> <span class="kw">|</span>a,b,c,d<span class="kw">|</span></span>
<span id="cb74-11"><a href="#cb74-11" aria-hidden="true" tabindex="-1"></a>      a<span class="kw">*</span>coefs<span class="kw">[</span><span class="dv">0</span><span class="kw">]</span> <span class="kw">+</span> b <span class="kw">*</span> coefs<span class="kw">[</span><span class="dv">1</span><span class="kw">]</span> <span class="kw">+</span> c <span class="kw">*</span> coefs<span class="kw">[</span><span class="dv">2</span><span class="kw">]</span> <span class="kw">+</span> d <span class="kw">*</span> coefs<span class="kw">[</span><span class="dv">3</span><span class="kw">]</span></span>
<span id="cb74-12"><a href="#cb74-12" aria-hidden="true" tabindex="-1"></a>   <span class="cf">end</span></span>
<span id="cb74-13"><a href="#cb74-13" aria-hidden="true" tabindex="-1"></a><span class="cf">end</span></span></code></pre></div>
<p>In this example, <code>[_h00]*3</code> builds an array of three 8-bit
zeros for the padding, <code>seach</code> creates the iterators over
this padding. This iterator is added to one over <code>ar</code> which
creates a global iterator over them all. <code>seach_slice</code> and
<code>sreduce</code> work the same way their Ruby equivalent
<code>each_slice</code> and <code>reduce</code> do. Here, since the
result is a single byte, it is directly assigned to the output
<code>sout</code>, but the following could also have been possible:</p>
<div class="sourceCode" id="cb75"><pre
class="sourceCode ruby"><code class="sourceCode ruby"><span id="cb75-1"><a href="#cb75-1" aria-hidden="true" tabindex="-1"></a>input <span class="wa">:clk</span>,<span class="wa">:start</span></span>
<span id="cb75-2"><a href="#cb75-2" aria-hidden="true" tabindex="-1"></a><span class="kw">[</span><span class="dv">8</span><span class="kw">]</span><span class="at">.input</span> <span class="wa">:sin</span></span>
<span id="cb75-3"><a href="#cb75-3" aria-hidden="true" tabindex="-1"></a><span class="kw">[</span><span class="dv">8</span><span class="kw">]</span><span class="at">.output</span> <span class="wa">:sout</span></span>
<span id="cb75-4"><a href="#cb75-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb75-5"><a href="#cb75-5" aria-hidden="true" tabindex="-1"></a>bit<span class="kw">[</span><span class="dv">8</span><span class="kw">][-</span><span class="dv">4</span><span class="kw">]</span><span class="at">.inner</span> <span class="wa">coefs: </span><span class="kw">[</span>_h01,_h05,_h0A,_hFE<span class="kw">]</span></span>
<span id="cb75-6"><a href="#cb75-6" aria-hidden="true" tabindex="-1"></a>bit<span class="kw">[</span><span class="dv">8</span><span class="kw">][-</span><span class="dv">16</span><span class="kw">]</span><span class="at">.inner</span> : ar</span>
<span id="cb75-7"><a href="#cb75-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb75-8"><a href="#cb75-8" aria-hidden="true" tabindex="-1"></a>res <span class="kw">=</span> <span class="dv">nil</span></span>
<span id="cb75-9"><a href="#cb75-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb75-10"><a href="#cb75-10" aria-hidden="true" tabindex="-1"></a>sequencer(clk,start) <span class="cf">do</span></span>
<span id="cb75-11"><a href="#cb75-11" aria-hidden="true" tabindex="-1"></a>   <span class="dv">16</span><span class="at">.stime</span> <span class="kw">{|</span>i<span class="kw">|</span> ar<span class="kw">[</span>i<span class="kw">]</span> <span class="kw">&lt;=</span> sin <span class="kw">}</span></span>
<span id="cb75-12"><a href="#cb75-12" aria-hidden="true" tabindex="-1"></a>   res <span class="kw">=</span> (<span class="kw">[</span>_h00<span class="kw">]*</span><span class="dv">3</span>)<span class="at">.seach</span> <span class="kw">+</span> ar<span class="at">.seach</span>)<span class="at">.seach_slice</span>(<span class="dv">4</span>)<span class="at">.sreduce</span>(_h00) <span class="cf">do</span> <span class="kw">|</span>a,b,c,d<span class="kw">|</span></span>
<span id="cb75-13"><a href="#cb75-13" aria-hidden="true" tabindex="-1"></a>      a<span class="kw">*</span>coefs<span class="kw">[</span><span class="dv">0</span><span class="kw">]</span> <span class="kw">+</span> b <span class="kw">*</span> coefs<span class="kw">[</span><span class="dv">1</span><span class="kw">]</span> <span class="kw">+</span> c <span class="kw">*</span> coefs<span class="kw">[</span><span class="dv">2</span><span class="kw">]</span> <span class="kw">+</span> d <span class="kw">*</span> coefs<span class="kw">[</span><span class="dv">3</span><span class="kw">]</span></span>
<span id="cb75-14"><a href="#cb75-14" aria-hidden="true" tabindex="-1"></a>   <span class="cf">end</span></span>
<span id="cb75-15"><a href="#cb75-15" aria-hidden="true" tabindex="-1"></a><span class="cf">end</span></span>
<span id="cb75-16"><a href="#cb75-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb75-17"><a href="#cb75-17" aria-hidden="true" tabindex="-1"></a>sout <span class="kw">&lt;=</span> res</span></code></pre></div>
<p>Please notice that since the Ruby variable <code>res</code> is used
outside the sequencer, it must also be declared outside
(<code>res = nil</code>).</p></li>
</ul>
<h4 id="create-your-enumerator.">Create your enumerator.</h4>
<p>The method <code>seach</code> and its derivates make it possible to
iterate over signals or other enumerable objects. But you can also
create your enumerator that can iterate on whatever you want and the way
you want. For that purpose, please use the following command:</p>
<div class="sourceCode" id="cb76"><pre
class="sourceCode ruby"><code class="sourceCode ruby"><span id="cb76-1"><a href="#cb76-1" aria-hidden="true" tabindex="-1"></a><span class="kw">&lt;</span>variable<span class="kw">&gt;</span> <span class="kw">=</span> senumerator(<span class="kw">&lt;</span>element type<span class="kw">&gt;</span>, <span class="kw">&lt;</span>number of elements<span class="kw">&gt;</span>) <span class="kw">&lt;</span>block<span class="kw">&gt;</span></span></code></pre></div>
<p>Where <code>block</code> is a block of sequencer code for accessing
an element by index. For example, the following defines the enumerator
named <code>enum0</code> enumerating over the 100 first square numbers
in 32-bit:</p>
<div class="sourceCode" id="cb77"><pre
class="sourceCode ruby"><code class="sourceCode ruby"><span id="cb77-1"><a href="#cb77-1" aria-hidden="true" tabindex="-1"></a>enum0 <span class="kw">=</span> senumerator(bit<span class="kw">[</span><span class="dv">32</span><span class="kw">]</span>,<span class="dv">100</span>) <span class="kw">{|</span>i<span class="kw">|</span> i<span class="kw">*</span>i <span class="kw">}</span></span></code></pre></div>
<p>It is also possible to put a sequencer control statement in the
access block, for example, the following enumerator accesses each bit of
signal x waiting for 2 cycles between each access:</p>
<div class="sourceCode" id="cb78"><pre
class="sourceCode ruby"><code class="sourceCode ruby"><span id="cb78-1"><a href="#cb78-1" aria-hidden="true" tabindex="-1"></a><span class="kw">[</span><span class="dv">128</span><span class="kw">]</span><span class="at">.input</span> <span class="wa">:x</span></span>
<span id="cb78-2"><a href="#cb78-2" aria-hidden="true" tabindex="-1"></a>enum1 <span class="kw">=</span> senumerator(bit,x<span class="at">.width</span>) <span class="cf">do</span> <span class="kw">|</span>i<span class="kw">|</span></span>
<span id="cb78-3"><a href="#cb78-3" aria-hidden="true" tabindex="-1"></a>   step</span>
<span id="cb78-4"><a href="#cb78-4" aria-hidden="true" tabindex="-1"></a>   step</span>
<span id="cb78-5"><a href="#cb78-5" aria-hidden="true" tabindex="-1"></a>   x<span class="kw">[</span>i<span class="kw">]</span></span>
<span id="cb78-6"><a href="#cb78-6" aria-hidden="true" tabindex="-1"></a><span class="cf">end</span></span></code></pre></div>
<hr />
<p>Now you know:</p>
<ul>
<li><p>You create enumerators.</p></li>
<li><p>How to use enumerators for easily building complex
algorithms.</p></li>
<li><p>How to create your enumerators.</p></li>
</ul>
<p>And with that, you may be able to build sequential hardware almost as
easily as software. But why bother? Simply because the performance of
the resulting hardware is much better than that of software, at least in
terms of energy and/or power consumption.</p>
<p>But this is not all: contrary to software, hardware is inherently
parallel, a property that has not been considered at all yet. From now
on, that will be the main topic of this tutorial. We will start slowly
by studying what happens when there are several sequencers.</p>
<h4 id="what-happens-when-there-are-several-sequencers">3.2.5. What
happens when there are several sequencers?</h4>
<h4 id="general-considerations">General considerations</h4>
<p>You can have as many sequencers as you want in a module, and of
course, you can have as many modules as you want in a circuit
description. In total, all these sequencers will run independently of
one another and in parallel. Furthermore, these parallel sequencers can
be controlled by the same clock and start signals or by different
ones.</p>
<p>As long as the sequencers do not access the same signals, they will
not interfere with one another and what has been explained up to now is
enough. However, it is common that the various parts of a circuit
cooperate, and therefore exchange information, i.e., access common
signals. There are two ways to handle access to the same signal from
several sequencers…</p>
<h4 id="the-easy-way-stick-to-a-simple-rule">The easy way: stick to a
simple rule</h4>
<p>There is a simple rule to follow in hardware design to avoid any
trouble when accessing a signal:</p>
<blockquote>
<p>A signal can be read from anywhere at any time, but only one
component (e.g., a port connection or a sequencer) can write to a given
signal.</p>
</blockquote>
<p>This rule is not absolute as you will see in the <a
href="#the-hard-way-arbitrating-between-writes-to-signals">hard way</a>
to access signals, but it has the advantage of not requiring any
additional hardware construct to be implemented. Hence, we do recommend
following this rule as much as possible.</p>
<p>Let us see an example for understanding how several sequencers can
interact while following this rule. First, let us consider a sequencer
that increases periodically a value and sends it to another sequencer
that will count the number of bits of this value and tell the first one
to proceed with the increase:</p>
<div class="sourceCode" id="cb79"><pre
class="sourceCode ruby"><code class="sourceCode ruby"><span id="cb79-1"><a href="#cb79-1" aria-hidden="true" tabindex="-1"></a><span class="fu">system</span> <span class="wa">:bit_pong</span> <span class="cf">do</span></span>
<span id="cb79-2"><a href="#cb79-2" aria-hidden="true" tabindex="-1"></a>   inner <span class="wa">:clk</span>,<span class="wa">:start</span></span>
<span id="cb79-3"><a href="#cb79-3" aria-hidden="true" tabindex="-1"></a>   inner <span class="wa">:req</span>, <span class="wa">:ack</span></span>
<span id="cb79-4"><a href="#cb79-4" aria-hidden="true" tabindex="-1"></a>   <span class="kw">[</span><span class="dv">4</span><span class="kw">]</span><span class="at">.inner</span> <span class="wa">:value</span></span>
<span id="cb79-5"><a href="#cb79-5" aria-hidden="true" tabindex="-1"></a>   <span class="kw">[</span><span class="dv">3</span><span class="kw">]</span><span class="at">.inner</span> <span class="wa">:count</span></span>
<span id="cb79-6"><a href="#cb79-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb79-7"><a href="#cb79-7" aria-hidden="true" tabindex="-1"></a>   sequencer(clk,start) <span class="cf">do</span></span>
<span id="cb79-8"><a href="#cb79-8" aria-hidden="true" tabindex="-1"></a>      req <span class="kw">&lt;=</span> <span class="dv">0</span></span>
<span id="cb79-9"><a href="#cb79-9" aria-hidden="true" tabindex="-1"></a>      value <span class="kw">&lt;=</span> <span class="dv">0</span></span>
<span id="cb79-10"><a href="#cb79-10" aria-hidden="true" tabindex="-1"></a>      sloop <span class="cf">do</span></span>
<span id="cb79-11"><a href="#cb79-11" aria-hidden="true" tabindex="-1"></a>         req <span class="kw">&lt;=</span> <span class="dv">1</span></span>
<span id="cb79-12"><a href="#cb79-12" aria-hidden="true" tabindex="-1"></a>         swhile(ack !<span class="kw">=</span> <span class="dv">1</span>)</span>
<span id="cb79-13"><a href="#cb79-13" aria-hidden="true" tabindex="-1"></a>         value <span class="kw">&lt;=</span> value <span class="kw">+</span> <span class="dv">1</span></span>
<span id="cb79-14"><a href="#cb79-14" aria-hidden="true" tabindex="-1"></a>         req <span class="kw">&lt;=</span> <span class="dv">0</span></span>
<span id="cb79-15"><a href="#cb79-15" aria-hidden="true" tabindex="-1"></a>      <span class="cf">end</span></span>
<span id="cb79-16"><a href="#cb79-16" aria-hidden="true" tabindex="-1"></a>   <span class="cf">end</span></span>
<span id="cb79-17"><a href="#cb79-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb79-18"><a href="#cb79-18" aria-hidden="true" tabindex="-1"></a>   sequencer(clk,start) <span class="cf">do</span></span>
<span id="cb79-19"><a href="#cb79-19" aria-hidden="true" tabindex="-1"></a>      ack <span class="kw">&lt;=</span> <span class="dv">0</span></span>
<span id="cb79-20"><a href="#cb79-20" aria-hidden="true" tabindex="-1"></a>      count <span class="kw">&lt;=</span> <span class="dv">0</span></span>
<span id="cb79-21"><a href="#cb79-21" aria-hidden="true" tabindex="-1"></a>      sloop <span class="cf">do</span></span>
<span id="cb79-22"><a href="#cb79-22" aria-hidden="true" tabindex="-1"></a>         ack <span class="kw">&lt;=</span> <span class="dv">0</span></span>
<span id="cb79-23"><a href="#cb79-23" aria-hidden="true" tabindex="-1"></a>         swhile(req !<span class="kw">=</span> <span class="dv">1</span>)</span>
<span id="cb79-24"><a href="#cb79-24" aria-hidden="true" tabindex="-1"></a>         count <span class="kw">&lt;=</span> value<span class="at">.sreduce</span>(_h0,:<span class="kw">+</span>)</span>
<span id="cb79-25"><a href="#cb79-25" aria-hidden="true" tabindex="-1"></a>         ack <span class="kw">&lt;=</span> <span class="dv">1</span></span>
<span id="cb79-26"><a href="#cb79-26" aria-hidden="true" tabindex="-1"></a>      <span class="cf">end</span></span>
<span id="cb79-27"><a href="#cb79-27" aria-hidden="true" tabindex="-1"></a>   <span class="cf">end</span></span>
<span id="cb79-28"><a href="#cb79-28" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb79-29"><a href="#cb79-29" aria-hidden="true" tabindex="-1"></a>   <span class="cf">def</span> clk!</span>
<span id="cb79-30"><a href="#cb79-30" aria-hidden="true" tabindex="-1"></a>      !<span class="dv">10</span><span class="at">.ns</span></span>
<span id="cb79-31"><a href="#cb79-31" aria-hidden="true" tabindex="-1"></a>      clk <span class="kw">&lt;=</span> <span class="dv">1</span></span>
<span id="cb79-32"><a href="#cb79-32" aria-hidden="true" tabindex="-1"></a>      !<span class="dv">10</span><span class="at">.ns</span></span>
<span id="cb79-33"><a href="#cb79-33" aria-hidden="true" tabindex="-1"></a>      clk <span class="kw">&lt;=</span> <span class="dv">0</span></span>
<span id="cb79-34"><a href="#cb79-34" aria-hidden="true" tabindex="-1"></a>   <span class="cf">end</span></span>
<span id="cb79-35"><a href="#cb79-35" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb79-36"><a href="#cb79-36" aria-hidden="true" tabindex="-1"></a>   timed <span class="cf">do</span></span>
<span id="cb79-37"><a href="#cb79-37" aria-hidden="true" tabindex="-1"></a>      clk   <span class="kw">&lt;=</span> <span class="dv">0</span></span>
<span id="cb79-38"><a href="#cb79-38" aria-hidden="true" tabindex="-1"></a>      start <span class="kw">&lt;=</span> <span class="dv">0</span></span>
<span id="cb79-39"><a href="#cb79-39" aria-hidden="true" tabindex="-1"></a>      clk!</span>
<span id="cb79-40"><a href="#cb79-40" aria-hidden="true" tabindex="-1"></a>      start <span class="kw">&lt;=</span> <span class="dv">1</span></span>
<span id="cb79-41"><a href="#cb79-41" aria-hidden="true" tabindex="-1"></a>      clk!</span>
<span id="cb79-42"><a href="#cb79-42" aria-hidden="true" tabindex="-1"></a>      start <span class="kw">&lt;=</span> <span class="dv">0</span></span>
<span id="cb79-43"><a href="#cb79-43" aria-hidden="true" tabindex="-1"></a>      repeat(<span class="dv">100</span>) <span class="kw">{</span> clk! <span class="kw">}</span></span>
<span id="cb79-44"><a href="#cb79-44" aria-hidden="true" tabindex="-1"></a>   <span class="cf">end</span></span>
<span id="cb79-45"><a href="#cb79-45" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb79-46"><a href="#cb79-46" aria-hidden="true" tabindex="-1"></a><span class="cf">end</span></span></code></pre></div>
<p>If you write this code in a file named <code>bit_pong.rb</code> and
simulate it as follows:</p>
<div class="sourceCode" id="cb80"><pre
class="sourceCode bash"><code class="sourceCode bash"><span id="cb80-1"><a href="#cb80-1" aria-hidden="true" tabindex="-1"></a><span class="ex">hdrcc</span> <span class="at">--sim</span> <span class="at">--vcd</span> bit_pong.rb bit_pong</span></code></pre></div>
<p>You will obtain the following kind of time chart:</p>
<p align="center">
<img data-name="hruby_simulator.vcd" src="bit_pong_vcd.png"  width="80%">
</p>
<p>You may notice a detail that is crucial in hardware: the increase of
<code>value</code> by the first sequencer starts not when
<code>ack</code> becomes 1, but the next clock cycle. This is the second
important rule in hardware design:</p>
<blockquote>
<p>When a signal is read in a clock-synchronized component (e.g., a
sequencer), the real value is not the value of the signal at this exact
instant, but the one it has a little while before. This is because
hardware implementation of signals takes physical time to propagate.</p>
</blockquote>
<p>With this simple rule and enough training, one can easily and
efficiently implement a large range of applications. But a few cases do
require several components (e.g., sequencers) to write to the same
signal. For example, when a resource must be shared among several
components. Let us see what can be done in such cases.</p>
<h4 id="the-hard-way-arbitrating-between-writes-to-signals">The hard
way: arbitrating between writes to signals</h4>
<p>The problem when several components write to the same signal is
handling the cases where different values are assigned at the
<em>same</em> time. This requires extra arbitration circuitry that must
be described by the designer or generated by the synthesis tool. Since
there is no general good way of arbitrating, the first option is the
most common, but with HDLRuby’s sequencer, there is an intermediate
solution that does not require designing a new circuit but still lets
the designer control the arbitration. It is this approach that is
explained here, for the design from scratch of an arbitration please
consult tutorials about advanced RTL design.</p>
<h4 id="the-hard-way-but-not-so-much-shared-signals">The hard way but
not so much: shared signals</h4>
<p>The HDLRuby sequencer supports another kind of signal called the
<em>shared signals</em>. They are inner signals of a module that can be
written to by any number of sequencers without causing any trouble. They
are declared like any other inner signals, but using the
<code>shared</code> keyword instead of <code>inner</code>. For example,
a shared 8-bit signed signal named <code>sh</code> can be declared as
follows:</p>
<div class="sourceCode" id="cb81"><pre
class="sourceCode ruby"><code class="sourceCode ruby"><span id="cb81-1"><a href="#cb81-1" aria-hidden="true" tabindex="-1"></a>signed<span class="kw">[</span><span class="dv">8</span><span class="kw">]</span><span class="at">.shared</span> <span class="wa">:sh</span></span></code></pre></div>
<p>After being declared, shared signals can be used exactly like any
other inner signals, but without any restriction when written within a
sequencer.</p>
<h4 id="but-what-about-the-arbitration">But what about the
arbitration?</h4>
<p>By default, the arbitration when writing to a shared signal is blunt:
the first declared sequencer that writes to this signal is <strong>the
only one</strong> that changes its value. The other sequencers’ writes
are simply ignored. For example, in the following, code, the value of
<code>sh</code> is 55, whatever the second sequencer does:</p>
<div class="sourceCode" id="cb82"><pre
class="sourceCode ruby"><code class="sourceCode ruby"><span id="cb82-1"><a href="#cb82-1" aria-hidden="true" tabindex="-1"></a>signed<span class="kw">[</span><span class="dv">8</span><span class="kw">]</span><span class="at">.shared</span> <span class="wa">:sh</span></span>
<span id="cb82-2"><a href="#cb82-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb82-3"><a href="#cb82-3" aria-hidden="true" tabindex="-1"></a>sequencer(clk,start) <span class="cf">do</span></span>
<span id="cb82-4"><a href="#cb82-4" aria-hidden="true" tabindex="-1"></a>   sh <span class="kw">&lt;=</span> <span class="dv">55</span></span>
<span id="cb82-5"><a href="#cb82-5" aria-hidden="true" tabindex="-1"></a><span class="cf">end</span></span>
<span id="cb82-6"><a href="#cb82-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb82-7"><a href="#cb82-7" aria-hidden="true" tabindex="-1"></a>sequencer(clk,start) <span class="cf">do</span></span>
<span id="cb82-8"><a href="#cb82-8" aria-hidden="true" tabindex="-1"></a>   <span class="dv">100</span><span class="at">.stimes</span> <span class="kw">{</span> <span class="kw">|</span>i<span class="kw">|</span> sh <span class="kw">&lt;=</span> i <span class="kw">}</span></span>
<span id="cb82-9"><a href="#cb82-9" aria-hidden="true" tabindex="-1"></a><span class="cf">end</span></span></code></pre></div>
<p>This is not so useful that way, but you can control that by setting
which sequencer has exclusive access using the <code>select</code>
method of a shared signal. For example, in the following code, the first
sequencer first writes 55 to <code>sh</code> but then gives access to
the second one:</p>
<div class="sourceCode" id="cb83"><pre
class="sourceCode ruby"><code class="sourceCode ruby"><span id="cb83-1"><a href="#cb83-1" aria-hidden="true" tabindex="-1"></a>signal<span class="kw">[</span><span class="dv">8</span><span class="kw">]</span><span class="at">.shared</span> <span class="wa">:sh</span></span>
<span id="cb83-2"><a href="#cb83-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb83-3"><a href="#cb83-3" aria-hidden="true" tabindex="-1"></a>sequencer(clk,start) <span class="cf">do</span></span>
<span id="cb83-4"><a href="#cb83-4" aria-hidden="true" tabindex="-1"></a>   sh <span class="kw">&lt;=</span> <span class="dv">55</span></span>
<span id="cb83-5"><a href="#cb83-5" aria-hidden="true" tabindex="-1"></a>   sh<span class="at">.select</span> <span class="kw">&lt;=</span> <span class="dv">1</span></span>
<span id="cb83-6"><a href="#cb83-6" aria-hidden="true" tabindex="-1"></a><span class="cf">end</span></span>
<span id="cb83-7"><a href="#cb83-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb83-8"><a href="#cb83-8" aria-hidden="true" tabindex="-1"></a>sequencer(clk,start) <span class="cf">do</span></span>
<span id="cb83-9"><a href="#cb83-9" aria-hidden="true" tabindex="-1"></a>  <span class="dv">100</span><span class="at">.stimes</span> <span class="kw">{</span> <span class="kw">|</span>i<span class="kw">|</span> sh <span class="kw">&lt;=</span> i <span class="kw">}</span></span>
<span id="cb83-10"><a href="#cb83-10" aria-hidden="true" tabindex="-1"></a><span class="cf">end</span></span></code></pre></div>
<p>With this code, the value of <code>sh</code> will be at each clock:
55, 1, 2, 3,…</p>
<p>This is simple enough, right? However, there is a limitation: only
one sequencer can access to the <code>select</code> of a shared signal…
Otherwise, another layer of arbitration is required and we are back to
the beginning. Often, this is all right, but sometimes, complex
arbitration between several sequencers and several signals makes things
messy.</p>
<h4 id="enter-the-global-arbiters">Enter the global arbiters</h4>
<p>So, you have multiple sequencers fighting with one another for
accessing several shared signals, what to do? You need a global arbiter
that will decide for everyone. The sequencer library provides such a
module, named <code>arbiter</code> that is instantiated like any module.
However, it does not have any specific port, instead, it must be
connected to the shared signals it will arbitrate. For example, an
arbiter named <code>arb01</code> controlling shared signals
<code>sh0</code> and <code>sh1</code> can be declared as follows:</p>
<div class="sourceCode" id="cb84"><pre
class="sourceCode ruby"><code class="sourceCode ruby"><span id="cb84-1"><a href="#cb84-1" aria-hidden="true" tabindex="-1"></a>arbiter(<span class="wa">:arb01</span>)<span class="kw">.</span>(sh0,sh1)</span></code></pre></div>
<p>Then, when a sequencer wants to write to either <code>sh0</code> or
<code>sh1</code> it must ask the right by sending 1 to the arbiter, and
when the access is done, it must release that right by sending 0 so that
it does not monopolize the signal. For example, the following sequencers
write in turn to the 2-bit shared signal <code>pingpong</code>:</p>
<div class="sourceCode" id="cb85"><pre
class="sourceCode ruby"><code class="sourceCode ruby"><span id="cb85-1"><a href="#cb85-1" aria-hidden="true" tabindex="-1"></a><span class="fu">system</span> <span class="wa">:pingpong</span> <span class="cf">do</span></span>
<span id="cb85-2"><a href="#cb85-2" aria-hidden="true" tabindex="-1"></a>   inner <span class="wa">:clk</span>, <span class="wa">:start</span></span>
<span id="cb85-3"><a href="#cb85-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb85-4"><a href="#cb85-4" aria-hidden="true" tabindex="-1"></a>   <span class="kw">[</span><span class="dv">2</span><span class="kw">]</span><span class="at">.shared</span> <span class="wa">:pingpong</span></span>
<span id="cb85-5"><a href="#cb85-5" aria-hidden="true" tabindex="-1"></a>   arbiter(<span class="wa">:arb</span>)<span class="kw">.</span>(pingpong)</span>
<span id="cb85-6"><a href="#cb85-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb85-7"><a href="#cb85-7" aria-hidden="true" tabindex="-1"></a>   sequencer(clk,start) <span class="cf">do</span></span>
<span id="cb85-8"><a href="#cb85-8" aria-hidden="true" tabindex="-1"></a>      sloop <span class="cf">do</span></span>
<span id="cb85-9"><a href="#cb85-9" aria-hidden="true" tabindex="-1"></a>        arb <span class="kw">&lt;=</span> <span class="dv">1</span></span>
<span id="cb85-10"><a href="#cb85-10" aria-hidden="true" tabindex="-1"></a>        pingpong <span class="kw">&lt;=</span> <span class="dv">1</span></span>
<span id="cb85-11"><a href="#cb85-11" aria-hidden="true" tabindex="-1"></a>        step</span>
<span id="cb85-12"><a href="#cb85-12" aria-hidden="true" tabindex="-1"></a>        arb <span class="kw">&lt;=</span> <span class="dv">0</span></span>
<span id="cb85-13"><a href="#cb85-13" aria-hidden="true" tabindex="-1"></a>      <span class="cf">end</span></span>
<span id="cb85-14"><a href="#cb85-14" aria-hidden="true" tabindex="-1"></a>   <span class="cf">end</span></span>
<span id="cb85-15"><a href="#cb85-15" aria-hidden="true" tabindex="-1"></a>   </span>
<span id="cb85-16"><a href="#cb85-16" aria-hidden="true" tabindex="-1"></a>   sequencer(clk,start) <span class="cf">do</span></span>
<span id="cb85-17"><a href="#cb85-17" aria-hidden="true" tabindex="-1"></a>      sloop <span class="cf">do</span></span>
<span id="cb85-18"><a href="#cb85-18" aria-hidden="true" tabindex="-1"></a>        arb <span class="kw">&lt;=</span> <span class="dv">1</span></span>
<span id="cb85-19"><a href="#cb85-19" aria-hidden="true" tabindex="-1"></a>        pingpong <span class="kw">&lt;=</span> <span class="dv">2</span></span>
<span id="cb85-20"><a href="#cb85-20" aria-hidden="true" tabindex="-1"></a>        step</span>
<span id="cb85-21"><a href="#cb85-21" aria-hidden="true" tabindex="-1"></a>        arb <span class="kw">&lt;=</span> <span class="dv">0</span></span>
<span id="cb85-22"><a href="#cb85-22" aria-hidden="true" tabindex="-1"></a>      <span class="cf">end</span></span>
<span id="cb85-23"><a href="#cb85-23" aria-hidden="true" tabindex="-1"></a>   <span class="cf">end</span></span>
<span id="cb85-24"><a href="#cb85-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb85-25"><a href="#cb85-25" aria-hidden="true" tabindex="-1"></a>   timed <span class="cf">do</span></span>
<span id="cb85-26"><a href="#cb85-26" aria-hidden="true" tabindex="-1"></a>      clk   <span class="kw">&lt;=</span> <span class="dv">0</span></span>
<span id="cb85-27"><a href="#cb85-27" aria-hidden="true" tabindex="-1"></a>      start <span class="kw">&lt;=</span> <span class="dv">1</span></span>
<span id="cb85-28"><a href="#cb85-28" aria-hidden="true" tabindex="-1"></a>      !<span class="dv">10</span><span class="at">.ns</span></span>
<span id="cb85-29"><a href="#cb85-29" aria-hidden="true" tabindex="-1"></a>      clk   <span class="kw">&lt;=</span> <span class="dv">1</span></span>
<span id="cb85-30"><a href="#cb85-30" aria-hidden="true" tabindex="-1"></a>      !<span class="dv">10</span><span class="at">.ns</span></span>
<span id="cb85-31"><a href="#cb85-31" aria-hidden="true" tabindex="-1"></a>      clk   <span class="kw">&lt;=</span> <span class="dv">0</span></span>
<span id="cb85-32"><a href="#cb85-32" aria-hidden="true" tabindex="-1"></a>      start <span class="kw">&lt;=</span> <span class="dv">0</span></span>
<span id="cb85-33"><a href="#cb85-33" aria-hidden="true" tabindex="-1"></a>      !<span class="dv">10</span><span class="at">.ns</span></span>
<span id="cb85-34"><a href="#cb85-34" aria-hidden="true" tabindex="-1"></a>      repeat(<span class="dv">20</span>) <span class="kw">{</span> clk <span class="kw">&lt;=</span> <span class="kw">~</span>clk ;<span class="kw"> !</span><span class="dv">10</span><span class="at">.ns</span> <span class="kw">}</span></span>
<span id="cb85-35"><a href="#cb85-35" aria-hidden="true" tabindex="-1"></a>   <span class="cf">end</span></span>
<span id="cb85-36"><a href="#cb85-36" aria-hidden="true" tabindex="-1"></a><span class="cf">end</span></span></code></pre></div>
<p>Now, you should be used to it, so please try to simulate the code
above. If you look at the VCD file in detail you will see a lot of
signals but not any signal called <code>pingpong</code>. This is because
shared signals hide underlining hardware that is exposed at simulation.
Usually, what is relevant is the output value of the shared signal,
which is called
<code>&lt;shared signal name&gt;_out$&lt;number&gt;</code>. For our
<code>pingpong</code> it is <code>pingpong_out$2</code>. Hence, you
should get the following graph:</p>
<p align="center">
<img data-name="hruby_simulator.vcd" src="pingpong0_vcd.png"  width="80%">
</p>
<p>Well, this is not an interesting result: <code>pingpong</code> is
always 1, what about the second sequencer? There are two reasons for
this:</p>
<ul>
<li><p>By default, an arbiter gives priority to sequencers in order of
declaration.</p></li>
<li><p>When a sequencer is denied access, its write access is ignored
and that’s all.</p></li>
</ul>
<p>Here, it happens that both sequencers always write to
<code>pingpong</code> at the exact <em>same</em> time and the first one
has higher priority. For instance, if the second sequencer were delayed
a bit compared to the first one, it would obtain access too:</p>
<div class="sourceCode" id="cb86"><pre
class="sourceCode ruby"><code class="sourceCode ruby"><span id="cb86-1"><a href="#cb86-1" aria-hidden="true" tabindex="-1"></a><span class="fu">system</span> <span class="wa">:pingpong</span> <span class="cf">do</span></span>
<span id="cb86-2"><a href="#cb86-2" aria-hidden="true" tabindex="-1"></a>   inner <span class="wa">:clk</span>, <span class="wa">:start</span></span>
<span id="cb86-3"><a href="#cb86-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb86-4"><a href="#cb86-4" aria-hidden="true" tabindex="-1"></a>   <span class="kw">[</span><span class="dv">2</span><span class="kw">]</span><span class="at">.shared</span> <span class="wa">:pingpong</span></span>
<span id="cb86-5"><a href="#cb86-5" aria-hidden="true" tabindex="-1"></a>   arbiter(<span class="wa">:arb</span>)<span class="kw">.</span>(pingpong)</span>
<span id="cb86-6"><a href="#cb86-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb86-7"><a href="#cb86-7" aria-hidden="true" tabindex="-1"></a>   sequencer(clk,start) <span class="cf">do</span></span>
<span id="cb86-8"><a href="#cb86-8" aria-hidden="true" tabindex="-1"></a>      sloop <span class="cf">do</span></span>
<span id="cb86-9"><a href="#cb86-9" aria-hidden="true" tabindex="-1"></a>        pingpong <span class="kw">&lt;=</span> <span class="dv">1</span></span>
<span id="cb86-10"><a href="#cb86-10" aria-hidden="true" tabindex="-1"></a>        arb <span class="kw">&lt;=</span> <span class="dv">1</span></span>
<span id="cb86-11"><a href="#cb86-11" aria-hidden="true" tabindex="-1"></a>        step</span>
<span id="cb86-12"><a href="#cb86-12" aria-hidden="true" tabindex="-1"></a>        arb <span class="kw">&lt;=</span> <span class="dv">0</span></span>
<span id="cb86-13"><a href="#cb86-13" aria-hidden="true" tabindex="-1"></a>      <span class="cf">end</span></span>
<span id="cb86-14"><a href="#cb86-14" aria-hidden="true" tabindex="-1"></a>   <span class="cf">end</span></span>
<span id="cb86-15"><a href="#cb86-15" aria-hidden="true" tabindex="-1"></a>   </span>
<span id="cb86-16"><a href="#cb86-16" aria-hidden="true" tabindex="-1"></a>   sequencer(clk,start) <span class="cf">do</span></span>
<span id="cb86-17"><a href="#cb86-17" aria-hidden="true" tabindex="-1"></a>      step</span>
<span id="cb86-18"><a href="#cb86-18" aria-hidden="true" tabindex="-1"></a>      sloop <span class="cf">do</span></span>
<span id="cb86-19"><a href="#cb86-19" aria-hidden="true" tabindex="-1"></a>        pingpong <span class="kw">&lt;=</span> <span class="dv">2</span></span>
<span id="cb86-20"><a href="#cb86-20" aria-hidden="true" tabindex="-1"></a>        arb <span class="kw">&lt;=</span> <span class="dv">1</span></span>
<span id="cb86-21"><a href="#cb86-21" aria-hidden="true" tabindex="-1"></a>        step</span>
<span id="cb86-22"><a href="#cb86-22" aria-hidden="true" tabindex="-1"></a>        arb <span class="kw">&lt;=</span> <span class="dv">0</span></span>
<span id="cb86-23"><a href="#cb86-23" aria-hidden="true" tabindex="-1"></a>      <span class="cf">end</span></span>
<span id="cb86-24"><a href="#cb86-24" aria-hidden="true" tabindex="-1"></a>   <span class="cf">end</span></span>
<span id="cb86-25"><a href="#cb86-25" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb86-26"><a href="#cb86-26" aria-hidden="true" tabindex="-1"></a>   timed <span class="cf">do</span></span>
<span id="cb86-27"><a href="#cb86-27" aria-hidden="true" tabindex="-1"></a>      clk   <span class="kw">&lt;=</span> <span class="dv">0</span></span>
<span id="cb86-28"><a href="#cb86-28" aria-hidden="true" tabindex="-1"></a>      start <span class="kw">&lt;=</span> <span class="dv">1</span></span>
<span id="cb86-29"><a href="#cb86-29" aria-hidden="true" tabindex="-1"></a>      !<span class="dv">10</span><span class="at">.ns</span></span>
<span id="cb86-30"><a href="#cb86-30" aria-hidden="true" tabindex="-1"></a>      clk   <span class="kw">&lt;=</span> <span class="dv">1</span></span>
<span id="cb86-31"><a href="#cb86-31" aria-hidden="true" tabindex="-1"></a>      !<span class="dv">10</span><span class="at">.ns</span></span>
<span id="cb86-32"><a href="#cb86-32" aria-hidden="true" tabindex="-1"></a>      clk   <span class="kw">&lt;=</span> <span class="dv">0</span></span>
<span id="cb86-33"><a href="#cb86-33" aria-hidden="true" tabindex="-1"></a>      start <span class="kw">&lt;=</span> <span class="dv">0</span></span>
<span id="cb86-34"><a href="#cb86-34" aria-hidden="true" tabindex="-1"></a>      !<span class="dv">10</span><span class="at">.ns</span></span>
<span id="cb86-35"><a href="#cb86-35" aria-hidden="true" tabindex="-1"></a>      repeat(<span class="dv">20</span>) <span class="kw">{</span> clk <span class="kw">&lt;=</span> <span class="kw">~</span>clk ;<span class="kw"> !</span><span class="dv">10</span><span class="at">.ns</span> <span class="kw">}</span></span>
<span id="cb86-36"><a href="#cb86-36" aria-hidden="true" tabindex="-1"></a>   <span class="cf">end</span></span>
<span id="cb86-37"><a href="#cb86-37" aria-hidden="true" tabindex="-1"></a><span class="cf">end</span></span></code></pre></div>
<p>And the simulation result should be:</p>
<p align="center">
<img data-name="hruby_simulator.vcd" src="pingpong1_vcd.png"  width="80%">
</p>
<p>Still, it may be annoying that some writes of a sequencer can be
ignored. In such a case, you can use a blocking version of the arbiter
called the <code>monitor</code>. This module is used like the arbiter,
but when write access is required, the sequencer will be blocked until
the access is granted. Hence to avoid confusion with the arbiters’
syntax, requiring access to a monitor is done by the <code>lock</code>
method, and releasing it is done by the <code>unlock</code> one. For
example, with the following code, the expected pingpong exchange will
happen even when both sequencers try to write at the same time:</p>
<div class="sourceCode" id="cb87"><pre
class="sourceCode ruby"><code class="sourceCode ruby"><span id="cb87-1"><a href="#cb87-1" aria-hidden="true" tabindex="-1"></a><span class="fu">system</span> <span class="wa">:pingpong</span> <span class="cf">do</span></span>
<span id="cb87-2"><a href="#cb87-2" aria-hidden="true" tabindex="-1"></a>   inner <span class="wa">:clk</span>, <span class="wa">:start</span></span>
<span id="cb87-3"><a href="#cb87-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb87-4"><a href="#cb87-4" aria-hidden="true" tabindex="-1"></a>   <span class="kw">[</span><span class="dv">2</span><span class="kw">]</span><span class="at">.shared</span> <span class="wa">:pingpong</span></span>
<span id="cb87-5"><a href="#cb87-5" aria-hidden="true" tabindex="-1"></a>   monitor(<span class="wa">:arb</span>)<span class="kw">.</span>(pingpong)</span>
<span id="cb87-6"><a href="#cb87-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb87-7"><a href="#cb87-7" aria-hidden="true" tabindex="-1"></a>   sequencer(clk,start) <span class="cf">do</span></span>
<span id="cb87-8"><a href="#cb87-8" aria-hidden="true" tabindex="-1"></a>      sloop <span class="cf">do</span></span>
<span id="cb87-9"><a href="#cb87-9" aria-hidden="true" tabindex="-1"></a>        pingpong <span class="kw">&lt;=</span> <span class="dv">1</span></span>
<span id="cb87-10"><a href="#cb87-10" aria-hidden="true" tabindex="-1"></a>        arb<span class="at">.lock</span></span>
<span id="cb87-11"><a href="#cb87-11" aria-hidden="true" tabindex="-1"></a>        arb<span class="at">.unlock</span></span>
<span id="cb87-12"><a href="#cb87-12" aria-hidden="true" tabindex="-1"></a>      <span class="cf">end</span></span>
<span id="cb87-13"><a href="#cb87-13" aria-hidden="true" tabindex="-1"></a>   <span class="cf">end</span></span>
<span id="cb87-14"><a href="#cb87-14" aria-hidden="true" tabindex="-1"></a>   </span>
<span id="cb87-15"><a href="#cb87-15" aria-hidden="true" tabindex="-1"></a>   sequencer(clk,start) <span class="cf">do</span></span>
<span id="cb87-16"><a href="#cb87-16" aria-hidden="true" tabindex="-1"></a>      sloop <span class="cf">do</span></span>
<span id="cb87-17"><a href="#cb87-17" aria-hidden="true" tabindex="-1"></a>        pingpong <span class="kw">&lt;=</span> <span class="dv">2</span></span>
<span id="cb87-18"><a href="#cb87-18" aria-hidden="true" tabindex="-1"></a>        arb<span class="at">.lock</span></span>
<span id="cb87-19"><a href="#cb87-19" aria-hidden="true" tabindex="-1"></a>        arb<span class="at">.unlock</span></span>
<span id="cb87-20"><a href="#cb87-20" aria-hidden="true" tabindex="-1"></a>      <span class="cf">end</span></span>
<span id="cb87-21"><a href="#cb87-21" aria-hidden="true" tabindex="-1"></a>   <span class="cf">end</span></span>
<span id="cb87-22"><a href="#cb87-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb87-23"><a href="#cb87-23" aria-hidden="true" tabindex="-1"></a>   timed <span class="cf">do</span></span>
<span id="cb87-24"><a href="#cb87-24" aria-hidden="true" tabindex="-1"></a>      clk   <span class="kw">&lt;=</span> <span class="dv">0</span></span>
<span id="cb87-25"><a href="#cb87-25" aria-hidden="true" tabindex="-1"></a>      start <span class="kw">&lt;=</span> <span class="dv">1</span></span>
<span id="cb87-26"><a href="#cb87-26" aria-hidden="true" tabindex="-1"></a>      !<span class="dv">10</span><span class="at">.ns</span></span>
<span id="cb87-27"><a href="#cb87-27" aria-hidden="true" tabindex="-1"></a>      clk   <span class="kw">&lt;=</span> <span class="dv">1</span></span>
<span id="cb87-28"><a href="#cb87-28" aria-hidden="true" tabindex="-1"></a>      !<span class="dv">10</span><span class="at">.ns</span></span>
<span id="cb87-29"><a href="#cb87-29" aria-hidden="true" tabindex="-1"></a>      clk   <span class="kw">&lt;=</span> <span class="dv">0</span></span>
<span id="cb87-30"><a href="#cb87-30" aria-hidden="true" tabindex="-1"></a>      start <span class="kw">&lt;=</span> <span class="dv">0</span></span>
<span id="cb87-31"><a href="#cb87-31" aria-hidden="true" tabindex="-1"></a>      !<span class="dv">10</span><span class="at">.ns</span></span>
<span id="cb87-32"><a href="#cb87-32" aria-hidden="true" tabindex="-1"></a>      repeat(<span class="dv">20</span>) <span class="kw">{</span> clk <span class="kw">&lt;=</span> <span class="kw">~</span>clk ;<span class="kw"> !</span><span class="dv">10</span><span class="at">.ns</span> <span class="kw">}</span></span>
<span id="cb87-33"><a href="#cb87-33" aria-hidden="true" tabindex="-1"></a>   <span class="cf">end</span></span>
<span id="cb87-34"><a href="#cb87-34" aria-hidden="true" tabindex="-1"></a><span class="cf">end</span></span></code></pre></div>
<p>As seen in the example, since the monitor locks processes, no
<code>step</code> is required, and the simulation result should be:</p>
<p align="center">
<img data-name="hruby_simulator.vcd" src="pingpong2_vcd.png"  width="80%">
</p>
<blockquote>
<p><strong>WARNING</strong>: while with an arbiter it was of no
importance, with a monitor the lock must be made <em>after</em> the
shared signal is written, otherwise this value will be taken into
account one cycle later.</p>
</blockquote>
<p>By the way, why does HDLRuby provide the arbiters if the monitors do
a better job? For performance reasons first: using an arbiter produces a
smaller and faster circuit. Also, it is sometimes better not to block a
sequencer: for example, maybe you want to write to a shared signal if
possible, and if not do something else. this can be done as follows:</p>
<div class="sourceCode" id="cb88"><pre
class="sourceCode ruby"><code class="sourceCode ruby"><span id="cb88-1"><a href="#cb88-1" aria-hidden="true" tabindex="-1"></a>sequencer(clk,start) <span class="cf">do</span></span>
<span id="cb88-2"><a href="#cb88-2" aria-hidden="true" tabindex="-1"></a>   arb <span class="kw">&lt;=</span> <span class="dv">1</span></span>
<span id="cb88-3"><a href="#cb88-3" aria-hidden="true" tabindex="-1"></a>   sif(sh<span class="at">.select</span> <span class="kw">==</span> arb<span class="at">.cur_priority</span>) <span class="kw">{</span> sh <span class="kw">&lt;=</span> <span class="dv">2</span> <span class="kw">}</span></span>
<span id="cb88-4"><a href="#cb88-4" aria-hidden="true" tabindex="-1"></a>   selse <span class="kw">{</span> <span class="kw">&lt;</span><span class="cf">do</span> something <span class="cf">else</span><span class="kw">&gt;</span> <span class="kw">}</span></span>
<span id="cb88-5"><a href="#cb88-5" aria-hidden="true" tabindex="-1"></a>   arb <span class="kw">&lt;=</span> <span class="dv">0</span></span>
<span id="cb88-6"><a href="#cb88-6" aria-hidden="true" tabindex="-1"></a><span class="cf">end</span></span></code></pre></div>
<p>In the code above, the sequencer checks if it has access by comparing
the shared signal selection with its priority (obtained by
<code>arb.cur_priority</code>).</p>
<h4 id="i-do-not-like-the-priority-rule-of-the-arbitermonitor">I do not
like the priority rule of the arbiter/monitor</h4>
<p>Indeed, sometimes we need to define our priority rules. This can be
done when instantiating an arbiter or a monitor in two possible
fashions:</p>
<ul>
<li>You can provide your priority table as an array containing the
declaration order of the sequencers in order of priority, e.g., for
reversing the priority in our example:</li>
</ul>
<div class="sourceCode" id="cb89"><pre
class="sourceCode ruby"><code class="sourceCode ruby"><span id="cb89-1"><a href="#cb89-1" aria-hidden="true" tabindex="-1"></a>arbiter(<span class="wa">:arb</span>,<span class="kw">[</span><span class="dv">1</span>,<span class="dv">0</span><span class="kw">]</span>)<span class="kw">.</span>(pingpong)</span></code></pre></div>
<ul>
<li>You can provide your policy as a chunk of HDLRuby code whose
argument is the declaration order of a sequencer and that returns true
if the sequencer is granted priority. Here is an example that switches
priority at each acquirement:</li>
</ul>
<div class="sourceCode" id="cb90"><pre
class="sourceCode ruby"><code class="sourceCode ruby"><span id="cb90-1"><a href="#cb90-1" aria-hidden="true" tabindex="-1"></a>inner <span class="wa">switch: </span><span class="dv">1</span></span>
<span id="cb90-2"><a href="#cb90-2" aria-hidden="true" tabindex="-1"></a>arbiter(<span class="wa">:arb</span>) <span class="kw">{</span> <span class="kw">|</span>i<span class="kw">|</span> switch <span class="kw">&lt;=</span> <span class="kw">~</span>switch ; i <span class="kw">==</span> switch <span class="kw">}.</span>(pingpong)</span></code></pre></div>
<hr />
<p>Now you know:</p>
<ul>
<li><p>That sequencers run in parallel.</p></li>
<li><p>How to synchronize them.</p></li>
<li><p>How to share resources between them.</p></li>
<li><p>How to make intricate deadlocks and how to escape them using
arbiters and monitors… Just to make even more intricate ones (trust me
with that).</p></li>
<li><p>And…</p></li>
</ul>
<h4 id="thats-all-for-this-section-1">That’s all for this section!</h4>
<p>Congratulations! You know everything about describing a working
circuit and using your knowledge of software design, I am sure you can
already do great things.</p>
<p>But in hardware, you can go much more into the details for even more
performance. So let us go to the more advanced parts of this
tutorial.</p>
<h2 id="how-to-add-parallelism-to-your-algorithms">4. How to add
parallelism to your algorithms</h2>
<p>In software, when you want to do parallelism you usually need
specific libraries because the model of computation of software is
inherently sequential. But this is not the case with the HDLRuby
sequencers because:</p>
<ul>
<li><p><a href="#41-a-sequencer-is-not-a-program">A sequencer is not a
program</a></p></li>
<li><p><a
href="#42-parallel-control-statements-functions-and-enumerators">Adding
parallelism is genuine</a></p></li>
</ul>
<h3 id="a-sequencer-is-not-a-program">4.1. A sequencer is not a
program</h3>
<p>We said earlier that hardware is inherently parallel and we showed
that multiple sequencers run concurrently by default. However, you may
want to increase parallelism within an algorithm too: after all, it is
what recent processors do, so why not hardware?</p>
<p>To tell the truth, we lied a little when we said that the sequencers
were “executing” statements in order. They do not execute anything and
statements are not <em>instructions</em>. Rather, they are
<em>instantiations</em> of circuits performing basic computations, and
the sequencer only schedules when each circuit is to be used. For
example, the following code describes two 3-value addition circuits
selected respectively at the first and second clock cycles:</p>
<div class="sourceCode" id="cb91"><pre
class="sourceCode ruby"><code class="sourceCode ruby"><span id="cb91-1"><a href="#cb91-1" aria-hidden="true" tabindex="-1"></a>sequencer(clk,start) <span class="cf">do</span></span>
<span id="cb91-2"><a href="#cb91-2" aria-hidden="true" tabindex="-1"></a>   d <span class="kw">&lt;=</span> a <span class="kw">+</span> b <span class="kw">+</span> c</span>
<span id="cb91-3"><a href="#cb91-3" aria-hidden="true" tabindex="-1"></a>   step</span>
<span id="cb91-4"><a href="#cb91-4" aria-hidden="true" tabindex="-1"></a>   z <span class="kw">&lt;=</span> u <span class="kw">+</span> v <span class="kw">+</span> w</span>
<span id="cb91-5"><a href="#cb91-5" aria-hidden="true" tabindex="-1"></a><span class="cf">end</span></span></code></pre></div>
<p>Now, what about the following:</p>
<div class="sourceCode" id="cb92"><pre
class="sourceCode ruby"><code class="sourceCode ruby"><span id="cb92-1"><a href="#cb92-1" aria-hidden="true" tabindex="-1"></a>sequencer(clk,start) <span class="cf">do</span></span>
<span id="cb92-2"><a href="#cb92-2" aria-hidden="true" tabindex="-1"></a>   d <span class="kw">&lt;=</span> a <span class="kw">+</span> b <span class="kw">+</span> c</span>
<span id="cb92-3"><a href="#cb92-3" aria-hidden="true" tabindex="-1"></a>   z <span class="kw">&lt;=</span> u <span class="kw">+</span> v <span class="kw">+</span> w</span>
<span id="cb92-4"><a href="#cb92-4" aria-hidden="true" tabindex="-1"></a><span class="cf">end</span></span></code></pre></div>
<p>… Yes, as said early, when there is no control statement or step, the
clock does not advances. That means that both adder circuits are
selected at the same time and do “run” in parallel. Then what about the
following:</p>
<div class="sourceCode" id="cb93"><pre
class="sourceCode ruby"><code class="sourceCode ruby"><span id="cb93-1"><a href="#cb93-1" aria-hidden="true" tabindex="-1"></a>sequencer(clk,start) <span class="cf">do</span></span>
<span id="cb93-2"><a href="#cb93-2" aria-hidden="true" tabindex="-1"></a>   d <span class="kw">&lt;=</span> a <span class="kw">+</span> b <span class="kw">+</span> c</span>
<span id="cb93-3"><a href="#cb93-3" aria-hidden="true" tabindex="-1"></a>   z <span class="kw">&lt;=</span> u <span class="kw">+</span> v <span class="kw">+</span> d</span></code></pre></div>
<p>… This time, <code>z</code> requires the value of <code>d</code>, but
both circuits will again be selected at the same time. However, the
output of the first one is connected to the third input of the second
one: since they are combinatorial, waiting a little bit is enough to
obtain the right <code>d</code> input for computing <code>z</code>.</p>
<blockquote>
<p><strong>WARNING</strong>: in hardware design with HDLRuby (and with
all similar languages like Verilog VHDL or VHDL,) it is assumed that a
clock is slow enough for the relevant combinatorial circuits to complete
computation before the next cycle. If this is not the case, the
resulting circuits will not function properly. Fortunately, the
synthesis frameworks usually provide tools for verifying these
timings.</p>
</blockquote>
<h3 id="parallel-control-statements-functions-and-enumerators">4.2.
Parallel control statements, functions, and enumerators</h3>
<p>Sequencers provide many constructs for easy control and enumeration.
However, those constructs are sequential by construction. What if you
would like to do the same in parallel? This is possible, but there is an
important restriction:</p>
<blockquote>
<p><strong>WARNING</strong>: there cannot be any loop within a parallel
section of an algorithm.</p>
</blockquote>
<h4 id="parallel-conditionals">4.2.1. Parallel conditionals</h4>
<p>With that being said, even without loops you can do a lot of things.
First, let us see parallel conditional and case statements. We already
presented the sequential versions: <code>sif</code> and
<code>scase</code>. The parallel versions have the same syntax but use
an <code>h</code> instead of an <code>s</code>:</p>
<ul>
<li><p><code>hif(&lt;condition&gt;) &lt;block&gt;</code>: executes
<code>block</code> if <code>condition</code> is true (i.e., different
from 0).</p></li>
<li><p><code>helsif(&lt;condition&gt;) &lt;block&gt;</code>: executes
<code>block</code> if the conditions of the previous <code>hif</code>
and <code>helsif</code> are false and if the current
<code>condition</code> is true.</p></li>
<li><p><code>helse &lt;block&gt;</code>: executes <code>block</code> if
the conditions of the previous <code>hif</code> and <code>helsif</code>
are false (i.e., equals 0). It is also used for giving the default block
for the <code>hcase</code> statement (see below).</p></li>
<li><p><code>hcase(&lt;choice&gt;)</code>: initializes a multiple case
statement.</p></li>
</ul>
<blockquote>
<p><strong>WARNING</strong>: these are parallel statements, hence their
blocks <strong>CANNOT</strong> contain any sequential statement like
<code>step</code>, <code>sif</code>, <code>sloop</code>, or even
<code>sbreak</code>.</p>
</blockquote>
<p>However, they have the advantage of not waiting for the next clock
cycle, hence high-speed algorithms can be devised when using them. For
example, the following assigns to <code>d</code> the max of signals
<code>u</code>, <code>v</code>, and <code>w</code> in less than one
cycle:</p>
<div class="sourceCode" id="cb94"><pre
class="sourceCode ruby"><code class="sourceCode ruby"><span id="cb94-1"><a href="#cb94-1" aria-hidden="true" tabindex="-1"></a>   sequencer(clk,start) <span class="cf">do</span></span>
<span id="cb94-2"><a href="#cb94-2" aria-hidden="true" tabindex="-1"></a>      hif(u <span class="kw">&gt;</span> v) <span class="cf">do</span></span>
<span id="cb94-3"><a href="#cb94-3" aria-hidden="true" tabindex="-1"></a>         hif(u <span class="kw">&gt;</span> w) <span class="kw">{</span> d <span class="kw">&lt;=</span> u <span class="kw">}</span></span>
<span id="cb94-4"><a href="#cb94-4" aria-hidden="true" tabindex="-1"></a>     helse      <span class="kw">{</span> d <span class="kw">&lt;=</span> w <span class="kw">}</span></span>
<span id="cb94-5"><a href="#cb94-5" aria-hidden="true" tabindex="-1"></a>      <span class="cf">end</span></span>
<span id="cb94-6"><a href="#cb94-6" aria-hidden="true" tabindex="-1"></a>      helsif(v <span class="kw">&gt;</span> w) <span class="kw">{</span> d <span class="kw">&lt;=</span> v <span class="kw">}</span></span>
<span id="cb94-7"><a href="#cb94-7" aria-hidden="true" tabindex="-1"></a>      helse         <span class="kw">{</span> d <span class="kw">&lt;=</span> w <span class="kw">}</span></span>
<span id="cb94-8"><a href="#cb94-8" aria-hidden="true" tabindex="-1"></a>      <span class="kw">...</span></span>
<span id="cb94-9"><a href="#cb94-9" aria-hidden="true" tabindex="-1"></a>   <span class="cf">end</span></span></code></pre></div>
<h4 id="yes-but-without-loops-we-are-quite-limited-no">4.2.2. Yes, but
without loops, we are quite limited no?</h4>
<p>There is a whole range of computations that do not require any loop:
the <em>dataflow</em> computations. Indeed, more often than not, in
software programs, the loops like <code>for</code> or <code>while</code>
are only there for ease of design or conciseness of code, and do not
have any algorithmic purpose. For example, if you want to pick up the
max value of a fixed-sized array, you do not need a loop for that… Heh,
we just did that in the previous section (just replace <code>u</code>,
<code>v</code>, and <code>w</code> with <code>ar[0]</code>,
<code>ar[1]</code>, and <code>ar[2]</code>).</p>
<p>Still, the code of the previous section was only for three variables,
and the code was already a bit messy. Fortunately, you can use Ruby for
this purpose… Do you remember? In HDLRuby, Ruby code is executed at
compile time, so Ruby loops or iterators can be used to produce complex
hardware descriptions cleanly. However…</p>
<blockquote>
<p><strong>WARNING</strong>: Ruby code itself does not generate nor
interact with hardware, for obtaining real hardware description you
<strong>must</strong> put HDLRuby code within the Ruby loops.</p>
</blockquote>
<p>Also:</p>
<blockquote>
<p><strong>WARNING</strong>: Ruby iterators <strong>do not</strong>
apply on HDLRuby construct. But, you can convert an HDLRuby signal to a
Ruby array for applying Ruby iterators on it. For that purpose, please
use the <code>to_a</code> method.</p>
</blockquote>
<p>Let us wrap everything we said with a sequencer selecting in parallel
the largest element of an array signal of sixteen 8-bit elements:</p>
<div class="sourceCode" id="cb95"><pre
class="sourceCode ruby"><code class="sourceCode ruby"><span id="cb95-1"><a href="#cb95-1" aria-hidden="true" tabindex="-1"></a><span class="fu">system</span> <span class="wa">:maxxer</span> <span class="cf">do</span></span>
<span id="cb95-2"><a href="#cb95-2" aria-hidden="true" tabindex="-1"></a>   inner <span class="wa">:clk</span>, <span class="wa">:start</span></span>
<span id="cb95-3"><a href="#cb95-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb95-4"><a href="#cb95-4" aria-hidden="true" tabindex="-1"></a>   bit<span class="kw">[</span><span class="dv">8</span><span class="kw">][-</span><span class="dv">8</span><span class="kw">]</span><span class="at">.inner</span> <span class="wa">ar: </span><span class="kw">[</span> _h05, _hA3, _h54, _h2F, _h33, _hE4, _h6B, _h1C <span class="kw">]</span></span>
<span id="cb95-5"><a href="#cb95-5" aria-hidden="true" tabindex="-1"></a>   bit<span class="kw">[</span><span class="dv">8</span><span class="kw">]</span><span class="at">.inner</span> <span class="wa">:ar_max</span></span>
<span id="cb95-6"><a href="#cb95-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb95-7"><a href="#cb95-7" aria-hidden="true" tabindex="-1"></a>   sequencer(clk,start) <span class="cf">do</span></span>
<span id="cb95-8"><a href="#cb95-8" aria-hidden="true" tabindex="-1"></a>      ar_max <span class="kw">&lt;=</span> <span class="dv">0</span></span>
<span id="cb95-9"><a href="#cb95-9" aria-hidden="true" tabindex="-1"></a>      ar<span class="at">.to_a.each</span> <span class="cf">do</span> <span class="kw">|</span>e<span class="kw">|</span></span>
<span id="cb95-10"><a href="#cb95-10" aria-hidden="true" tabindex="-1"></a>         hif(ar_max <span class="kw">&lt;</span> e) <span class="kw">{</span> ar_max <span class="kw">&lt;=</span> e <span class="kw">}</span></span>
<span id="cb95-11"><a href="#cb95-11" aria-hidden="true" tabindex="-1"></a>      <span class="cf">end</span></span>
<span id="cb95-12"><a href="#cb95-12" aria-hidden="true" tabindex="-1"></a>   <span class="cf">end</span></span>
<span id="cb95-13"><a href="#cb95-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb95-14"><a href="#cb95-14" aria-hidden="true" tabindex="-1"></a>   timed <span class="cf">do</span></span>
<span id="cb95-15"><a href="#cb95-15" aria-hidden="true" tabindex="-1"></a>      clk   <span class="kw">&lt;=</span> <span class="dv">0</span></span>
<span id="cb95-16"><a href="#cb95-16" aria-hidden="true" tabindex="-1"></a>      start <span class="kw">&lt;=</span> <span class="dv">1</span></span>
<span id="cb95-17"><a href="#cb95-17" aria-hidden="true" tabindex="-1"></a>      !<span class="dv">10</span><span class="at">.ns</span></span>
<span id="cb95-18"><a href="#cb95-18" aria-hidden="true" tabindex="-1"></a>      clk   <span class="kw">&lt;=</span> <span class="dv">1</span></span>
<span id="cb95-19"><a href="#cb95-19" aria-hidden="true" tabindex="-1"></a>      !<span class="dv">10</span><span class="at">.ns</span></span>
<span id="cb95-20"><a href="#cb95-20" aria-hidden="true" tabindex="-1"></a>      clk   <span class="kw">&lt;=</span> <span class="dv">0</span></span>
<span id="cb95-21"><a href="#cb95-21" aria-hidden="true" tabindex="-1"></a>      start <span class="kw">&lt;=</span> <span class="dv">0</span></span>
<span id="cb95-22"><a href="#cb95-22" aria-hidden="true" tabindex="-1"></a>      !<span class="dv">10</span><span class="at">.ns</span></span>
<span id="cb95-23"><a href="#cb95-23" aria-hidden="true" tabindex="-1"></a>      repeat(<span class="dv">20</span>) <span class="kw">{</span> clk <span class="kw">&lt;=</span> <span class="kw">~</span>clk ;<span class="kw"> !</span><span class="dv">10</span><span class="at">.ns</span> <span class="kw">}</span></span>
<span id="cb95-24"><a href="#cb95-24" aria-hidden="true" tabindex="-1"></a>   <span class="cf">end</span></span>
<span id="cb95-25"><a href="#cb95-25" aria-hidden="true" tabindex="-1"></a><span class="cf">end</span></span></code></pre></div>
<p>The simulation result should be:</p>
<p align="center">
<img data-name="hruby_simulator.vcd" src="maxxer_vcd.png"  width="80%">
</p>
<p>As promised, the max is obtained at the first cycle of the sequencer
execution!</p>
<p>However, the code given below will not produce anything other than
setting <code>ar_max</code> to 0, because the Ruby <code>max</code>
method does not use any HDLRuby code:</p>
<div class="sourceCode" id="cb96"><pre
class="sourceCode ruby"><code class="sourceCode ruby"><span id="cb96-1"><a href="#cb96-1" aria-hidden="true" tabindex="-1"></a>   sequencer(clk,start) <span class="cf">do</span></span>
<span id="cb96-2"><a href="#cb96-2" aria-hidden="true" tabindex="-1"></a>      ar_max <span class="kw">&lt;=</span> <span class="dv">0</span></span>
<span id="cb96-3"><a href="#cb96-3" aria-hidden="true" tabindex="-1"></a>      ar<span class="at">.to_a.max</span></span>
<span id="cb96-4"><a href="#cb96-4" aria-hidden="true" tabindex="-1"></a>   <span class="cf">end</span></span></code></pre></div>
<p>So, you can use <code>each</code> but not <code>max</code>… Why?
Because the <code>max</code> method does the comparison between elements
at HDLRuby compile time and does not generate any hardware. More
generally:</p>
<blockquote>
<p>If the method iterates without any <strong>implicit</strong>
computation, then it can be used for parallel HDLRuby description.</p>
</blockquote>
<p>Yes, this is becoming confusing because it is hard to know what Ruby
does when executing its methods. Unfortunately, there is nothing to help
with that yet, but we hope to clarify things in future versions of
HDLRuby. For now, if unsure, it is recommended to stick to the following
Ruby methods:</p>
<ul>
<li><p><code>each</code>, <code>each_cons</code>,
<code>each_slice</code></p></li>
<li><p><code>reduce</code> (or <code>inject</code>)</p></li>
<li><p><code>zip</code></p></li>
</ul>
<h4 id="can-functions-be-parallel-too">4.2.3. Can functions be parallel
too?</h4>
<p>As explained before, the body of a <code>sdef</code> function can
contain any kind of sequencer code, hence parallel code is also
possible. Yet, calling and returning from such a function are themselves
sequential procedures that require several cycles to be performed.
Hence, there exists a parallel version of <code>sdef</code> whose call
and return as well as its body execution is fully combinatorial. It is
declared as follows:</p>
<div class="sourceCode" id="cb97"><pre
class="sourceCode ruby"><code class="sourceCode ruby"><span id="cb97-1"><a href="#cb97-1" aria-hidden="true" tabindex="-1"></a>hdef :<span class="kw">&lt;</span>name<span class="kw">&gt;</span> <span class="cf">do</span> <span class="kw">|&lt;</span>arguments<span class="kw">&gt;|</span></span>
<span id="cb97-2"><a href="#cb97-2" aria-hidden="true" tabindex="-1"></a>   <span class="kw">&lt;</span>body<span class="kw">&gt;</span></span>
<span id="cb97-3"><a href="#cb97-3" aria-hidden="true" tabindex="-1"></a><span class="cf">end</span></span></code></pre></div>
<p>As you can see, the declaration is identical to the <code>sdef</code>
one. However the behavior is different, and this new kind of function
has the following limitations:</p>
<ol type="1">
<li><p>It cannot contain any sequential code, i.e., constructs like
<code>step</code>, <code>sif</code> or <code>sloop</code>.</p></li>
<li><p>It does not support the <code>sreturn</code> constructs either,
instead, it is the last value computed by the function that is
returned.</p></li>
<li><p>It cannot be recursive.</p></li>
</ol>
<p>Here is an example of a parallel-compatible function counting the
number of ones in the input argument:</p>
<div class="sourceCode" id="cb98"><pre
class="sourceCode ruby"><code class="sourceCode ruby"><span id="cb98-1"><a href="#cb98-1" aria-hidden="true" tabindex="-1"></a>hdef <span class="wa">:popcount</span> <span class="cf">do</span> <span class="kw">|</span>n<span class="kw">|</span></span>
<span id="cb98-2"><a href="#cb98-2" aria-hidden="true" tabindex="-1"></a>   n<span class="at">.each.reduce</span>(_b0<span class="at">.as</span>(n<span class="at">.type</span>),<span class="kw">&amp;</span>:<span class="kw">+</span>)</span>
<span id="cb98-3"><a href="#cb98-3" aria-hidden="true" tabindex="-1"></a><span class="cf">end</span></span></code></pre></div>
<p>In the code above, it can be seen that no return is provided but
instead, it will be the result of the parallel sum result that will be
returned since it is the last computation of the function. Also, the
data type of the sum is obtained from the argument <code>n</code>
(<code>as(n.type)</code>).</p>
<hr />
<p>Now you know:</p>
<ul>
<li><p>How to introduce parallelism within a sequencer.</p></li>
<li><p>How to define a parallel-compatible function using
<code>hdef</code></p></li>
</ul>
<p>But, by the way, why bother with sequential code if parallel one is
faster?</p>
<h4 id="parallel-is-faster-so-why-do-sequential-computations">4.2.4.
Parallel is faster, so why do sequential computations?</h4>
<p>Why parallel dataflow computations are indeed faster than sequential
ones, in theory, they also have some drawbacks.</p>
<ul>
<li><p>First, not every algorithm can be implemented by a dataflow
computation. For example, the initial sequencer example that counts the
clock cycles is necessarily sequential. More generally, any algorithm
that has as input or output a sequence of values must be sequential. But
that is not all:</p>
<blockquote>
<p>Any algorithm that processes data of arbitrary size requires at least
partly some sequential computation.</p>
</blockquote>
<p>For example, how can you process a text whose size is unknown without
any sequential computation… You can say, OK, let us first look for the
end of the text and then we can process it in parallel but wait… Looking
for this end will require some sequential processing, e.g., looking at
one character after the other if it is the end (EOF).</p></li>
<li><p>Second, parallel implementation of algorithms requires much more
chip area than sequential ones. This is expensive, and there are some
physical limitations with the size of a chip.</p></li>
<li><p>Third, while faster in theory, parallel implementations may end
slower than sequential ones in practice. This is because, the larger a
combinatorial circuit is, the longer its delays are.</p></li>
</ul>
<p>Now, the big question is: how do we know which part of our circuit
would better be parallel?</p>
<blockquote>
<p>Unfortunately, the best answer is the designer’s experience.</p>
</blockquote>
<p>Indeed, some design tools can decide for you, but the solution they
give may not match your expectations. For HDLRuby, the idea is to let
the designer decide but help him with as easy to use as possible
sequential and parallel constructs.</p>
<h4 id="thats-all-for-this-section-2">That’s all for this section!</h4>
<p>That was short this time because almost all had been already said in
the previous sessions. But now it is time to go past the sequencers and
dive into real RTL design.</p>
<h2 id="toward-lower-level-hardware-design-the-processes">5. Toward
lower level hardware design: the processes</h2>
<p>Why sequencers are easy to use with a software mindset, they are
implemented on top of a control circuit that schedules their operations.
While this circuit does not represent much overhead, you may want
top-notch optimizations, or simply you may want more precise control
over what hardware will be produced. It is therefore time to leave the
comfort of the sequencer and study genuine hardware description
constructs: the <em>processes</em>. Things will become more difficult,
but here is an attempt to do it progressively:</p>
<ul>
<li><p><a href="#51-what-are-the-processes">What are the
processes?</a></p></li>
<li><p><a href="#52-what-are-the-connection-processes">What are the
connection processes?</a></p></li>
<li><p><a href="#53-what-are-the-combinatorial-processes">What are the
combinatorial processes?</a></p></li>
<li><p><a href="#54-what-are-the-clocked-processes">What are the clocked
processes?</a></p></li>
<li><p><a href="#55-what-about-the-control-statements-in-processes">What
about the control statements in processes?</a></p></li>
<li><p><a href="#56-how-to-share-signals-in-processes">How to share
signals in processes?</a></p></li>
</ul>
<h3 id="what-are-the-processes">5.1. What are the processes?</h3>
<p>First, we must make things clear:</p>
<blockquote>
<p>Processes in hardware have very little (nothing?) to do with any kind
of software process.</p>
</blockquote>
<p>In hardware, a process is a list of data flow statements that are
activated (we would say <em>executed</em> if they were software
instructions) on a common condition.</p>
<blockquote>
<p>By data flow statements, we mean all the assignment statements, the
<code>hif</code>, <code>helse</code>, <code>hcase</code> and
<code>hwhen</code> statements, and the calls to <code>hdef</code>
functions.</p>
</blockquote>
<p>Depending on the activation condition, there are three kinds of
processes:</p>
<ul>
<li><p>The connection processes (in HDLRuby they are considered to be
processes)</p></li>
<li><p>The combinatorial processes</p></li>
<li><p>The clocked processes</p></li>
</ul>
<p>We also saw earlier the timed processes, they are indeed kinds of
processes, but they do not represent hardware and are therefore not
considered in this section.</p>
<p>We will detail these three kinds of hardware processes in further
sections, but there is another property to discuss before: that is the
way the data flow statements are scheduled within a process. Like with
the sequencer between clock cycles, everything is parallel, but unlike
it, there are two possible ways for handling dependencies:</p>
<ul>
<li><p>Blocking assignments scheduling where the result of a statement
can be used directly as input of the following statements. Such
processes are declared with the <code>seq</code> keyword.</p></li>
<li><p>Non-blocking assignments where all the statements are independent
of each other. Such processes are declared with the <code>par</code>
keyword.</p></li>
</ul>
<p>For example, if we assume that the initial value of <code>x</code> is
1 and that the initial value of <code>y</code> is 0, when the following
process is activated, the value of <code>z</code> will become 4:</p>
<div class="sourceCode" id="cb99"><pre
class="sourceCode ruby"><code class="sourceCode ruby"><span id="cb99-1"><a href="#cb99-1" aria-hidden="true" tabindex="-1"></a>seq(<span class="kw">&lt;</span>activation condition<span class="kw">&gt;</span>) <span class="cf">do</span></span>
<span id="cb99-2"><a href="#cb99-2" aria-hidden="true" tabindex="-1"></a>   y <span class="kw">&lt;=</span> x <span class="kw">+</span> <span class="dv">1</span></span>
<span id="cb99-3"><a href="#cb99-3" aria-hidden="true" tabindex="-1"></a>   z <span class="kw">&lt;=</span> y <span class="kw">+</span> <span class="dv">2</span></span>
<span id="cb99-4"><a href="#cb99-4" aria-hidden="true" tabindex="-1"></a><span class="cf">end</span></span></code></pre></div>
<p>Whereas, with the following process, <code>z</code> will become 2,
i.e., it will be the result of the addition of the initial value of
<code>y</code> which is still 0:</p>
<div class="sourceCode" id="cb100"><pre
class="sourceCode ruby"><code class="sourceCode ruby"><span id="cb100-1"><a href="#cb100-1" aria-hidden="true" tabindex="-1"></a>par(<span class="kw">&lt;</span>activation condition<span class="kw">&gt;</span>) <span class="cf">do</span></span>
<span id="cb100-2"><a href="#cb100-2" aria-hidden="true" tabindex="-1"></a>   y <span class="kw">&lt;=</span> x <span class="kw">+</span> <span class="dv">1</span></span>
<span id="cb100-3"><a href="#cb100-3" aria-hidden="true" tabindex="-1"></a>   z <span class="kw">&lt;=</span> y <span class="kw">+</span> <span class="dv">2</span></span>
<span id="cb100-4"><a href="#cb100-4" aria-hidden="true" tabindex="-1"></a><span class="cf">end</span></span></code></pre></div>
<blockquote>
<p>There is a couple of caveats with the non-blocking processes. First,
only the last assignment prevails when a signal is assigned multiple
times. For example, with the following process, assuming the same
initial values for x and y as before, z will become 3 and not 2:</p>
</blockquote>
<div class="sourceCode" id="cb101"><pre
class="sourceCode ruby"><code class="sourceCode ruby"><span id="cb101-1"><a href="#cb101-1" aria-hidden="true" tabindex="-1"></a>par(<span class="kw">&lt;</span>activation condition<span class="kw">&gt;</span>) <span class="cf">do</span></span>
<span id="cb101-2"><a href="#cb101-2" aria-hidden="true" tabindex="-1"></a>   y <span class="kw">&lt;=</span> x <span class="kw">+</span> <span class="dv">1</span></span>
<span id="cb101-3"><a href="#cb101-3" aria-hidden="true" tabindex="-1"></a>   z <span class="kw">&lt;=</span> y <span class="kw">+</span> <span class="dv">2</span></span>
<span id="cb101-4"><a href="#cb101-4" aria-hidden="true" tabindex="-1"></a>   z <span class="kw">&lt;=</span> y <span class="kw">+</span> <span class="dv">3</span></span>
<span id="cb101-5"><a href="#cb101-5" aria-hidden="true" tabindex="-1"></a><span class="cf">end</span></span></code></pre></div>
<blockquote>
<p>Second, the order of statements assigning to different values does
not affect the result. For example, the following process is identical
to the previous one:</p>
</blockquote>
<div class="sourceCode" id="cb102"><pre
class="sourceCode ruby"><code class="sourceCode ruby"><span id="cb102-1"><a href="#cb102-1" aria-hidden="true" tabindex="-1"></a>par(<span class="kw">&lt;</span>activation condition<span class="kw">&gt;</span>) <span class="cf">do</span></span>
<span id="cb102-2"><a href="#cb102-2" aria-hidden="true" tabindex="-1"></a>   z <span class="kw">&lt;=</span> y <span class="kw">+</span> <span class="dv">2</span></span>
<span id="cb102-3"><a href="#cb102-3" aria-hidden="true" tabindex="-1"></a>   z <span class="kw">&lt;=</span> y <span class="kw">+</span> <span class="dv">3</span></span>
<span id="cb102-4"><a href="#cb102-4" aria-hidden="true" tabindex="-1"></a>   y <span class="kw">&lt;=</span> x <span class="kw">+</span> <span class="dv">1</span></span>
<span id="cb102-5"><a href="#cb102-5" aria-hidden="true" tabindex="-1"></a><span class="cf">end</span></span></code></pre></div>
<blockquote>
<p>But this one is different (we switched two assignments to the same
signal):</p>
</blockquote>
<div class="sourceCode" id="cb103"><pre
class="sourceCode ruby"><code class="sourceCode ruby"><span id="cb103-1"><a href="#cb103-1" aria-hidden="true" tabindex="-1"></a>par(<span class="kw">&lt;</span>activation condition<span class="kw">&gt;</span>) <span class="cf">do</span></span>
<span id="cb103-2"><a href="#cb103-2" aria-hidden="true" tabindex="-1"></a>   y <span class="kw">&lt;=</span> x <span class="kw">+</span> <span class="dv">1</span></span>
<span id="cb103-3"><a href="#cb103-3" aria-hidden="true" tabindex="-1"></a>   z <span class="kw">&lt;=</span> y <span class="kw">+</span> <span class="dv">3</span></span>
<span id="cb103-4"><a href="#cb103-4" aria-hidden="true" tabindex="-1"></a>   z <span class="kw">&lt;=</span> y <span class="kw">+</span> <span class="dv">2</span></span>
<span id="cb103-5"><a href="#cb103-5" aria-hidden="true" tabindex="-1"></a><span class="cf">end</span></span></code></pre></div>
<p>Now let us see the different kinds of processes in detail.</p>
<h3 id="what-are-the-connection-processes">5.2. What are the connection
processes?</h3>
<p>We already mentioned the connections at the beginning of this
tutorial about how to <a href="#circuit-use">reuse circuits</a>. Each
connection is considered to be a standalone process. Such a process is
continuously activated, and its left value is <em>always</em> equal to
its right value.</p>
<p>Since the connection processes are one-statements only, they do not
require a <code>seq</code> or <code>par</code> keyword. For example, the
following module includes two connections to its output ports:</p>
<div class="sourceCode" id="cb104"><pre
class="sourceCode ruby"><code class="sourceCode ruby"><span id="cb104-1"><a href="#cb104-1" aria-hidden="true" tabindex="-1"></a><span class="fu">system</span> <span class="wa">:a_system_with_cnx</span> <span class="cf">do</span></span>
<span id="cb104-2"><a href="#cb104-2" aria-hidden="true" tabindex="-1"></a>   <span class="kw">[</span><span class="dv">8</span><span class="kw">]</span><span class="at">.input</span> <span class="wa">:x</span>, <span class="wa">:y</span></span>
<span id="cb104-3"><a href="#cb104-3" aria-hidden="true" tabindex="-1"></a>   <span class="kw">[</span><span class="dv">8</span><span class="kw">]</span><span class="at">.output</span> <span class="wa">:u</span>,<span class="wa">:v</span></span>
<span id="cb104-4"><a href="#cb104-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb104-5"><a href="#cb104-5" aria-hidden="true" tabindex="-1"></a>   u <span class="kw">&lt;=</span> x <span class="kw">+</span> y</span>
<span id="cb104-6"><a href="#cb104-6" aria-hidden="true" tabindex="-1"></a>   v <span class="kw">&lt;=</span> x <span class="kw">-</span> y</span>
<span id="cb104-7"><a href="#cb104-7" aria-hidden="true" tabindex="-1"></a><span class="cf">end</span></span></code></pre></div>
<h3 id="what-are-the-combinatorial-processes">5.3. What are the
combinatorial processes?</h3>
<p>These processes are declared with a <code>seq</code> or a
<code>par</code> keywords with a list of signals as activation
conditions. They have activated each time one or more signals of their
activation condition changed value. For example, the following process
will only be activated when <code>x</code> or <code>y</code> changes
value, but not when <code>z</code>, <code>u</code> or <code>v</code>
does:</p>
<div class="sourceCode" id="cb105"><pre
class="sourceCode ruby"><code class="sourceCode ruby"><span id="cb105-1"><a href="#cb105-1" aria-hidden="true" tabindex="-1"></a>par(x,y) <span class="cf">do</span></span>
<span id="cb105-2"><a href="#cb105-2" aria-hidden="true" tabindex="-1"></a>   u <span class="kw">&lt;=</span> x <span class="kw">+</span> z</span>
<span id="cb105-3"><a href="#cb105-3" aria-hidden="true" tabindex="-1"></a>   v <span class="kw">&lt;=</span> y <span class="kw">-</span> z</span>
<span id="cb105-4"><a href="#cb105-4" aria-hidden="true" tabindex="-1"></a><span class="cf">end</span></span></code></pre></div>
<p>Another kind of combinatorial process is activated each time a signal
its computations depend on changes in value. They are declared with the
<code>seq</code> or <code>par</code> keywords without any activation
condition. For example, the following process will be activated when
<code>x</code>, <code>y</code>, or <code>z</code> change value:</p>
<div class="sourceCode" id="cb106"><pre
class="sourceCode ruby"><code class="sourceCode ruby"><span id="cb106-1"><a href="#cb106-1" aria-hidden="true" tabindex="-1"></a>par <span class="cf">do</span></span>
<span id="cb106-2"><a href="#cb106-2" aria-hidden="true" tabindex="-1"></a>   u <span class="kw">&lt;=</span> x <span class="kw">+</span> z</span>
<span id="cb106-3"><a href="#cb106-3" aria-hidden="true" tabindex="-1"></a>   v <span class="kw">&lt;=</span> y <span class="kw">-</span> z</span>
<span id="cb106-4"><a href="#cb106-4" aria-hidden="true" tabindex="-1"></a><span class="cf">end</span></span></code></pre></div>
<p>Here is a more practical example: a circuit that computes the 8-bit
checksum of an input 32-bit vector.</p>
<div class="sourceCode" id="cb107"><pre
class="sourceCode ruby"><code class="sourceCode ruby"><span id="cb107-1"><a href="#cb107-1" aria-hidden="true" tabindex="-1"></a><span class="fu">system</span> <span class="wa">:checksum</span> <span class="cf">do</span></span>
<span id="cb107-2"><a href="#cb107-2" aria-hidden="true" tabindex="-1"></a>   <span class="kw">[</span><span class="dv">32</span><span class="kw">]</span><span class="at">.input</span> <span class="wa">:x</span></span>
<span id="cb107-3"><a href="#cb107-3" aria-hidden="true" tabindex="-1"></a>   <span class="kw">[</span><span class="dv">32</span><span class="kw">+</span><span class="dv">8</span><span class="kw">]</span><span class="at">.output</span> <span class="wa">:z</span></span>
<span id="cb107-4"><a href="#cb107-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb107-5"><a href="#cb107-5" aria-hidden="true" tabindex="-1"></a>   <span class="kw">[</span><span class="dv">8</span><span class="kw">]</span><span class="at">.inner</span> <span class="wa">:sum</span></span>
<span id="cb107-6"><a href="#cb107-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb107-7"><a href="#cb107-7" aria-hidden="true" tabindex="-1"></a>   seq <span class="cf">do</span></span>
<span id="cb107-8"><a href="#cb107-8" aria-hidden="true" tabindex="-1"></a>      sum <span class="kw">&lt;=</span> x<span class="kw">[</span><span class="dv">31</span><span class="kw">..</span><span class="dv">24</span><span class="kw">]</span> <span class="kw">^</span> x<span class="kw">[</span><span class="dv">23</span><span class="kw">..</span><span class="dv">16</span><span class="kw">]</span> <span class="kw">^</span> x<span class="kw">[</span><span class="dv">15</span><span class="kw">..</span><span class="dv">8</span><span class="kw">]</span> <span class="kw">^</span> x<span class="kw">[</span><span class="dv">7</span><span class="kw">..</span><span class="dv">0</span><span class="kw">]</span></span>
<span id="cb107-9"><a href="#cb107-9" aria-hidden="true" tabindex="-1"></a>      z <span class="kw">&lt;=</span> <span class="kw">[</span>x,sum<span class="kw">]</span></span>
<span id="cb107-10"><a href="#cb107-10" aria-hidden="true" tabindex="-1"></a>   <span class="cf">end</span></span>
<span id="cb107-11"><a href="#cb107-11" aria-hidden="true" tabindex="-1"></a><span class="cf">end</span></span></code></pre></div>
<p>In this code, the statement <code>z &lt;= [x,sum]</code> concatenates
the value of <code>x</code> with the value of <code>sum</code> using the
concatenation operator <code>[]</code>.</p>
<blockquote>
<p>Please note that the concatenation operator is different from the
access operator even if they use the same characters: the syntax
<code>&lt;sig&gt;[&lt;integer or range]</code> is the access operator,
and the syntax <code>[&lt;list of signals or values&gt;]</code> is the
concatenation operator.</p>
</blockquote>
<p>You can check this module with the following simulation
environment:</p>
<div class="sourceCode" id="cb108"><pre
class="sourceCode ruby"><code class="sourceCode ruby"><span id="cb108-1"><a href="#cb108-1" aria-hidden="true" tabindex="-1"></a><span class="fu">system</span> <span class="wa">:checksum_sim</span> <span class="cf">do</span></span>
<span id="cb108-2"><a href="#cb108-2" aria-hidden="true" tabindex="-1"></a>   <span class="kw">[</span><span class="dv">32</span><span class="kw">]</span><span class="at">.inner</span> <span class="wa">:x</span></span>
<span id="cb108-3"><a href="#cb108-3" aria-hidden="true" tabindex="-1"></a>   <span class="kw">[</span><span class="dv">40</span><span class="kw">]</span><span class="at">.inner</span> <span class="wa">:z</span></span>
<span id="cb108-4"><a href="#cb108-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb108-5"><a href="#cb108-5" aria-hidden="true" tabindex="-1"></a>   checksum(<span class="wa">:checksumI</span>)<span class="kw">.</span>(x,z)</span>
<span id="cb108-6"><a href="#cb108-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb108-7"><a href="#cb108-7" aria-hidden="true" tabindex="-1"></a>   timed <span class="cf">do</span></span>
<span id="cb108-8"><a href="#cb108-8" aria-hidden="true" tabindex="-1"></a>      x <span class="kw">&lt;=</span> <span class="dv">0</span></span>
<span id="cb108-9"><a href="#cb108-9" aria-hidden="true" tabindex="-1"></a>      !<span class="dv">10</span><span class="at">.ns</span></span>
<span id="cb108-10"><a href="#cb108-10" aria-hidden="true" tabindex="-1"></a>      x <span class="kw">&lt;=</span> _h34F4AC68</span>
<span id="cb108-11"><a href="#cb108-11" aria-hidden="true" tabindex="-1"></a>      !<span class="dv">10</span><span class="at">.ns</span></span>
<span id="cb108-12"><a href="#cb108-12" aria-hidden="true" tabindex="-1"></a>   <span class="cf">end</span></span>
<span id="cb108-13"><a href="#cb108-13" aria-hidden="true" tabindex="-1"></a><span class="cf">end</span></span></code></pre></div>
<p>The simulation result should be:</p>
<p align="center">
<img data-name="hruby_simulator.vcd" src="checksum_vcd.png"  width="80%">
</p>
<p>That is to say that the checksum of <code>x</code> is <code>04</code>
appended at the end of <code>z</code>.</p>
<h4
id="combinatorial-processes-that-cannot-become-combinatorial-circuits.">Combinatorial
processes that cannot become combinatorial circuits.</h4>
<p>In the final hardware, a circuit whose output signals are also used
as inputs is <strong>not</strong> a combinatorial circuit, and may not
be a viable circuit at all. Such non-combinatorial circuits are used for
making memory points (e.g., registers), or local synchronization (e.g.,
C elements). It is possible to describe such an element with a
combinatorial process: it is enough to make a signal dependent on itself
in a process. For example, for both combinatorial processes, signals
<code>x</code> and <code>u</code> depend on themselves, and are
therefore not describing combinatorial circuit:</p>
<div class="sourceCode" id="cb109"><pre
class="sourceCode ruby"><code class="sourceCode ruby"><span id="cb109-1"><a href="#cb109-1" aria-hidden="true" tabindex="-1"></a>par <span class="cf">do</span></span>
<span id="cb109-2"><a href="#cb109-2" aria-hidden="true" tabindex="-1"></a>   x <span class="kw">&lt;=</span> x <span class="kw">+</span> <span class="dv">1</span></span>
<span id="cb109-3"><a href="#cb109-3" aria-hidden="true" tabindex="-1"></a><span class="cf">end</span></span>
<span id="cb109-4"><a href="#cb109-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb109-5"><a href="#cb109-5" aria-hidden="true" tabindex="-1"></a>seq <span class="cf">do</span></span>
<span id="cb109-6"><a href="#cb109-6" aria-hidden="true" tabindex="-1"></a>  u <span class="kw">&lt;=</span> v <span class="kw">+</span> <span class="dv">1</span></span>
<span id="cb109-7"><a href="#cb109-7" aria-hidden="true" tabindex="-1"></a>  v <span class="kw">&lt;=</span> u <span class="kw">+</span> w</span>
<span id="cb109-8"><a href="#cb109-8" aria-hidden="true" tabindex="-1"></a><span class="cf">end</span></span></code></pre></div>
<blockquote>
<p><strong>WARNING</strong>: while such processes are accepted in
HDLRuby (as well as in other hardware description languages like Verilog
HDL), it is strongly recommended <strong>not</strong> to use them
because the behavior of the resulting circuit is hard to predict. If you
want to use memory elements, you should use the clocked processes
instead.</p>
</blockquote>
<h3 id="what-are-the-clocked-processes">5.4. What are the clocked
processes?</h3>
<p>These processes are declared with the <code>par</code> or
<code>seq</code> keyword with a list of signal edges as an activation
condition. There are two kinds of signal edges:</p>
<ul>
<li><p>The positive edges indicate changes in single-bit signals from 0
to 1. They are noted as follows: <code>sig.posedge</code> where
<code>sig</code> is a single-bit signal.</p></li>
<li><p>The negative edges indicate changes in single-bit signals from 1
to 0. They are noted as follows: <code>sig.negedge</code> where
<code>sig</code> is a single-bit signal.</p></li>
</ul>
<p>These processes are usually used for describing parts of circuits
that are synchronized by a global clock. This includes the cases where
you want to memorize a value.</p>
<p>Here is a simple example for illustrating this kind of process:</p>
<div class="sourceCode" id="cb110"><pre
class="sourceCode ruby"><code class="sourceCode ruby"><span id="cb110-1"><a href="#cb110-1" aria-hidden="true" tabindex="-1"></a><span class="fu">system</span> <span class="wa">:clock_counter</span> <span class="cf">do</span></span>
<span id="cb110-2"><a href="#cb110-2" aria-hidden="true" tabindex="-1"></a>   input <span class="wa">:clk</span>, <span class="wa">:run</span></span>
<span id="cb110-3"><a href="#cb110-3" aria-hidden="true" tabindex="-1"></a>   <span class="kw">[</span><span class="dv">32</span><span class="kw">]</span><span class="at">.output</span> <span class="wa">:count</span></span>
<span id="cb110-4"><a href="#cb110-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb110-5"><a href="#cb110-5" aria-hidden="true" tabindex="-1"></a>   par(clk<span class="at">.posedge</span>) <span class="cf">do</span></span>
<span id="cb110-6"><a href="#cb110-6" aria-hidden="true" tabindex="-1"></a>       hif(run) <span class="kw">{</span> count <span class="kw">&lt;=</span> count <span class="kw">+</span> <span class="dv">1</span> <span class="kw">}</span></span>
<span id="cb110-7"><a href="#cb110-7" aria-hidden="true" tabindex="-1"></a>       helse    <span class="kw">{</span> count <span class="kw">&lt;=</span> <span class="dv">0</span> <span class="kw">}</span></span>
<span id="cb110-8"><a href="#cb110-8" aria-hidden="true" tabindex="-1"></a>   <span class="cf">end</span></span>
<span id="cb110-9"><a href="#cb110-9" aria-hidden="true" tabindex="-1"></a><span class="cf">end</span></span>
<span id="cb110-10"><a href="#cb110-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb110-11"><a href="#cb110-11" aria-hidden="true" tabindex="-1"></a><span class="fu">system</span> <span class="wa">:clock_counter_sim</span> <span class="cf">do</span></span>
<span id="cb110-12"><a href="#cb110-12" aria-hidden="true" tabindex="-1"></a>   inner <span class="wa">:clk</span>, <span class="wa">:run</span></span>
<span id="cb110-13"><a href="#cb110-13" aria-hidden="true" tabindex="-1"></a>   <span class="kw">[</span><span class="dv">32</span><span class="kw">]</span><span class="at">.inner</span> <span class="wa">:count</span></span>
<span id="cb110-14"><a href="#cb110-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb110-15"><a href="#cb110-15" aria-hidden="true" tabindex="-1"></a>   clock_counter(<span class="wa">:clock_counterI</span>)<span class="kw">.</span>(clk,run,count)</span>
<span id="cb110-16"><a href="#cb110-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb110-17"><a href="#cb110-17" aria-hidden="true" tabindex="-1"></a>   timed <span class="cf">do</span></span>
<span id="cb110-18"><a href="#cb110-18" aria-hidden="true" tabindex="-1"></a>      clk <span class="kw">&lt;=</span> <span class="dv">0</span></span>
<span id="cb110-19"><a href="#cb110-19" aria-hidden="true" tabindex="-1"></a>      run <span class="kw">&lt;=</span> <span class="dv">0</span></span>
<span id="cb110-20"><a href="#cb110-20" aria-hidden="true" tabindex="-1"></a>      !<span class="dv">10</span><span class="at">.ns</span></span>
<span id="cb110-21"><a href="#cb110-21" aria-hidden="true" tabindex="-1"></a>      clk <span class="kw">&lt;=</span> <span class="dv">1</span></span>
<span id="cb110-22"><a href="#cb110-22" aria-hidden="true" tabindex="-1"></a>      !<span class="dv">10</span><span class="at">.ns</span></span>
<span id="cb110-23"><a href="#cb110-23" aria-hidden="true" tabindex="-1"></a>      run <span class="kw">&lt;=</span> <span class="dv">1</span></span>
<span id="cb110-24"><a href="#cb110-24" aria-hidden="true" tabindex="-1"></a>      repeat(<span class="dv">30</span>) <span class="kw">{</span> clk <span class="kw">&lt;=</span> <span class="kw">~</span>clk ;<span class="kw"> !</span><span class="dv">10</span><span class="at">.ns</span> <span class="kw">}</span></span>
<span id="cb110-25"><a href="#cb110-25" aria-hidden="true" tabindex="-1"></a>   <span class="cf">end</span></span>
<span id="cb110-26"><a href="#cb110-26" aria-hidden="true" tabindex="-1"></a><span class="cf">end</span></span></code></pre></div>
<p>The result should be:</p>
<p align="center">
<img data-name="hruby_simulator.vcd" src="clock_counter_vcd.png"  width="80%">
</p>
<p>Did you get what the <code>clock_counter</code> circuit does? Yes, it
simply counts the number of the positive edge of the signal
<code>clk</code> when <code>run</code> is 1: signal <code>count</code>
is initialized at 0 when declared, then the process which is activated
on each positive edge of <code>clk</code> increases this signal by one.
If you remember the sequencers, these clocked processes should look
somewhat similar. Indeed, sequencers are built upon such processes.
However, within processes, the fancy control statements like
<code>sif</code>, <code>sloop</code>, or the enumerators
<strong>cannot</strong> be used.</p>
<p>As seen in this code, a previously seen control statement has been
used: the <code>hif</code>. Yes, this statement was used for parallel
computation in sequencers… But more generally, are there any other
control statements that can be used in processes?</p>
<h3 id="what-about-the-control-statements-in-processes">5.5. What about
the control statements in processes?</h3>
<p>There is not much to say in this section… Because all has been said
in the section about <a href="#parallelism">parallelism in
sequencer</a>. The fact is all the constructs described in this previous
section were initially designed for the processes, and by extension
could also be used in sequencers.</p>
<p>These statements can be used for both clocked processes and
combinatorial processes. For example, the following is a combinatorial
circuit that implements a simple ALU (Arithmetic and Logic Unit), able
to perform the addition, the subtraction, the bitwise AND, and the
bitwise OR of the two input values, while the operation is selected by a
third input signal.</p>
<div class="sourceCode" id="cb111"><pre
class="sourceCode ruby"><code class="sourceCode ruby"><span id="cb111-1"><a href="#cb111-1" aria-hidden="true" tabindex="-1"></a><span class="fu">system</span> <span class="wa">:alu</span> <span class="cf">do</span></span>
<span id="cb111-2"><a href="#cb111-2" aria-hidden="true" tabindex="-1"></a>   <span class="kw">[</span><span class="dv">8</span><span class="kw">]</span><span class="at">.input</span> <span class="wa">:x</span>,<span class="wa">:y</span></span>
<span id="cb111-3"><a href="#cb111-3" aria-hidden="true" tabindex="-1"></a>   <span class="kw">[</span><span class="dv">2</span><span class="kw">]</span><span class="at">.input</span> <span class="wa">:opr</span></span>
<span id="cb111-4"><a href="#cb111-4" aria-hidden="true" tabindex="-1"></a>   <span class="kw">[</span><span class="dv">8</span><span class="kw">]</span><span class="at">.output</span> <span class="wa">:z</span></span>
<span id="cb111-5"><a href="#cb111-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb111-6"><a href="#cb111-6" aria-hidden="true" tabindex="-1"></a>   par <span class="cf">do</span></span>
<span id="cb111-7"><a href="#cb111-7" aria-hidden="true" tabindex="-1"></a>      hcase(opr)</span>
<span id="cb111-8"><a href="#cb111-8" aria-hidden="true" tabindex="-1"></a>      hwhen(<span class="dv">0</span>) <span class="kw">{</span> z <span class="kw">&lt;=</span> x <span class="kw">+</span> y <span class="kw">}</span></span>
<span id="cb111-9"><a href="#cb111-9" aria-hidden="true" tabindex="-1"></a>      hwhen(<span class="dv">1</span>) <span class="kw">{</span> z <span class="kw">&lt;=</span> x <span class="kw">-</span> y <span class="kw">}</span></span>
<span id="cb111-10"><a href="#cb111-10" aria-hidden="true" tabindex="-1"></a>      hwhen(<span class="dv">2</span>) <span class="kw">{</span> z <span class="kw">&lt;=</span> x <span class="kw">&amp;</span> y <span class="kw">}</span></span>
<span id="cb111-11"><a href="#cb111-11" aria-hidden="true" tabindex="-1"></a>      hwhen(<span class="dv">3</span>) <span class="kw">{</span> z <span class="kw">&lt;=</span> x <span class="kw">|</span> y <span class="kw">}</span></span>
<span id="cb111-12"><a href="#cb111-12" aria-hidden="true" tabindex="-1"></a>   <span class="cf">end</span></span>
<span id="cb111-13"><a href="#cb111-13" aria-hidden="true" tabindex="-1"></a><span class="cf">end</span></span></code></pre></div>
<p>This circuit is combinatorial, hence every time <code>x</code>,
<code>y</code>, or <code>opr</code> change value, <code>z</code> will
also instantaneously change (in reality, there is a small physical delay
that is not simulated).</p>
<p>You can check it as follows:</p>
<div class="sourceCode" id="cb112"><pre
class="sourceCode ruby"><code class="sourceCode ruby"><span id="cb112-1"><a href="#cb112-1" aria-hidden="true" tabindex="-1"></a><span class="fu">system</span> <span class="wa">:alu_sim</span> <span class="cf">do</span></span>
<span id="cb112-2"><a href="#cb112-2" aria-hidden="true" tabindex="-1"></a>   <span class="kw">[</span><span class="dv">8</span><span class="kw">]</span><span class="at">.inner</span> <span class="wa">:x</span>, <span class="wa">:y</span></span>
<span id="cb112-3"><a href="#cb112-3" aria-hidden="true" tabindex="-1"></a>   <span class="kw">[</span><span class="dv">2</span><span class="kw">]</span><span class="at">.inner</span> <span class="wa">:opr</span></span>
<span id="cb112-4"><a href="#cb112-4" aria-hidden="true" tabindex="-1"></a>   <span class="kw">[</span><span class="dv">8</span><span class="kw">]</span><span class="at">.inner</span> <span class="wa">:z</span></span>
<span id="cb112-5"><a href="#cb112-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb112-6"><a href="#cb112-6" aria-hidden="true" tabindex="-1"></a>   alu(<span class="wa">:aluI</span>)<span class="kw">.</span>(x,y,opr,z)</span>
<span id="cb112-7"><a href="#cb112-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb112-8"><a href="#cb112-8" aria-hidden="true" tabindex="-1"></a>   timed <span class="cf">do</span></span>
<span id="cb112-9"><a href="#cb112-9" aria-hidden="true" tabindex="-1"></a>      x <span class="kw">&lt;=</span> _h2A</span>
<span id="cb112-10"><a href="#cb112-10" aria-hidden="true" tabindex="-1"></a>      y <span class="kw">&lt;=</span> _h31</span>
<span id="cb112-11"><a href="#cb112-11" aria-hidden="true" tabindex="-1"></a>      opr <span class="kw">&lt;=</span> <span class="dv">0</span></span>
<span id="cb112-12"><a href="#cb112-12" aria-hidden="true" tabindex="-1"></a>      !<span class="dv">10</span><span class="at">.ns</span></span>
<span id="cb112-13"><a href="#cb112-13" aria-hidden="true" tabindex="-1"></a>      opr <span class="kw">&lt;=</span> <span class="dv">1</span></span>
<span id="cb112-14"><a href="#cb112-14" aria-hidden="true" tabindex="-1"></a>      !<span class="dv">10</span><span class="at">.ns</span></span>
<span id="cb112-15"><a href="#cb112-15" aria-hidden="true" tabindex="-1"></a>      opr <span class="kw">&lt;=</span> <span class="dv">2</span></span>
<span id="cb112-16"><a href="#cb112-16" aria-hidden="true" tabindex="-1"></a>      !<span class="dv">10</span><span class="at">.ns</span></span>
<span id="cb112-17"><a href="#cb112-17" aria-hidden="true" tabindex="-1"></a>      opr <span class="kw">&lt;=</span> <span class="dv">3</span></span>
<span id="cb112-18"><a href="#cb112-18" aria-hidden="true" tabindex="-1"></a>      !<span class="dv">10</span><span class="at">.ns</span></span>
<span id="cb112-19"><a href="#cb112-19" aria-hidden="true" tabindex="-1"></a>   <span class="cf">end</span></span>
<span id="cb112-20"><a href="#cb112-20" aria-hidden="true" tabindex="-1"></a><span class="cf">end</span></span></code></pre></div>
<p>The result should be:</p>
<p align="center">
<img data-name="hruby_simulator.vcd" src="alu_vcd.png"  width="80%">
</p>
<p>…So we can do controls with processes, but what about sharing
signals?</p>
<h3 id="how-to-share-signals-in-processes">5.6. How to share signals in
processes?</h3>
<p>This was the last feature of the sequencer: signals that can be
written to by multiple sequencers. But can we do the same with
processes?</p>
<ul>
<li><p>The short answer is no: the shared signals and the arbiter or
monitor constructs can only be used in sequencers.</p></li>
<li><p>The long answer is yes, there are even two possible ways, but you
will have to describe the underlying hardware from scratch.</p></li>
</ul>
<h4 id="the-first-way-use-a-multiplexer.">5.6.1. The first way: use a
multiplexer.</h4>
<p>A multiplexer is a circuit that selects one input among several ones
to be output. Usually, this is done according to an additional input
that indicates the number of the selected input. In HDLRuby, there are
two simple ways to describe multiplexers:</p>
<ul>
<li><p>The use of the <code>hcase</code> statements. We had an example
previously with the ALU:</p>
<div class="sourceCode" id="cb113"><pre
class="sourceCode ruby"><code class="sourceCode ruby"><span id="cb113-1"><a href="#cb113-1" aria-hidden="true" tabindex="-1"></a><span class="fu">system</span> <span class="wa">:alu</span> <span class="cf">do</span></span>
<span id="cb113-2"><a href="#cb113-2" aria-hidden="true" tabindex="-1"></a>   <span class="kw">[</span><span class="dv">8</span><span class="kw">]</span><span class="at">.input</span> <span class="wa">:x</span>,<span class="wa">:y</span></span>
<span id="cb113-3"><a href="#cb113-3" aria-hidden="true" tabindex="-1"></a>   <span class="kw">[</span><span class="dv">2</span><span class="kw">]</span><span class="at">.input</span> <span class="wa">:opr</span></span>
<span id="cb113-4"><a href="#cb113-4" aria-hidden="true" tabindex="-1"></a>   <span class="kw">[</span><span class="dv">8</span><span class="kw">]</span><span class="at">.output</span> <span class="wa">:z</span></span>
<span id="cb113-5"><a href="#cb113-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb113-6"><a href="#cb113-6" aria-hidden="true" tabindex="-1"></a>   par <span class="cf">do</span></span>
<span id="cb113-7"><a href="#cb113-7" aria-hidden="true" tabindex="-1"></a>      hcase(opr)</span>
<span id="cb113-8"><a href="#cb113-8" aria-hidden="true" tabindex="-1"></a>      hwhen(<span class="dv">0</span>) <span class="kw">{</span> z <span class="kw">&lt;=</span> x <span class="kw">+</span> y <span class="kw">}</span></span>
<span id="cb113-9"><a href="#cb113-9" aria-hidden="true" tabindex="-1"></a>      hwhen(<span class="dv">1</span>) <span class="kw">{</span> z <span class="kw">&lt;=</span> x <span class="kw">-</span> y <span class="kw">}</span></span>
<span id="cb113-10"><a href="#cb113-10" aria-hidden="true" tabindex="-1"></a>      hwhen(<span class="dv">2</span>) <span class="kw">{</span> z <span class="kw">&lt;=</span> x <span class="kw">&amp;</span> y <span class="kw">}</span></span>
<span id="cb113-11"><a href="#cb113-11" aria-hidden="true" tabindex="-1"></a>      hwhen(<span class="dv">3</span>) <span class="kw">{</span> z <span class="kw">&lt;=</span> x <span class="kw">|</span> y <span class="kw">}</span></span>
<span id="cb113-12"><a href="#cb113-12" aria-hidden="true" tabindex="-1"></a>   <span class="cf">end</span></span>
<span id="cb113-13"><a href="#cb113-13" aria-hidden="true" tabindex="-1"></a><span class="cf">end</span></span></code></pre></div>
<p>With this example, all the operations are performed in parallel, and
the <code>hcase</code> statement selects which result is to be sent to
<code>z</code> according to the selection signal
<code>opr</code>.</p></li>
<li><p>The use of the <code>mux</code> operator that has the following
syntax:
<code>mux(&lt;selection&gt;,&lt;input 0&gt;,&lt;input 1&gt;, ...)</code>
where <code>selection</code> is the selection signal, and the other
arguments are the possible inputs. The same ALU circuit can therefore be
described as follows:</p>
<div class="sourceCode" id="cb114"><pre
class="sourceCode ruby"><code class="sourceCode ruby"><span id="cb114-1"><a href="#cb114-1" aria-hidden="true" tabindex="-1"></a><span class="fu">system</span> <span class="wa">:alu</span> <span class="cf">do</span></span>
<span id="cb114-2"><a href="#cb114-2" aria-hidden="true" tabindex="-1"></a>   <span class="kw">[</span><span class="dv">8</span><span class="kw">]</span><span class="at">.input</span> <span class="wa">:x</span>,<span class="wa">:y</span></span>
<span id="cb114-3"><a href="#cb114-3" aria-hidden="true" tabindex="-1"></a>   <span class="kw">[</span><span class="dv">2</span><span class="kw">]</span><span class="at">.input</span> <span class="wa">:opr</span></span>
<span id="cb114-4"><a href="#cb114-4" aria-hidden="true" tabindex="-1"></a>   <span class="kw">[</span><span class="dv">8</span><span class="kw">]</span><span class="at">.output</span> <span class="wa">:z</span></span>
<span id="cb114-5"><a href="#cb114-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-6"><a href="#cb114-6" aria-hidden="true" tabindex="-1"></a>   z <span class="kw">&lt;=</span> mux(opr, x<span class="kw">+</span>y, x<span class="kw">-</span>y, x <span class="kw">&amp;</span> y, x <span class="kw">|</span> y)</span>
<span id="cb114-7"><a href="#cb114-7" aria-hidden="true" tabindex="-1"></a><span class="cf">end</span></span></code></pre></div>
<p>A connection is used instead of a combinatorial process for this
second example since there is a single statement.</p></li>
</ul>
<h4 id="the-second-way-use-of-tri-state-bus">5.6.2. The second way: use
of tri-state bus <a name="tri-state"></a></h4>
<p>Multiplexers are easy to describe and use, but their size grows
exponentially with the number of inputs and linearly with their bit
width. Moreover, the number of inputs of a chip is often strongly
limited. For all these reasons, an alternative is sometimes used: the
tri-state buses. They are signals where several processes or circuits
can write a value provided that only one does it at a time and that when
not writing the accesses are set in high impedance.</p>
<blockquote>
<p>Before explaining further the tri-state buses, we need to clarify a
possible misconception about hardware values: we often spoke about bits,
and you may have assumed that their possible values were 0 or 1 for
standard boolean logic. However, in hardware design it is common to use
a 4-valued logic that represents the relevant states of a wire in a
circuit:</p>
</blockquote>
<ul>
<li><p><code>0</code> for ground level, used for representing
<code>false</code> or the digit <code>0</code>;</p></li>
<li><p><code>1</code> for power supply level, used for representing
<code>true</code> or the digit <code>1</code>;</p></li>
<li><p><code>Z</code> for high impedance, used in tri-state
buses;</p></li>
<li><p><code>X</code> for undefined level, usually indicating a problem
in the circuit or an uninitialized state.</p></li>
</ul>
<p>Physically, when a signal is set to the <code>Z</code> state, it is
possible to safely write another value on it, its state becoming this
written value. Such a signal is then called a tri-state signal or
bus.</p>
<p>Tri-state signals can be <code>inner</code> or <code>inout</code>,
and as long as there are no simultaneous <code>0</code> or
<code>1</code> writes on them, they can be used freely… In theory.
However, in practice, synthesis tools prioritize safety over flexibility
and will reject several descriptions that should work. This is highly
dependent on the tool you are using, hence we cannot give precise
guidelines for the proper use of such signals. Instead, here is an
example of tri-state bus usage that should work with a majority of the
design tools, please feel free to adapt it to your needs:</p>
<div class="sourceCode" id="cb115"><pre
class="sourceCode ruby"><code class="sourceCode ruby"><span id="cb115-1"><a href="#cb115-1" aria-hidden="true" tabindex="-1"></a><span class="fu">system</span> <span class="wa">:ram8</span> <span class="cf">do</span></span>
<span id="cb115-2"><a href="#cb115-2" aria-hidden="true" tabindex="-1"></a>    input <span class="wa">:clk</span>, <span class="wa">:en</span>, <span class="wa">:rwb</span></span>
<span id="cb115-3"><a href="#cb115-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">[</span><span class="dv">8</span><span class="kw">]</span><span class="at">.input</span> <span class="wa">:addr</span></span>
<span id="cb115-4"><a href="#cb115-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">[</span><span class="dv">8</span><span class="kw">]</span><span class="at">.inout</span> <span class="wa">:data</span></span>
<span id="cb115-5"><a href="#cb115-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb115-6"><a href="#cb115-6" aria-hidden="true" tabindex="-1"></a>    bit<span class="kw">[</span><span class="dv">8</span><span class="kw">][-</span><span class="dv">2</span><span class="kw">**</span><span class="dv">8</span><span class="kw">]</span><span class="at">.inner</span> <span class="wa">:content</span></span>
<span id="cb115-7"><a href="#cb115-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb115-8"><a href="#cb115-8" aria-hidden="true" tabindex="-1"></a>    <span class="kw">[</span><span class="dv">8</span><span class="kw">]</span><span class="at">.inner</span> <span class="wa">:tmp</span></span>
<span id="cb115-9"><a href="#cb115-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb115-10"><a href="#cb115-10" aria-hidden="true" tabindex="-1"></a>    par <span class="cf">do</span></span>
<span id="cb115-11"><a href="#cb115-11" aria-hidden="true" tabindex="-1"></a>       hif(en <span class="kw">&amp;</span> rwb) <span class="kw">{</span> data <span class="kw">&lt;=</span> tmp <span class="kw">}</span></span>
<span id="cb115-12"><a href="#cb115-12" aria-hidden="true" tabindex="-1"></a>       helse         <span class="kw">{</span> data <span class="kw">&lt;=</span> _bZZZZZZZZ <span class="kw">}</span></span>
<span id="cb115-13"><a href="#cb115-13" aria-hidden="true" tabindex="-1"></a>    <span class="cf">end</span></span>
<span id="cb115-14"><a href="#cb115-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb115-15"><a href="#cb115-15" aria-hidden="true" tabindex="-1"></a>    par(clk<span class="at">.posedge</span>) <span class="cf">do</span></span>
<span id="cb115-16"><a href="#cb115-16" aria-hidden="true" tabindex="-1"></a>        hif(en) <span class="cf">do</span></span>
<span id="cb115-17"><a href="#cb115-17" aria-hidden="true" tabindex="-1"></a>            <span class="co"># Read case</span></span>
<span id="cb115-18"><a href="#cb115-18" aria-hidden="true" tabindex="-1"></a>            hif(rwb)   <span class="kw">{</span> tmp <span class="kw">&lt;=</span> content<span class="kw">[</span>addr<span class="kw">]</span> <span class="kw">}</span></span>
<span id="cb115-19"><a href="#cb115-19" aria-hidden="true" tabindex="-1"></a>            helse      <span class="kw">{</span> content<span class="kw">[</span>addr<span class="kw">]</span> <span class="kw">&lt;=</span> data <span class="kw">}</span></span>
<span id="cb115-20"><a href="#cb115-20" aria-hidden="true" tabindex="-1"></a>        <span class="cf">end</span></span>
<span id="cb115-21"><a href="#cb115-21" aria-hidden="true" tabindex="-1"></a>    <span class="cf">end</span></span>
<span id="cb115-22"><a href="#cb115-22" aria-hidden="true" tabindex="-1"></a><span class="cf">end</span></span>
<span id="cb115-23"><a href="#cb115-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb115-24"><a href="#cb115-24" aria-hidden="true" tabindex="-1"></a><span class="fu">system</span> <span class="wa">:ram8_sim</span> <span class="cf">do</span></span>
<span id="cb115-25"><a href="#cb115-25" aria-hidden="true" tabindex="-1"></a>    inner <span class="wa">:clk</span>, <span class="wa">:en</span>, <span class="wa">:rwb</span></span>
<span id="cb115-26"><a href="#cb115-26" aria-hidden="true" tabindex="-1"></a>    <span class="kw">[</span><span class="dv">8</span><span class="kw">]</span><span class="at">.inner</span> <span class="wa">:addr</span>, <span class="wa">:data</span></span>
<span id="cb115-27"><a href="#cb115-27" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb115-28"><a href="#cb115-28" aria-hidden="true" tabindex="-1"></a>    <span class="kw">[</span><span class="dv">8</span><span class="kw">]</span><span class="at">.inner</span> <span class="wa">:value</span></span>
<span id="cb115-29"><a href="#cb115-29" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb115-30"><a href="#cb115-30" aria-hidden="true" tabindex="-1"></a>    ram8(<span class="wa">:ram8I</span>)<span class="kw">.</span>(clk,en,rwb,addr,data)</span>
<span id="cb115-31"><a href="#cb115-31" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb115-32"><a href="#cb115-32" aria-hidden="true" tabindex="-1"></a>    par <span class="cf">do</span></span>
<span id="cb115-33"><a href="#cb115-33" aria-hidden="true" tabindex="-1"></a>       hif(en <span class="kw">&amp;</span> <span class="kw">~</span>rwb) <span class="kw">{</span> data <span class="kw">&lt;=</span> value <span class="kw">}</span></span>
<span id="cb115-34"><a href="#cb115-34" aria-hidden="true" tabindex="-1"></a>       helse          <span class="kw">{</span> data <span class="kw">&lt;=</span> _bZZZZZZZZ <span class="kw">}</span></span>
<span id="cb115-35"><a href="#cb115-35" aria-hidden="true" tabindex="-1"></a>    <span class="cf">end</span></span>
<span id="cb115-36"><a href="#cb115-36" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb115-37"><a href="#cb115-37" aria-hidden="true" tabindex="-1"></a>    timed <span class="cf">do</span></span>
<span id="cb115-38"><a href="#cb115-38" aria-hidden="true" tabindex="-1"></a>        addr  <span class="kw">&lt;=</span> <span class="dv">0</span></span>
<span id="cb115-39"><a href="#cb115-39" aria-hidden="true" tabindex="-1"></a>        en    <span class="kw">&lt;=</span> <span class="dv">0</span></span>
<span id="cb115-40"><a href="#cb115-40" aria-hidden="true" tabindex="-1"></a>        rwb   <span class="kw">&lt;=</span> <span class="dv">1</span></span>
<span id="cb115-41"><a href="#cb115-41" aria-hidden="true" tabindex="-1"></a>        value <span class="kw">&lt;=</span> <span class="dv">0</span></span>
<span id="cb115-42"><a href="#cb115-42" aria-hidden="true" tabindex="-1"></a>        clk   <span class="kw">&lt;=</span> <span class="dv">0</span></span>
<span id="cb115-43"><a href="#cb115-43" aria-hidden="true" tabindex="-1"></a>        !<span class="dv">10</span><span class="at">.ns</span></span>
<span id="cb115-44"><a href="#cb115-44" aria-hidden="true" tabindex="-1"></a>        clk   <span class="kw">&lt;=</span> <span class="dv">1</span></span>
<span id="cb115-45"><a href="#cb115-45" aria-hidden="true" tabindex="-1"></a>        !<span class="dv">10</span><span class="at">.ns</span></span>
<span id="cb115-46"><a href="#cb115-46" aria-hidden="true" tabindex="-1"></a>        repeat(<span class="dv">256</span>) <span class="cf">do</span></span>
<span id="cb115-47"><a href="#cb115-47" aria-hidden="true" tabindex="-1"></a>            en  <span class="kw">&lt;=</span> <span class="dv">1</span></span>
<span id="cb115-48"><a href="#cb115-48" aria-hidden="true" tabindex="-1"></a>            rwb <span class="kw">&lt;=</span> <span class="dv">1</span></span>
<span id="cb115-49"><a href="#cb115-49" aria-hidden="true" tabindex="-1"></a>            clk <span class="kw">&lt;=</span> <span class="dv">0</span></span>
<span id="cb115-50"><a href="#cb115-50" aria-hidden="true" tabindex="-1"></a>            !<span class="dv">10</span><span class="at">.ns</span></span>
<span id="cb115-51"><a href="#cb115-51" aria-hidden="true" tabindex="-1"></a>            clk   <span class="kw">&lt;=</span> <span class="dv">1</span></span>
<span id="cb115-52"><a href="#cb115-52" aria-hidden="true" tabindex="-1"></a>            !<span class="dv">10</span><span class="at">.ns</span></span>
<span id="cb115-53"><a href="#cb115-53" aria-hidden="true" tabindex="-1"></a>            en    <span class="kw">&lt;=</span> <span class="dv">0</span></span>
<span id="cb115-54"><a href="#cb115-54" aria-hidden="true" tabindex="-1"></a>            addr  <span class="kw">&lt;=</span> addr <span class="kw">+</span> <span class="dv">1</span></span>
<span id="cb115-55"><a href="#cb115-55" aria-hidden="true" tabindex="-1"></a>            value <span class="kw">&lt;=</span> value <span class="kw">+</span> <span class="dv">1</span></span>
<span id="cb115-56"><a href="#cb115-56" aria-hidden="true" tabindex="-1"></a>            clk   <span class="kw">&lt;=</span> <span class="dv">0</span></span>
<span id="cb115-57"><a href="#cb115-57" aria-hidden="true" tabindex="-1"></a>            !<span class="dv">10</span><span class="at">.ns</span></span>
<span id="cb115-58"><a href="#cb115-58" aria-hidden="true" tabindex="-1"></a>            clk   <span class="kw">&lt;=</span> <span class="dv">1</span></span>
<span id="cb115-59"><a href="#cb115-59" aria-hidden="true" tabindex="-1"></a>            !<span class="dv">10</span><span class="at">.ns</span></span>
<span id="cb115-60"><a href="#cb115-60" aria-hidden="true" tabindex="-1"></a>            en  <span class="kw">&lt;=</span> <span class="dv">1</span></span>
<span id="cb115-61"><a href="#cb115-61" aria-hidden="true" tabindex="-1"></a>            rwb <span class="kw">&lt;=</span> <span class="dv">0</span></span>
<span id="cb115-62"><a href="#cb115-62" aria-hidden="true" tabindex="-1"></a>            clk <span class="kw">&lt;=</span> <span class="dv">0</span></span>
<span id="cb115-63"><a href="#cb115-63" aria-hidden="true" tabindex="-1"></a>            !<span class="dv">10</span><span class="at">.ns</span></span>
<span id="cb115-64"><a href="#cb115-64" aria-hidden="true" tabindex="-1"></a>            clk <span class="kw">&lt;=</span> <span class="dv">1</span></span>
<span id="cb115-65"><a href="#cb115-65" aria-hidden="true" tabindex="-1"></a>            !<span class="dv">10</span><span class="at">.ns</span></span>
<span id="cb115-66"><a href="#cb115-66" aria-hidden="true" tabindex="-1"></a>            en <span class="kw">&lt;=</span> <span class="dv">0</span></span>
<span id="cb115-67"><a href="#cb115-67" aria-hidden="true" tabindex="-1"></a>            clk <span class="kw">&lt;=</span> <span class="dv">0</span></span>
<span id="cb115-68"><a href="#cb115-68" aria-hidden="true" tabindex="-1"></a>            !<span class="dv">10</span><span class="at">.ns</span></span>
<span id="cb115-69"><a href="#cb115-69" aria-hidden="true" tabindex="-1"></a>            clk <span class="kw">&lt;=</span> <span class="dv">1</span></span>
<span id="cb115-70"><a href="#cb115-70" aria-hidden="true" tabindex="-1"></a>            !<span class="dv">10</span><span class="at">.ns</span></span>
<span id="cb115-71"><a href="#cb115-71" aria-hidden="true" tabindex="-1"></a>        <span class="cf">end</span></span>
<span id="cb115-72"><a href="#cb115-72" aria-hidden="true" tabindex="-1"></a>    <span class="cf">end</span></span>
<span id="cb115-73"><a href="#cb115-73" aria-hidden="true" tabindex="-1"></a><span class="cf">end</span></span></code></pre></div>
<p>And the simulation result should be:</p>
<p align="center">
<img data-name="hruby_simulator.vcd" src="ram_vcd.png"  width="80%">
</p>
<p>The first module is an 8-bit address 8-bit data RAM with a single
data bus for both reading and writing. When the RAM is not read
(<code>en</code> is 0 or <code>rwb</code> is 0), the data bus is set to
<code>Z</code>. The second module simply accesses the RAM, and for that
purpose uses a process specifically for writing to the data bus: when a
write operation is performed (<code>en</code> is 1 for activating the
access to the RAM and <code>rwb</code> is set to 0), the value is
written to the bus, otherwise, a value is nonetheless written but it is
a <code>Z</code> value. The coding style of this process is crucial for
ensuring synthesis tools will succeed: we cannot guarantee it will work
if it is described differently.</p>
<h4
id="this-section-may-have-been-quite-a-leap-from-the-software-mindset">This
section may have been quite a leap from the software mindset…</h4>
<hr />
<p>But, now you may understand:</p>
<ul>
<li><p>How to describe low-level hardware with HDLRuby with
processes.</p></li>
<li><p>The existence of three kinds of processes: the connections,
combinatorial, and clocked processes.</p></li>
<li><p>How to use controls in processes.</p></li>
<li><p>How to write several values to a single signal without the
comfort brought by the sequencers and their shared signals.</p></li>
<li><p>What is a tri-state bus and how to use it.</p></li>
</ul>
<p>With that, you have all the constructs required for describing
optimized hardware. Of course, mastering them requires a lot of
know-how, but this is out of the scope of this tutorial. To go further,
please follow lessons about hardware design using popular hardware
description languages like Verilog HDL or VHDL since what you can do
with them, you can do it with HDLRuby.</p>
<p>However, there remain a few major features for more efficient coding
inherited from the Ruby language.</p>
<h2
id="not-enough-what-about-genericity-object-orientation-metaprogramming-and-reflection">6.
Not enough? What about genericity, object orientation, metaprogramming,
and reflection?</h2>
<p>Let us imagine you spent hours designing a circuit processing 8-bit
values for outputting a 16-bit result and you learn that the input
should be 16-bit and the output 8-bit. Well, that’s not so tough, you
just need to modify the data types in your circuit description…
<strong>everywhere</strong>. When you just finished, you learn that it
would be great if there was also another version of the circuit that
could output flags about the result. Ok, so let us make another version
of the circuit, and since it is not so different, let us do some copy
and paste, and then make modifications for the flags… But whoop! You did
not notice that with your modifications you unintentionally modified a
few lines of code introducing new bugs… And of course, you realize it
after hours of testing.</p>
<p>Such situations happen all the time in software design… But it is
much worse in hardware. Indeed, due to the variety of hardware circuits,
it is very common to want to reuse a design with different bit widths.
This is why, existing hardware description language supports genericity
to a certain degree. However, HDLRuby ruby goes further in terms of
genericity, and also adds object-oriented programming, metaprogramming,
and reflection concepts to maximize the possibilities of code reuse.
From now on, let us detail:</p>
<ul>
<li><p><a href="#61-genericity-in-hdlruby">Genericity in
HDLRuby</a></p></li>
<li><p><a
href="#62-object-oriented-programming-in-hdlruby">Object-oriented
programming in HDLRuby</a></p></li>
<li><p><a
href="#63-metaprogramming-and-reflection-in-hdlruby">Metaprogramming and
reflection in HDLRuby</a></p></li>
</ul>
<h3 id="genericity-in-hdlruby">6.1. Genericity in HDLRuby</h3>
<p>In HDLRuby, genericity is supported through the <em>generic
module</em> constructs. These constructs describe circuits like standard
module does but with the addition of parameters that control their
content. They are declared as follows:</p>
<div class="sourceCode" id="cb116"><pre
class="sourceCode ruby"><code class="sourceCode ruby"><span id="cb116-1"><a href="#cb116-1" aria-hidden="true" tabindex="-1"></a><span class="fu">system</span> :<span class="kw">&lt;</span>name<span class="kw">&gt;</span> <span class="cf">do</span> <span class="kw">|&lt;</span>list of parameters<span class="kw">&gt;|</span></span>
<span id="cb116-2"><a href="#cb116-2" aria-hidden="true" tabindex="-1"></a>   <span class="kw">&lt;</span>some hardware description code<span class="kw">&gt;</span></span>
<span id="cb116-3"><a href="#cb116-3" aria-hidden="true" tabindex="-1"></a><span class="cf">end</span></span></code></pre></div>
<p>The list of parameters is simply a list of variable names that can
represent anything, e.g., some values of any type, some data types, or
even some chunks of Ruby or HDLRuby code.</p>
<p>Before being used, a generic module must be specialized by specifying
each of its parameters. This is done as follows:</p>
<div class="sourceCode" id="cb117"><pre
class="sourceCode ruby"><code class="sourceCode ruby"><span id="cb117-1"><a href="#cb117-1" aria-hidden="true" tabindex="-1"></a><span class="kw">&lt;</span>generic <span class="fu">system</span><span class="kw">&gt;</span>(<span class="kw">&lt;</span>list of objects<span class="kw">&gt;</span>)</span></code></pre></div>
<p>Where <code>generic system</code> is the name of the generic module
to specialize.</p>
<p>And there is nothing more to explain since there is no restriction
with the parameters. Instead, here are a couple of examples. First, a
module counting the clock cycles whose counter bit width is a generic
parameter:</p>
<div class="sourceCode" id="cb118"><pre
class="sourceCode ruby"><code class="sourceCode ruby"><span id="cb118-1"><a href="#cb118-1" aria-hidden="true" tabindex="-1"></a><span class="fu">system</span> <span class="wa">:counter</span> <span class="cf">do</span> <span class="kw">|</span>size<span class="kw">|</span></span>
<span id="cb118-2"><a href="#cb118-2" aria-hidden="true" tabindex="-1"></a>   input <span class="wa">:clk</span>, <span class="wa">:rst</span></span>
<span id="cb118-3"><a href="#cb118-3" aria-hidden="true" tabindex="-1"></a>   <span class="kw">[</span>size<span class="kw">]</span><span class="at">.output</span> <span class="wa">:count</span></span>
<span id="cb118-4"><a href="#cb118-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb118-5"><a href="#cb118-5" aria-hidden="true" tabindex="-1"></a>   par(clk<span class="at">.posedge</span>) <span class="cf">do</span></span>
<span id="cb118-6"><a href="#cb118-6" aria-hidden="true" tabindex="-1"></a>      hif(rst) <span class="kw">{</span> count <span class="kw">&lt;=</span> <span class="dv">0</span> <span class="kw">}</span></span>
<span id="cb118-7"><a href="#cb118-7" aria-hidden="true" tabindex="-1"></a>      helse    <span class="kw">{</span> count <span class="kw">&lt;=</span> count <span class="kw">+</span> <span class="dv">1</span> <span class="kw">}</span></span>
<span id="cb118-8"><a href="#cb118-8" aria-hidden="true" tabindex="-1"></a>   <span class="cf">end</span></span>
<span id="cb118-9"><a href="#cb118-9" aria-hidden="true" tabindex="-1"></a><span class="cf">end</span></span></code></pre></div>
<p>If you want to instantiate this circuit, you will need first to
specialize it. For example, here are two instances, named
<code>counterI8</code> and <code>counterI16</code> that have
respectively a 8-bit and a 16-bit output:</p>
<div class="sourceCode" id="cb119"><pre
class="sourceCode ruby"><code class="sourceCode ruby"><span id="cb119-1"><a href="#cb119-1" aria-hidden="true" tabindex="-1"></a>counter(<span class="dv">8</span>)<span class="kw">.</span>(<span class="wa">:counterI8</span>)</span>
<span id="cb119-2"><a href="#cb119-2" aria-hidden="true" tabindex="-1"></a>counter(<span class="dv">16</span>)<span class="kw">.</span>(<span class="wa">:counterI16</span>)</span></code></pre></div>
<p>The second example is again a counter of clock cycles but whose full
data type of the output is a generic parameter (not only its size), and
which has a given value that when reached triggers some hardware code
also provided as a generic parameter:</p>
<div class="sourceCode" id="cb120"><pre
class="sourceCode ruby"><code class="sourceCode ruby"><span id="cb120-1"><a href="#cb120-1" aria-hidden="true" tabindex="-1"></a><span class="fu">system</span> <span class="wa">:counter_ext</span> <span class="cf">do</span> <span class="kw">|</span>typ,trig,code<span class="kw">|</span></span>
<span id="cb120-2"><a href="#cb120-2" aria-hidden="true" tabindex="-1"></a>   input <span class="wa">:clk</span>, <span class="wa">:rst</span></span>
<span id="cb120-3"><a href="#cb120-3" aria-hidden="true" tabindex="-1"></a>   typ<span class="at">.output</span> <span class="wa">:count</span></span>
<span id="cb120-4"><a href="#cb120-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb120-5"><a href="#cb120-5" aria-hidden="true" tabindex="-1"></a>   seq(clk<span class="at">.posedge</span>) <span class="cf">do</span></span>
<span id="cb120-6"><a href="#cb120-6" aria-hidden="true" tabindex="-1"></a>      hif(rst) <span class="kw">{</span> count <span class="kw">&lt;=</span> <span class="dv">0</span> <span class="kw">}</span></span>
<span id="cb120-7"><a href="#cb120-7" aria-hidden="true" tabindex="-1"></a>      helse <span class="cf">do</span></span>
<span id="cb120-8"><a href="#cb120-8" aria-hidden="true" tabindex="-1"></a>         count <span class="kw">&lt;=</span> count <span class="kw">+</span> <span class="dv">1</span></span>
<span id="cb120-9"><a href="#cb120-9" aria-hidden="true" tabindex="-1"></a>         hif(count <span class="kw">==</span> trig) <span class="kw">{</span> code<span class="at">.call</span>(count) <span class="kw">}</span></span>
<span id="cb120-10"><a href="#cb120-10" aria-hidden="true" tabindex="-1"></a>      <span class="cf">end</span></span>
<span id="cb120-11"><a href="#cb120-11" aria-hidden="true" tabindex="-1"></a>   <span class="cf">end</span></span>
<span id="cb120-12"><a href="#cb120-12" aria-hidden="true" tabindex="-1"></a><span class="cf">end</span></span></code></pre></div>
<p>There is more to unwrap here:</p>
<ul>
<li><p><code>typ</code> is the data type of the output, and is therefore
used as is for declaring <code>count</code></p></li>
<li><p><code>trig</code> is the value that will activate the hardware
provided as a generic parameter.</p></li>
<li><p><code>code</code> is a chunk of HDLRuby code. To paste this code
chunk, the <code>call</code> method is used, and for giving access to
the <code>count</code> signal to this code chunk, it is passed as an
argument of the method.</p></li>
</ul>
<p>And here is one instance of this module called
<code>counter_extI</code>, with a 16-bit signed output, a trigger at
value 5, and a triggered code that sets the count to -4:</p>
<div class="sourceCode" id="cb121"><pre
class="sourceCode ruby"><code class="sourceCode ruby"><span id="cb121-1"><a href="#cb121-1" aria-hidden="true" tabindex="-1"></a><span class="fu">system</span> <span class="wa">:counter_ext_sim</span> <span class="cf">do</span></span>
<span id="cb121-2"><a href="#cb121-2" aria-hidden="true" tabindex="-1"></a>   inner <span class="wa">:clk</span>,<span class="wa">:rst</span></span>
<span id="cb121-3"><a href="#cb121-3" aria-hidden="true" tabindex="-1"></a>   signed<span class="kw">[</span><span class="dv">16</span><span class="kw">]</span><span class="at">.inner</span> <span class="wa">:count</span></span>
<span id="cb121-4"><a href="#cb121-4" aria-hidden="true" tabindex="-1"></a>   counter_ext(signed<span class="kw">[</span><span class="dv">16</span><span class="kw">]</span>,<span class="dv">5</span>, <span class="fu">proc</span> <span class="kw">{</span> <span class="kw">|</span>count<span class="kw">|</span> count <span class="kw">&lt;=</span> <span class="kw">-</span><span class="dv">4</span> <span class="kw">}</span>)<span class="kw">.</span>(<span class="wa">:counter_extI</span>)<span class="kw">.</span>(clk,rst,count)</span>
<span id="cb121-5"><a href="#cb121-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb121-6"><a href="#cb121-6" aria-hidden="true" tabindex="-1"></a>   timed <span class="cf">do</span></span>
<span id="cb121-7"><a href="#cb121-7" aria-hidden="true" tabindex="-1"></a>      clk <span class="kw">&lt;=</span> <span class="dv">0</span></span>
<span id="cb121-8"><a href="#cb121-8" aria-hidden="true" tabindex="-1"></a>      rst <span class="kw">&lt;=</span> <span class="dv">0</span></span>
<span id="cb121-9"><a href="#cb121-9" aria-hidden="true" tabindex="-1"></a>      !<span class="dv">10</span><span class="at">.ns</span></span>
<span id="cb121-10"><a href="#cb121-10" aria-hidden="true" tabindex="-1"></a>      clk <span class="kw">&lt;=</span> <span class="dv">1</span></span>
<span id="cb121-11"><a href="#cb121-11" aria-hidden="true" tabindex="-1"></a>      !<span class="dv">10</span><span class="at">.ns</span></span>
<span id="cb121-12"><a href="#cb121-12" aria-hidden="true" tabindex="-1"></a>      clk <span class="kw">&lt;=</span> <span class="dv">0</span></span>
<span id="cb121-13"><a href="#cb121-13" aria-hidden="true" tabindex="-1"></a>      rst <span class="kw">&lt;=</span> <span class="dv">1</span></span>
<span id="cb121-14"><a href="#cb121-14" aria-hidden="true" tabindex="-1"></a>      !<span class="dv">10</span><span class="at">.ns</span></span>
<span id="cb121-15"><a href="#cb121-15" aria-hidden="true" tabindex="-1"></a>      clk <span class="kw">&lt;=</span> <span class="dv">1</span></span>
<span id="cb121-16"><a href="#cb121-16" aria-hidden="true" tabindex="-1"></a>      !<span class="dv">10</span><span class="at">.ns</span></span>
<span id="cb121-17"><a href="#cb121-17" aria-hidden="true" tabindex="-1"></a>      clk <span class="kw">&lt;=</span> <span class="dv">0</span></span>
<span id="cb121-18"><a href="#cb121-18" aria-hidden="true" tabindex="-1"></a>      rst <span class="kw">&lt;=</span> <span class="dv">0</span></span>
<span id="cb121-19"><a href="#cb121-19" aria-hidden="true" tabindex="-1"></a>      repeat(<span class="dv">20</span>) <span class="kw">{ !</span><span class="dv">10</span><span class="at">.ns</span>; clk <span class="kw">&lt;=</span> <span class="kw">~</span>clk <span class="kw">}</span></span>
<span id="cb121-20"><a href="#cb121-20" aria-hidden="true" tabindex="-1"></a>      !<span class="dv">10</span><span class="at">.ns</span></span>
<span id="cb121-21"><a href="#cb121-21" aria-hidden="true" tabindex="-1"></a>   <span class="cf">end</span></span>
<span id="cb121-22"><a href="#cb121-22" aria-hidden="true" tabindex="-1"></a><span class="cf">end</span></span></code></pre></div>
<p>In this code, the syntax <code>proc &lt;block&gt;</code> is for
creating a chunk of HDLRuby (or Ruby) code from the content of
<code>block</code>. With this environment, the simulation result should
be:</p>
<p align="center">
<img data-name="hruby_simulator.vcd" src="counter_ext_vcd.png"  width="80%">
</p>
<h3 id="object-oriented-programming-in-hdlruby">6.2. Object-oriented
programming in HDLRuby</h3>
<p>Genericity allows using a single design for several different
circuits but it does not allow modifying this design. This possibility
is brought by object-oriented programming and its key concept: <a
href="#621-inheritance">inheritance</a>. With it, it is possible to
modify afterward a circuit design without touching the original
description, to define a new circuit based on an original one without
redoing everything from scratch, and to change a single instance of a
circuit without influencing the other ones, all that with a simple <a
href="#622-modifying-a-module-or-an-instance">construct</a>. Finally, it
is possible under certain conditions to <a
href="#623-overriding">reimplement parts of the code</a>.</p>
<h4 id="inheritance">6.2.1 Inheritance</h4>
<p>In HDLRuby, inheritance can be applied to modules. When a module
inherits from another one, the latter is called its <em>superclass
module</em>. By default, a module contains all the ports and all the
content of its superclass modules. Then, new ports or content can be
added to the later at will. Inheritance is declared as follows:</p>
<div class="sourceCode" id="cb122"><pre
class="sourceCode ruby"><code class="sourceCode ruby"><span id="cb122-1"><a href="#cb122-1" aria-hidden="true" tabindex="-1"></a><span class="fu">system</span> :<span class="kw">&lt;</span>name<span class="kw">&gt;</span>, <span class="kw">&lt;</span>list of superclass modules<span class="kw">&gt;</span> <span class="kw">&lt;</span>block<span class="kw">&gt;</span></span></code></pre></div>
<p>Alternatively, the following syntax is also possible:</p>
<div class="sourceCode" id="cb123"><pre
class="sourceCode ruby"><code class="sourceCode ruby"><span id="cb123-1"><a href="#cb123-1" aria-hidden="true" tabindex="-1"></a><span class="fu">system</span> :<span class="kw">&lt;</span>name<span class="kw">&gt;</span> <span class="cf">do</span></span>
<span id="cb123-2"><a href="#cb123-2" aria-hidden="true" tabindex="-1"></a>   <span class="fu">include</span> <span class="kw">&lt;</span>list of superclass modules<span class="kw">&gt;</span></span>
<span id="cb123-3"><a href="#cb123-3" aria-hidden="true" tabindex="-1"></a>   <span class="kw">&lt;</span><span class="dt">HDLRuby</span> code<span class="kw">&gt;</span></span>
<span id="cb123-4"><a href="#cb123-4" aria-hidden="true" tabindex="-1"></a><span class="cf">end</span></span></code></pre></div>
<p>For example, let us consider the following 8-bit adder/subtracter
module:</p>
<div class="sourceCode" id="cb124"><pre
class="sourceCode ruby"><code class="sourceCode ruby"><span id="cb124-1"><a href="#cb124-1" aria-hidden="true" tabindex="-1"></a><span class="fu">system</span> <span class="wa">:addsub8</span> <span class="cf">do</span></span>
<span id="cb124-2"><a href="#cb124-2" aria-hidden="true" tabindex="-1"></a>   input <span class="wa">:s</span></span>
<span id="cb124-3"><a href="#cb124-3" aria-hidden="true" tabindex="-1"></a>   signed<span class="kw">[</span><span class="dv">8</span><span class="kw">]</span><span class="at">.input</span> <span class="wa">:x</span>, <span class="wa">:y</span></span>
<span id="cb124-4"><a href="#cb124-4" aria-hidden="true" tabindex="-1"></a>   signed<span class="kw">[</span><span class="dv">8</span><span class="kw">]</span><span class="at">.output</span> <span class="wa">:z</span></span>
<span id="cb124-5"><a href="#cb124-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb124-6"><a href="#cb124-6" aria-hidden="true" tabindex="-1"></a>   par <span class="cf">do</span></span>
<span id="cb124-7"><a href="#cb124-7" aria-hidden="true" tabindex="-1"></a>      hif(s) <span class="kw">{</span> z <span class="kw">&lt;=</span> x <span class="kw">-</span> y <span class="kw">}</span></span>
<span id="cb124-8"><a href="#cb124-8" aria-hidden="true" tabindex="-1"></a>      helse  <span class="kw">{</span> z <span class="kw">&lt;=</span> x <span class="kw">+</span> y <span class="kw">}</span></span>
<span id="cb124-9"><a href="#cb124-9" aria-hidden="true" tabindex="-1"></a>   <span class="cf">end</span></span>
<span id="cb124-10"><a href="#cb124-10" aria-hidden="true" tabindex="-1"></a><span class="cf">end</span></span></code></pre></div>
<p>And let us assume we want to design a new 8-bit adder/subtracter
module that also outputs a zero flag. That can be done with inheritance
as follows:</p>
<div class="sourceCode" id="cb125"><pre
class="sourceCode ruby"><code class="sourceCode ruby"><span id="cb125-1"><a href="#cb125-1" aria-hidden="true" tabindex="-1"></a><span class="fu">system</span> <span class="wa">:addsub_zf8</span>, addsub8 <span class="cf">do</span></span>
<span id="cb125-2"><a href="#cb125-2" aria-hidden="true" tabindex="-1"></a>   output <span class="wa">:zf</span></span>
<span id="cb125-3"><a href="#cb125-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb125-4"><a href="#cb125-4" aria-hidden="true" tabindex="-1"></a>   zf <span class="kw">&lt;=</span> (z <span class="kw">==</span> <span class="dv">0</span>)</span>
<span id="cb125-5"><a href="#cb125-5" aria-hidden="true" tabindex="-1"></a><span class="cf">end</span></span></code></pre></div>
<p>So why is there an alternate syntax with the <code>include</code>
keyword? This is for easing the mix of genericity and inheritance. For
example, the previous circuit was 8-bit only. What if you want to do the
same with generic input and output widths? For the initial counter, this
is straightforward:</p>
<div class="sourceCode" id="cb126"><pre
class="sourceCode ruby"><code class="sourceCode ruby"><span id="cb126-1"><a href="#cb126-1" aria-hidden="true" tabindex="-1"></a><span class="fu">system</span> <span class="wa">:addsub</span> <span class="cf">do</span> <span class="kw">|</span>width<span class="kw">|</span></span>
<span id="cb126-2"><a href="#cb126-2" aria-hidden="true" tabindex="-1"></a>   inner <span class="wa">:s</span></span>
<span id="cb126-3"><a href="#cb126-3" aria-hidden="true" tabindex="-1"></a>   <span class="kw">[</span>width<span class="kw">]</span><span class="at">.input</span> <span class="wa">:x</span>, <span class="wa">:y</span></span>
<span id="cb126-4"><a href="#cb126-4" aria-hidden="true" tabindex="-1"></a>   <span class="kw">[</span>width<span class="kw">]</span><span class="at">.output</span> <span class="wa">:z</span></span>
<span id="cb126-5"><a href="#cb126-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb126-6"><a href="#cb126-6" aria-hidden="true" tabindex="-1"></a>   par <span class="cf">do</span></span>
<span id="cb126-7"><a href="#cb126-7" aria-hidden="true" tabindex="-1"></a>      hif(s) <span class="kw">{</span> z <span class="kw">&lt;=</span> x <span class="kw">-</span> y <span class="kw">}</span></span>
<span id="cb126-8"><a href="#cb126-8" aria-hidden="true" tabindex="-1"></a>      helse  <span class="kw">{</span> z <span class="kw">&lt;=</span> x <span class="kw">+</span> y <span class="kw">}</span></span>
<span id="cb126-9"><a href="#cb126-9" aria-hidden="true" tabindex="-1"></a>   <span class="cf">end</span></span>
<span id="cb126-10"><a href="#cb126-10" aria-hidden="true" tabindex="-1"></a><span class="cf">end</span></span></code></pre></div>
<p>But for the second one? It needs to transmit its generic parameter to
its superclass module, but the parameter is only available within its
block description. In such a case, the second syntax is useful:</p>
<div class="sourceCode" id="cb127"><pre
class="sourceCode ruby"><code class="sourceCode ruby"><span id="cb127-1"><a href="#cb127-1" aria-hidden="true" tabindex="-1"></a><span class="fu">system</span> <span class="wa">:addsub_zf</span> <span class="cf">do</span> <span class="kw">|</span>width<span class="kw">|</span></span>
<span id="cb127-2"><a href="#cb127-2" aria-hidden="true" tabindex="-1"></a>   <span class="fu">include</span> addsub(width)</span>
<span id="cb127-3"><a href="#cb127-3" aria-hidden="true" tabindex="-1"></a>   output <span class="wa">:zf</span></span>
<span id="cb127-4"><a href="#cb127-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb127-5"><a href="#cb127-5" aria-hidden="true" tabindex="-1"></a>   zf <span class="kw">&lt;=</span> (z <span class="kw">==</span> <span class="dv">0</span>)</span>
<span id="cb127-6"><a href="#cb127-6" aria-hidden="true" tabindex="-1"></a><span class="cf">end</span></span></code></pre></div>
<h4 id="modifying-a-module-or-an-instance">6.2.2. Modifying a module or
an instance</h4>
<p>Let us assume that you think that after all, the adder-subtracter
circuit you described previously should definitively have a
<code>zf</code> flag for your new project. You can of course create a
new module with inheritance for that, but you can also modify afterward
the initial <code>addsub</code> module using the <code>open</code>
method as follows:</p>
<div class="sourceCode" id="cb128"><pre
class="sourceCode ruby"><code class="sourceCode ruby"><span id="cb128-1"><a href="#cb128-1" aria-hidden="true" tabindex="-1"></a>addsub<span class="at">.open</span> <span class="cf">do</span></span>
<span id="cb128-2"><a href="#cb128-2" aria-hidden="true" tabindex="-1"></a>   output <span class="wa">:zf</span></span>
<span id="cb128-3"><a href="#cb128-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb128-4"><a href="#cb128-4" aria-hidden="true" tabindex="-1"></a>   zf <span class="kw">&lt;=</span> (z <span class="kw">==</span> <span class="dv">0</span>)</span>
<span id="cb128-5"><a href="#cb128-5" aria-hidden="true" tabindex="-1"></a><span class="cf">end</span></span></code></pre></div>
<p>After that, all the instances that are created from
<code>addsub</code> will include the <code>zf</code> flag computation
and output.</p>
<p>In contrast, you may want only one instance to have the flag. In such
a case, it may not be necessary to define a new module for that but just
modify this instance only. This is possible using again the
<code>open</code> method but on the instance. For example with the
instance used in the following simulation environment:</p>
<div class="sourceCode" id="cb129"><pre
class="sourceCode ruby"><code class="sourceCode ruby"><span id="cb129-1"><a href="#cb129-1" aria-hidden="true" tabindex="-1"></a><span class="fu">system</span> <span class="wa">:addsub_sim</span> <span class="cf">do</span></span>
<span id="cb129-2"><a href="#cb129-2" aria-hidden="true" tabindex="-1"></a>   signed<span class="kw">[</span><span class="dv">8</span><span class="kw">]</span><span class="at">.inner</span> <span class="wa">:x</span>, <span class="wa">:y</span>, <span class="wa">:z</span></span>
<span id="cb129-3"><a href="#cb129-3" aria-hidden="true" tabindex="-1"></a>   inner <span class="wa">:zf</span>, <span class="wa">:s</span></span>
<span id="cb129-4"><a href="#cb129-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb129-5"><a href="#cb129-5" aria-hidden="true" tabindex="-1"></a>   addsub(signed<span class="kw">[</span><span class="dv">8</span><span class="kw">]</span>)<span class="kw">.</span>(<span class="wa">:addsubI8</span>)<span class="kw">.</span>(s,x,y,z)</span>
<span id="cb129-6"><a href="#cb129-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb129-7"><a href="#cb129-7" aria-hidden="true" tabindex="-1"></a>   addsubI8<span class="at">.open</span> <span class="cf">do</span></span>
<span id="cb129-8"><a href="#cb129-8" aria-hidden="true" tabindex="-1"></a>      output <span class="wa">:zf</span></span>
<span id="cb129-9"><a href="#cb129-9" aria-hidden="true" tabindex="-1"></a>   </span>
<span id="cb129-10"><a href="#cb129-10" aria-hidden="true" tabindex="-1"></a>      zf <span class="kw">&lt;=</span> (z <span class="kw">==</span> <span class="dv">0</span>)</span>
<span id="cb129-11"><a href="#cb129-11" aria-hidden="true" tabindex="-1"></a>   <span class="cf">end</span></span>
<span id="cb129-12"><a href="#cb129-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb129-13"><a href="#cb129-13" aria-hidden="true" tabindex="-1"></a>   zf <span class="kw">&lt;=</span> addsubI8<span class="at">.zf</span></span>
<span id="cb129-14"><a href="#cb129-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb129-15"><a href="#cb129-15" aria-hidden="true" tabindex="-1"></a>   timed <span class="cf">do</span></span>
<span id="cb129-16"><a href="#cb129-16" aria-hidden="true" tabindex="-1"></a>      x <span class="kw">&lt;=</span> <span class="dv">0</span></span>
<span id="cb129-17"><a href="#cb129-17" aria-hidden="true" tabindex="-1"></a>      y <span class="kw">&lt;=</span> <span class="dv">0</span></span>
<span id="cb129-18"><a href="#cb129-18" aria-hidden="true" tabindex="-1"></a>      s <span class="kw">&lt;=</span> <span class="dv">0</span></span>
<span id="cb129-19"><a href="#cb129-19" aria-hidden="true" tabindex="-1"></a>      repeat(<span class="dv">3</span>) <span class="kw">{ !</span><span class="dv">10</span><span class="at">.ns</span>; x <span class="kw">&lt;=</span> x <span class="kw">+</span> <span class="dv">1</span> <span class="kw">}</span></span>
<span id="cb129-20"><a href="#cb129-20" aria-hidden="true" tabindex="-1"></a>      repeat(<span class="dv">3</span>) <span class="kw">{ !</span><span class="dv">10</span><span class="at">.ns</span>; y <span class="kw">&lt;=</span> y <span class="kw">+</span> <span class="dv">1</span> <span class="kw">}</span></span>
<span id="cb129-21"><a href="#cb129-21" aria-hidden="true" tabindex="-1"></a>      s <span class="kw">&lt;=</span> <span class="dv">1</span></span>
<span id="cb129-22"><a href="#cb129-22" aria-hidden="true" tabindex="-1"></a>      repeat(<span class="dv">3</span>) <span class="kw">{ !</span><span class="dv">10</span><span class="at">.ns</span>; x <span class="kw">&lt;=</span> x <span class="kw">-</span> <span class="dv">1</span> <span class="kw">}</span></span>
<span id="cb129-23"><a href="#cb129-23" aria-hidden="true" tabindex="-1"></a>      repeat(<span class="dv">3</span>) <span class="kw">{ !</span><span class="dv">10</span><span class="at">.ns</span>; y <span class="kw">&lt;=</span> y <span class="kw">-</span> <span class="dv">1</span> <span class="kw">}</span></span>
<span id="cb129-24"><a href="#cb129-24" aria-hidden="true" tabindex="-1"></a>      !<span class="dv">10</span><span class="at">.ns</span></span>
<span id="cb129-25"><a href="#cb129-25" aria-hidden="true" tabindex="-1"></a>   <span class="cf">end</span></span>
<span id="cb129-26"><a href="#cb129-26" aria-hidden="true" tabindex="-1"></a><span class="cf">end</span></span></code></pre></div>
<p>And the simulation result should be:</p>
<p align="center">
<img data-name="hruby_simulator.vcd" src="addsub_vcd.png"  width="80%">
</p>
<h4 id="overriding">6.2.3. Overriding</h4>
<p>Let us consider the following circuit that performs an addition a
computes four flags:</p>
<div class="sourceCode" id="cb130"><pre
class="sourceCode ruby"><code class="sourceCode ruby"><span id="cb130-1"><a href="#cb130-1" aria-hidden="true" tabindex="-1"></a><span class="fu">system</span> <span class="wa">:adder_flags</span> <span class="cf">do</span> <span class="kw">|</span>width<span class="kw">|</span></span>
<span id="cb130-2"><a href="#cb130-2" aria-hidden="true" tabindex="-1"></a>   signed<span class="kw">[</span>width<span class="kw">]</span><span class="at">.input</span> <span class="wa">:x</span>, <span class="wa">:y</span></span>
<span id="cb130-3"><a href="#cb130-3" aria-hidden="true" tabindex="-1"></a>   signed<span class="kw">[</span>width<span class="kw">]</span><span class="at">.output</span> <span class="wa">:z</span></span>
<span id="cb130-4"><a href="#cb130-4" aria-hidden="true" tabindex="-1"></a>   output <span class="wa">:cf</span>, <span class="wa">:zf</span>, <span class="wa">:sf</span>, <span class="wa">:of</span></span>
<span id="cb130-5"><a href="#cb130-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb130-6"><a href="#cb130-6" aria-hidden="true" tabindex="-1"></a>   <span class="kw">[</span>cf,z<span class="kw">]</span> <span class="kw">&lt;=</span> x<span class="at">.as</span>(signed<span class="kw">[</span>width<span class="kw">+</span><span class="dv">1</span><span class="kw">]</span>) <span class="kw">+</span> y</span>
<span id="cb130-7"><a href="#cb130-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb130-8"><a href="#cb130-8" aria-hidden="true" tabindex="-1"></a>   zf <span class="kw">&lt;=</span> (z <span class="kw">==</span> <span class="dv">0</span>)</span>
<span id="cb130-9"><a href="#cb130-9" aria-hidden="true" tabindex="-1"></a>   sf <span class="kw">&lt;=</span> z<span class="kw">[-</span><span class="dv">1</span><span class="kw">]</span></span>
<span id="cb130-10"><a href="#cb130-10" aria-hidden="true" tabindex="-1"></a>   of <span class="kw">&lt;=</span> (x<span class="kw">[-</span><span class="dv">1</span><span class="kw">]</span> <span class="kw">&amp;</span> y<span class="kw">[-</span><span class="dv">1</span><span class="kw">]</span> <span class="kw">&amp;</span> <span class="kw">~</span>z<span class="kw">[-</span><span class="dv">1</span><span class="kw">]</span>) <span class="kw">|</span> (<span class="kw">~</span>x<span class="kw">[-</span><span class="dv">1</span><span class="kw">]</span> <span class="kw">&amp;</span> <span class="kw">~</span>y<span class="kw">[-</span><span class="dv">1</span><span class="kw">]</span> <span class="kw">&amp;</span> z<span class="kw">[-</span><span class="dv">1</span><span class="kw">]</span>)</span>
<span id="cb130-11"><a href="#cb130-11" aria-hidden="true" tabindex="-1"></a><span class="cf">end</span></span></code></pre></div>
<p>Let us also assume that we want to make a circuit that does the same
but saturates the addition result between -300 and +300. For that
purpose, the computation of <code>z</code> must be replaced. This is
called <code>overriding</code> and for the sake of code readability
overriding is only permitted for <em>named sub-sections</em> of a
module. A named subsection is declared as follows:</p>
<div class="sourceCode" id="cb131"><pre
class="sourceCode ruby"><code class="sourceCode ruby"><span id="cb131-1"><a href="#cb131-1" aria-hidden="true" tabindex="-1"></a><span class="fu">sub</span>(:<span class="kw">&lt;</span>name<span class="kw">&gt;</span>) <span class="kw">&lt;</span>block<span class="kw">&gt;</span></span></code></pre></div>
<p>Where <code>block</code> can contain any HDLRuby code apart from the
port definition. A named subsection can be overridden anywhere in the
code, and also in subclass modules by redefining it. In our previous
example, if <code>adder_flags</code> is rewritten as follows:</p>
<div class="sourceCode" id="cb132"><pre
class="sourceCode ruby"><code class="sourceCode ruby"><span id="cb132-1"><a href="#cb132-1" aria-hidden="true" tabindex="-1"></a><span class="fu">system</span> <span class="wa">:adder_flags</span> <span class="cf">do</span> <span class="kw">|</span>width<span class="kw">|</span></span>
<span id="cb132-2"><a href="#cb132-2" aria-hidden="true" tabindex="-1"></a>   signed<span class="kw">[</span>width<span class="kw">]</span><span class="at">.input</span> <span class="wa">:x</span>, <span class="wa">:y</span></span>
<span id="cb132-3"><a href="#cb132-3" aria-hidden="true" tabindex="-1"></a>   signed<span class="kw">[</span>width<span class="kw">]</span><span class="at">.output</span> <span class="wa">:z</span></span>
<span id="cb132-4"><a href="#cb132-4" aria-hidden="true" tabindex="-1"></a>   output <span class="wa">:cf</span>, <span class="wa">:zf</span>, <span class="wa">:sf</span>, <span class="wa">:of</span></span>
<span id="cb132-5"><a href="#cb132-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb132-6"><a href="#cb132-6" aria-hidden="true" tabindex="-1"></a>   <span class="fu">sub</span>(<span class="wa">:add</span>) <span class="cf">do</span></span>
<span id="cb132-7"><a href="#cb132-7" aria-hidden="true" tabindex="-1"></a>      <span class="kw">[</span>cf,z<span class="kw">]</span> <span class="kw">&lt;=</span> x<span class="at">.as</span>(signed<span class="kw">[</span>width<span class="kw">+</span><span class="dv">1</span><span class="kw">]</span>) <span class="kw">+</span> y</span>
<span id="cb132-8"><a href="#cb132-8" aria-hidden="true" tabindex="-1"></a>   <span class="cf">end</span></span>
<span id="cb132-9"><a href="#cb132-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb132-10"><a href="#cb132-10" aria-hidden="true" tabindex="-1"></a>   zf <span class="kw">&lt;=</span> (z <span class="kw">==</span> <span class="dv">0</span>)</span>
<span id="cb132-11"><a href="#cb132-11" aria-hidden="true" tabindex="-1"></a>   sf <span class="kw">&lt;=</span> z<span class="kw">[-</span><span class="dv">1</span><span class="kw">]</span></span>
<span id="cb132-12"><a href="#cb132-12" aria-hidden="true" tabindex="-1"></a>   of <span class="kw">&lt;=</span> (x<span class="kw">[-</span><span class="dv">1</span><span class="kw">]</span> <span class="kw">&amp;</span> y<span class="kw">[-</span><span class="dv">1</span><span class="kw">]</span> <span class="kw">&amp;</span> <span class="kw">~</span>z<span class="kw">[-</span><span class="dv">1</span><span class="kw">]</span>) <span class="kw">|</span> (<span class="kw">~</span>x<span class="kw">[-</span><span class="dv">1</span><span class="kw">]</span> <span class="kw">&amp;</span> <span class="kw">~</span>y<span class="kw">[-</span><span class="dv">1</span><span class="kw">]</span> <span class="kw">&amp;</span> z<span class="kw">[-</span><span class="dv">1</span><span class="kw">]</span>)</span>
<span id="cb132-13"><a href="#cb132-13" aria-hidden="true" tabindex="-1"></a><span class="cf">end</span></span></code></pre></div>
<p>Then a new module with saturated addition can be defined as follows
using inheritance and overriding:</p>
<div class="sourceCode" id="cb133"><pre
class="sourceCode ruby"><code class="sourceCode ruby"><span id="cb133-1"><a href="#cb133-1" aria-hidden="true" tabindex="-1"></a><span class="fu">system</span> <span class="wa">:adder_sat_flags</span> <span class="cf">do</span> <span class="kw">|</span>width<span class="kw">|</span></span>
<span id="cb133-2"><a href="#cb133-2" aria-hidden="true" tabindex="-1"></a>   <span class="fu">include</span> adder_flags(width)</span>
<span id="cb133-3"><a href="#cb133-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb133-4"><a href="#cb133-4" aria-hidden="true" tabindex="-1"></a>   <span class="fu">sub</span>(<span class="wa">:add</span>) <span class="cf">do</span></span>
<span id="cb133-5"><a href="#cb133-5" aria-hidden="true" tabindex="-1"></a>      seq <span class="cf">do</span></span>
<span id="cb133-6"><a href="#cb133-6" aria-hidden="true" tabindex="-1"></a>         <span class="kw">[</span>cf,z<span class="kw">]</span> <span class="kw">&lt;=</span> x<span class="at">.as</span>(signed<span class="kw">[</span>width<span class="kw">+</span><span class="dv">1</span><span class="kw">]</span>) <span class="kw">+</span> y</span>
<span id="cb133-7"><a href="#cb133-7" aria-hidden="true" tabindex="-1"></a>         hif(z<span class="kw">&lt;-</span><span class="dv">300</span>) <span class="kw">{</span> z <span class="kw">&lt;=</span> <span class="kw">-</span><span class="dv">300</span> <span class="kw">}</span></span>
<span id="cb133-8"><a href="#cb133-8" aria-hidden="true" tabindex="-1"></a>         hif(z<span class="kw">&gt;</span><span class="dv">300</span>)  <span class="kw">{</span> z <span class="kw">&lt;=</span> <span class="dv">300</span> <span class="kw">}</span></span>
<span id="cb133-9"><a href="#cb133-9" aria-hidden="true" tabindex="-1"></a>      <span class="cf">end</span></span>
<span id="cb133-10"><a href="#cb133-10" aria-hidden="true" tabindex="-1"></a>   <span class="cf">end</span></span>
<span id="cb133-11"><a href="#cb133-11" aria-hidden="true" tabindex="-1"></a><span class="cf">end</span></span></code></pre></div>
<p>If you wish to see how this adder with saturation works, here is a
simple simulation environment for it:</p>
<div class="sourceCode" id="cb134"><pre
class="sourceCode ruby"><code class="sourceCode ruby"><span id="cb134-1"><a href="#cb134-1" aria-hidden="true" tabindex="-1"></a><span class="fu">system</span> <span class="wa">:adder_sat_flags_sim</span> <span class="cf">do</span></span>
<span id="cb134-2"><a href="#cb134-2" aria-hidden="true" tabindex="-1"></a>   signed<span class="kw">[</span><span class="dv">16</span><span class="kw">]</span><span class="at">.inner</span> <span class="wa">:x</span>, <span class="wa">:y</span>, <span class="wa">:z</span></span>
<span id="cb134-3"><a href="#cb134-3" aria-hidden="true" tabindex="-1"></a>   inner <span class="wa">:cf</span>, <span class="wa">:zf</span>, <span class="wa">:sf</span>, <span class="wa">:of</span></span>
<span id="cb134-4"><a href="#cb134-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb134-5"><a href="#cb134-5" aria-hidden="true" tabindex="-1"></a>   adder_sat_flags(<span class="dv">16</span>)<span class="kw">.</span>(<span class="wa">:adderI</span>)<span class="kw">.</span>(x,y,z,cf,zf,sf,of)</span>
<span id="cb134-6"><a href="#cb134-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb134-7"><a href="#cb134-7" aria-hidden="true" tabindex="-1"></a>   timed <span class="cf">do</span></span>
<span id="cb134-8"><a href="#cb134-8" aria-hidden="true" tabindex="-1"></a>      x <span class="kw">&lt;=</span> <span class="dv">0</span></span>
<span id="cb134-9"><a href="#cb134-9" aria-hidden="true" tabindex="-1"></a>      y <span class="kw">&lt;=</span> <span class="dv">0</span></span>
<span id="cb134-10"><a href="#cb134-10" aria-hidden="true" tabindex="-1"></a>      repeat(<span class="dv">3</span>) <span class="kw">{ !</span><span class="dv">10</span><span class="at">.ns</span>; x <span class="kw">&lt;=</span> x <span class="kw">+</span> <span class="dv">1</span> <span class="kw">}</span></span>
<span id="cb134-11"><a href="#cb134-11" aria-hidden="true" tabindex="-1"></a>      repeat(<span class="dv">3</span>) <span class="kw">{ !</span><span class="dv">10</span><span class="at">.ns</span>; y <span class="kw">&lt;=</span> y <span class="kw">+</span> <span class="dv">1</span> <span class="kw">}</span></span>
<span id="cb134-12"><a href="#cb134-12" aria-hidden="true" tabindex="-1"></a>      !<span class="dv">10</span><span class="at">.ns</span></span>
<span id="cb134-13"><a href="#cb134-13" aria-hidden="true" tabindex="-1"></a>      x <span class="kw">&lt;=</span> <span class="dv">299</span></span>
<span id="cb134-14"><a href="#cb134-14" aria-hidden="true" tabindex="-1"></a>      y <span class="kw">&lt;=</span> <span class="dv">0</span></span>
<span id="cb134-15"><a href="#cb134-15" aria-hidden="true" tabindex="-1"></a>      repeat(<span class="dv">3</span>) <span class="kw">{ !</span><span class="dv">10</span><span class="at">.ns</span>; x <span class="kw">&lt;=</span> x <span class="kw">+</span> <span class="dv">1</span> <span class="kw">}</span></span>
<span id="cb134-16"><a href="#cb134-16" aria-hidden="true" tabindex="-1"></a>      !<span class="dv">10</span><span class="at">.ns</span></span>
<span id="cb134-17"><a href="#cb134-17" aria-hidden="true" tabindex="-1"></a>      x <span class="kw">&lt;=</span> <span class="kw">-</span><span class="dv">1</span></span>
<span id="cb134-18"><a href="#cb134-18" aria-hidden="true" tabindex="-1"></a>      y <span class="kw">&lt;=</span> <span class="kw">-</span><span class="dv">300</span></span>
<span id="cb134-19"><a href="#cb134-19" aria-hidden="true" tabindex="-1"></a>      repeat(<span class="dv">3</span>) <span class="kw">{ !</span><span class="dv">10</span><span class="at">.ns</span>; x <span class="kw">&lt;=</span> x <span class="kw">+</span> <span class="dv">1</span> <span class="kw">}</span></span>
<span id="cb134-20"><a href="#cb134-20" aria-hidden="true" tabindex="-1"></a>      !<span class="dv">10</span><span class="at">.ns</span></span>
<span id="cb134-21"><a href="#cb134-21" aria-hidden="true" tabindex="-1"></a>   <span class="cf">end</span></span>
<span id="cb134-22"><a href="#cb134-22" aria-hidden="true" tabindex="-1"></a><span class="cf">end</span></span></code></pre></div>
<p>And the simulation result should be:</p>
<p align="center">
<img data-name="hruby_simulator.vcd" src="adder_sat_flags_vcd.png"  width="80%">
</p>
<p><strong>Note</strong>: with this circuit, the <code>of</code> flag
(overflow) is always 0 because there cannot be any overflow for a 10-bit
number with saturation at -300, 300.</p>
<h3 id="metaprogramming-and-reflection-in-hdlruby">6.3. Metaprogramming
and reflection in HDLRuby</h3>
<p>There is not much to say about metaprogramming and reflection because
both have been used extensively in this tutorial.</p>
<ul>
<li><p>Metaprogramming consists of using programs that generate the
final code. In HDLRuby, this is done by using Ruby code for generating,
passing as an argument, and appending chunks of HDLRuby code. This has
been done when presenting how to describe parallel code in sequencers,
but this can be used everywhere, e.g., within the general processes.
Moreover, the possibility to use a chunk of code as a generic argument
presented in this section is also metaprogramming.</p></li>
<li><p>Reflection has been used in several cases, e.g., the
<code>width</code> method for knowing the bit width of a type or the
<code>open</code> method. More generally, HDLRuby provides a large
number of methods for inspecting and modifying directly the objects of
the internal representation. Please consult the documentation of the
HDLRuby classes for details about them (good luck, this is low-level
coding documentation).</p></li>
</ul>
<blockquote>
<p><strong>Note</strong>: the sequencers, the shared signals, the
arbiter, and the monitor are not native HDLRuby constructs, they have
all been implemented with metaprogramming and reflection.</p>
</blockquote>
<h2 id="how-to-mix-hardware-and-software.">7. How to mix hardware and
software.</h2>
<p>Digital electronic devices often contain one of several processors
for executing software. That makes then more versatile and easier to
update or fix. However, designing a mix of software and hardware
(hardware-software co-design) can be challenging, especially because
both worlds use different languages and models of computation.</p>
<p>For HDLRuby, the mix of hardware and software is done using a
construct, called a program, that provides a basic communication
interface made of registers and interrupts. This interface can then be
extended both on the hardware and the software side to support more
complex interactions.</p>
<h3 id="the-program-construct">7.1. The Program construct</h3>
<p>A program construct, like the processes or the sequencers, is
declared within a module, but unlike them, its content is not some code
description (neither hardware nor software), but instead a description
of its hardware-software interface.</p>
<p>More specifically, a program is declared as follows:</p>
<div class="sourceCode" id="cb135"><pre
class="sourceCode ruby"><code class="sourceCode ruby"><span id="cb135-1"><a href="#cb135-1" aria-hidden="true" tabindex="-1"></a>program(<span class="kw">&lt;</span>programming language<span class="kw">&gt;</span>, <span class="kw">&lt;</span>function name<span class="kw">&gt;</span>) <span class="cf">do</span></span>
<span id="cb135-2"><a href="#cb135-2" aria-hidden="true" tabindex="-1"></a>   <span class="kw">&lt;</span>location of the software files <span class="cf">and</span> description of its interface<span class="kw">&gt;</span></span>
<span id="cb135-3"><a href="#cb135-3" aria-hidden="true" tabindex="-1"></a><span class="cf">end</span></span></code></pre></div>
<p>In the code above, <code>programming language</code> is a symbol
representing the programming language used for the software. For now,
only two languages are supported:</p>
<ul>
<li><p><code>:ruby</code>: for programs in Ruby.</p></li>
<li><p><code>:c</code>: for programs in C. However, for this case, any
language that can be compiled to a shared library linkable with C is
supported.</p></li>
</ul>
<p>The <code>function name</code> parameter indicates which function is
to be executed when an activation event occurs. There can be only one
such function per program, but any number of programs can be declared
inside the same module.</p>
<p>The
<code>location of the software files and description of its interface</code>
part can include the following declaration statements:</p>
<ul>
<li><p><code>actport &lt;list of events&gt;</code>: for declaring the
list of events that activates the program, i.e., that will trigger the
execution of the program’s start function.</p></li>
<li><p><code>inport &lt;list of port names associated with a signal&gt;</code>:
for declaring the list of ports that the software code of the program
can read.</p></li>
<li><p><code>outport &lt;list of port names associated with a signal&gt;</code>:
for declaring the list of ports that the software code of the program
can write to.</p></li>
<li><p><code>code &lt;list of filenames&gt;</code>: for declaring the
source code files.</p></li>
</ul>
<p>For example the following declares a program in the Ruby language
whose start function is <code>echo</code> that is activated on the
positive edge of signal <code>req</code>, has a read port called
<code>inP</code> that is connected to signal <code>count</code> and a
write port called <code>outP</code> that is connected to signal
<code>val</code>, finally the code of this program is given in a file
named <code>echo.rb</code> (the extension <code>.rb</code> can also be
omitted):</p>
<div class="sourceCode" id="cb136"><pre
class="sourceCode ruby"><code class="sourceCode ruby"><span id="cb136-1"><a href="#cb136-1" aria-hidden="true" tabindex="-1"></a><span class="fu">system</span> <span class="wa">:my_system</span> <span class="cf">do</span></span>
<span id="cb136-2"><a href="#cb136-2" aria-hidden="true" tabindex="-1"></a>   inner <span class="wa">:req</span></span>
<span id="cb136-3"><a href="#cb136-3" aria-hidden="true" tabindex="-1"></a>   <span class="kw">[</span><span class="dv">8</span><span class="kw">]</span><span class="at">.inner</span> <span class="wa">:count</span>, <span class="wa">:val</span></span>
<span id="cb136-4"><a href="#cb136-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb136-5"><a href="#cb136-5" aria-hidden="true" tabindex="-1"></a>   program(<span class="wa">:ruby</span>,<span class="vs">&#39;echo&#39;</span>) <span class="cf">do</span></span>
<span id="cb136-6"><a href="#cb136-6" aria-hidden="true" tabindex="-1"></a>      actport req<span class="at">.posedge</span></span>
<span id="cb136-7"><a href="#cb136-7" aria-hidden="true" tabindex="-1"></a>      inport  <span class="wa">inP: </span> count</span>
<span id="cb136-8"><a href="#cb136-8" aria-hidden="true" tabindex="-1"></a>      outport <span class="wa">outP: </span>val</span>
<span id="cb136-9"><a href="#cb136-9" aria-hidden="true" tabindex="-1"></a>      code <span class="st">&quot;echo.rb&quot;</span></span>
<span id="cb136-10"><a href="#cb136-10" aria-hidden="true" tabindex="-1"></a>   <span class="cf">end</span></span>
<span id="cb136-11"><a href="#cb136-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb136-12"><a href="#cb136-12" aria-hidden="true" tabindex="-1"></a>   <span class="kw">...</span></span>
<span id="cb136-13"><a href="#cb136-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb136-14"><a href="#cb136-14" aria-hidden="true" tabindex="-1"></a><span class="cf">end</span></span></code></pre></div>
<p>A similar program construct can also use C as follows:</p>
<div class="sourceCode" id="cb137"><pre
class="sourceCode ruby"><code class="sourceCode ruby"><span id="cb137-1"><a href="#cb137-1" aria-hidden="true" tabindex="-1"></a><span class="fu">system</span> <span class="wa">:my_system</span> <span class="cf">do</span></span>
<span id="cb137-2"><a href="#cb137-2" aria-hidden="true" tabindex="-1"></a>   inner <span class="wa">:req</span></span>
<span id="cb137-3"><a href="#cb137-3" aria-hidden="true" tabindex="-1"></a>   <span class="kw">[</span><span class="dv">8</span><span class="kw">]</span><span class="at">.inner</span> <span class="wa">:count</span>, <span class="wa">:val</span></span>
<span id="cb137-4"><a href="#cb137-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb137-5"><a href="#cb137-5" aria-hidden="true" tabindex="-1"></a>   program(<span class="wa">:c</span>,<span class="vs">&#39;echo&#39;</span>) <span class="cf">do</span></span>
<span id="cb137-6"><a href="#cb137-6" aria-hidden="true" tabindex="-1"></a>      actport req<span class="at">.posedge</span></span>
<span id="cb137-7"><a href="#cb137-7" aria-hidden="true" tabindex="-1"></a>      inport  <span class="wa">inP: </span> count</span>
<span id="cb137-8"><a href="#cb137-8" aria-hidden="true" tabindex="-1"></a>      outport <span class="wa">outP: </span>val</span>
<span id="cb137-9"><a href="#cb137-9" aria-hidden="true" tabindex="-1"></a>      code <span class="st">&quot;echo&quot;</span></span>
<span id="cb137-10"><a href="#cb137-10" aria-hidden="true" tabindex="-1"></a>   <span class="cf">end</span></span>
<span id="cb137-11"><a href="#cb137-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb137-12"><a href="#cb137-12" aria-hidden="true" tabindex="-1"></a>   <span class="kw">...</span></span>
<span id="cb137-13"><a href="#cb137-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb137-14"><a href="#cb137-14" aria-hidden="true" tabindex="-1"></a><span class="cf">end</span></span></code></pre></div>
<p>There is a difference from Ruby though in that the C code cannot be
used directly and must be compiled to a library, and it is the name of
the library that has to be indicated in the <code>code</code> section.
Since the format of the compiler program depends highly on the target
software environment, it is recommended to omit the extension (e.g.,
here only <code>echo</code> and not <code>echo.so</code> or any other
extension), so that the framework looks for the suitable format
automatically.</p>
<p>Now, let us see how the software code can be written to interact with
hardware.</p>
<h3 id="writing-software-for-a-hdlruby-program-construct.">7.2. Writing
software for a HDLRuby Program construct.</h3>
<p>As long as the language is supported by HDLRuby (i.e., Ruby or a
C-compatible compiled language), there should not be any restrictions
for the software code. The function that has been declared in the
HDLRuby program construct for being activated will act as a handler for
an interrupt raised by one of the corresponding events.</p>
<p>Then, for accessing the ports on the hardware-software interface, a
library that depends on the used software language must be loaded.</p>
<h4 id="in-the-case-of-ruby">7.2.1. In the case of Ruby</h4>
<p>If the software language is Ruby, then the library is loaded by
requiring the file <code>rubyHDL.rb</code>. If HDLRuby is correctly
installed, adding the following line at the beginning of the code is
enough:</p>
<div class="sourceCode" id="cb138"><pre
class="sourceCode ruby"><code class="sourceCode ruby"><span id="cb138-1"><a href="#cb138-1" aria-hidden="true" tabindex="-1"></a><span class="fu">require</span> <span class="vs">&#39;rubyHDL.rb&#39;</span></span></code></pre></div>
<p>This library gives access to a Ruby module named “RubyHDL” which
gives access to the ports of the hardware-software interface described
in the HDLRuby program construct. Those ports are directly accessible by
name as follows: <code>RubyHDL.&lt;name&gt;</code>.</p>
<p>For example, the following is an example of implementation of the
<code>echo.rb</code> software used in the previous HDLRuby program
example:</p>
<div class="sourceCode" id="cb139"><pre
class="sourceCode ruby"><code class="sourceCode ruby"><span id="cb139-1"><a href="#cb139-1" aria-hidden="true" tabindex="-1"></a><span class="fu">require</span> <span class="vs">&#39;rubyHDL&#39;</span></span>
<span id="cb139-2"><a href="#cb139-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb139-3"><a href="#cb139-3" aria-hidden="true" tabindex="-1"></a><span class="cf">def</span> echo</span>
<span id="cb139-4"><a href="#cb139-4" aria-hidden="true" tabindex="-1"></a>   val <span class="kw">=</span> <span class="dt">RubyHDL</span><span class="at">.inP</span></span>
<span id="cb139-5"><a href="#cb139-5" aria-hidden="true" tabindex="-1"></a>   <span class="dt">RubyHDL</span><span class="at">.outP</span> <span class="kw">=</span> val</span>
<span id="cb139-6"><a href="#cb139-6" aria-hidden="true" tabindex="-1"></a><span class="cf">end</span></span></code></pre></div>
<p>This program is limited to the handler <code>echo</code>, that reads
on port <code>inP</code> and write the result to port <code>outP</code>.
If you remember the corresponding HDLRuby program construct, that means
<code>echo</code> will get the value of signal <code>count</code> and
send it to signal <code>val</code>.</p>
<h4 id="for-the-case-of-c">7.2.2. For the case of C</h4>
<p>If the software language is C (or a compatible compiled language),
then the library is accessed by including the file <code>cHDL.h</code>.
However, this file is probably not within the includes path of the C
compiler, so you need to bring it to your working directory, as well as
other possible necessary files, using the <code>hdrcc</code> command as
follows:</p>
<div class="sourceCode" id="cb140"><pre
class="sourceCode bash"><code class="sourceCode bash"><span id="cb140-1"><a href="#cb140-1" aria-hidden="true" tabindex="-1"></a><span class="ex">hdrcc</span> <span class="at">--ch</span> <span class="op">&lt;</span>path to your working directory<span class="op">&gt;</span></span></code></pre></div>
<p>Here, your working directory is assumed to contain the source code
for your C program.</p>
<p>Then, you can include the file as follows in your C source code:</p>
<div class="sourceCode" id="cb141"><pre
class="sourceCode ruby"><code class="sourceCode ruby"><span id="cb141-1"><a href="#cb141-1" aria-hidden="true" tabindex="-1"></a><span class="co">#include &quot;cHDL.h&quot;</span></span></code></pre></div>
<p>This library gives access to three C functions for interacting with
the ports:</p>
<ul>
<li><p><code>void* c_get_port(const char* name)</code>: returns a
pointer to the port whose name is passed as argument.</p></li>
<li><p><code>int c_read_port(void* port)</code>: reads the port whose
pointer is passed as argument and returns its value.</p></li>
<li><p><code>int c_write_port(void* port, int val)</code>: write the
value <code>val</code> to the port passed as argument.</p></li>
</ul>
<p>Please notice that whatever the bit width of the signal connected to
the part may be, from the software side the type of the data going
through a port is always <code>int</code>. If the signal is larger than
an <code>int</code>, the extra bits will be truncated, and if it is
smaller, the value of the extra bits from the software side is
undefined.</p>
<p>For example, the following is an example of implementation of the
<code>echo.rb</code> software used in the previous HDLRuby program
example:</p>
<div class="sourceCode" id="cb142"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb142-1"><a href="#cb142-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&quot;cHDL.h&quot;</span></span>
<span id="cb142-2"><a href="#cb142-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb142-3"><a href="#cb142-3" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> echo<span class="op">()</span> <span class="op">{</span></span>
<span id="cb142-4"><a href="#cb142-4" aria-hidden="true" tabindex="-1"></a>   <span class="dt">static</span> <span class="dt">void</span><span class="op">*</span> inP <span class="op">=</span> c_get_port<span class="op">(</span><span class="st">&quot;inP&quot;</span><span class="op">);</span></span>
<span id="cb142-5"><a href="#cb142-5" aria-hidden="true" tabindex="-1"></a>   <span class="dt">static</span> <span class="dt">void</span><span class="op">*</span> outP <span class="op">=</span> c_get_port<span class="op">(</span><span class="st">&quot;outP&quot;</span><span class="op">);</span></span>
<span id="cb142-6"><a href="#cb142-6" aria-hidden="true" tabindex="-1"></a>   <span class="dt">int</span> val <span class="op">=</span> c_read_port<span class="op">(</span>inP<span class="op">);</span></span>
<span id="cb142-7"><a href="#cb142-7" aria-hidden="true" tabindex="-1"></a>   c_write_port<span class="op">(</span>outP<span class="op">);</span></span>
<span id="cb142-8"><a href="#cb142-8" aria-hidden="true" tabindex="-1"></a>end</span></code></pre></div>
<p>This program is the same as the Ruby version, but the ports are only
available after being looked up by name using the
<code>c_get_port</code> function. It is enough to do that once though,
so that in the example, we set the corresponding port variable
<code>inP</code> and <code>outP</code> as static local.</p>
<h3 id="hardware-software-co-simulation">7.3. Hardware-software
co-simulation</h3>
<p>Hardware-software co-simulation is done, like pure hardware
simulation, using the HDLRuby simulator using the
<code>hdrcc --sim</code> command (please see <a
href="#1-3-using-hdlruby">section 1.3.</a>.</p>
<p>When the software language is Ruby, there is nothing more to do.
However, when the software language is C, its code must first be
compiled to a shared library for the host (i.e., the computer that
executes the HDLRuby simulator). For example, assuming you want to
compile the C file <code>echo.c</code> located into the
<code>echo</code> directory, if you are using GCC on a Linux system, you
could type (after entering the <code>echo</code> directory):</p>
<div class="sourceCode" id="cb143"><pre
class="sourceCode bash"><code class="sourceCode bash"><span id="cb143-1"><a href="#cb143-1" aria-hidden="true" tabindex="-1"></a><span class="bu">cd</span> echo</span>
<span id="cb143-2"><a href="#cb143-2" aria-hidden="true" tabindex="-1"></a><span class="fu">gcc</span> <span class="at">-shared</span> <span class="at">-fPIC</span> <span class="at">-undefined</span> dynamic_lookup  <span class="at">-o</span> c_program.so echo.c</span></code></pre></div>
<p>Otherwise, it may be easier to use the Ruby environment by first
installing <code>rake-compiler</code> as follows:</p>
<div class="sourceCode" id="cb144"><pre
class="sourceCode bash"><code class="sourceCode bash"><span id="cb144-1"><a href="#cb144-1" aria-hidden="true" tabindex="-1"></a><span class="ex">gem</span> install rake-compiler</span></code></pre></div>
<p>And simply type the following command (after entering the
<code>echo</code> directory):</p>
<div class="sourceCode" id="cb145"><pre
class="sourceCode bash"><code class="sourceCode bash"><span id="cb145-1"><a href="#cb145-1" aria-hidden="true" tabindex="-1"></a><span class="ex">rake</span> compile</span></code></pre></div>
<p>The rake tool will take care of everything for performing the
compiling whatever your system may be.</p>
<p>When the C code is compiled, the HDLRuby simulator can be executed as
usual.</p>
<p><strong>Note</strong>:</p>
<p><strong>Important:</strong> for windows, dynamically loaded functions
must be declared with the following prefix:
<code>__declspec(dllexport)</code>. If this prefix is not present before
each function that is used as an HDLRuby program, the simulation will
not work. For example, for Windows, the function echo <em>must</em> be
written as follows:</p>
<div class="sourceCode" id="cb146"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb146-1"><a href="#cb146-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&quot;cHDL.h&quot;</span></span>
<span id="cb146-2"><a href="#cb146-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb146-3"><a href="#cb146-3" aria-hidden="true" tabindex="-1"></a>__declspec<span class="op">(</span>dllexport<span class="op">)</span> <span class="dt">void</span> echo<span class="op">()</span> <span class="op">{</span></span>
<span id="cb146-4"><a href="#cb146-4" aria-hidden="true" tabindex="-1"></a>   <span class="dt">void</span><span class="op">*</span> inP <span class="op">=</span> c_get_port<span class="op">(</span><span class="st">&quot;inP&quot;</span><span class="op">);</span></span>
<span id="cb146-5"><a href="#cb146-5" aria-hidden="true" tabindex="-1"></a>   <span class="dt">void</span><span class="op">*</span> outP <span class="op">=</span> c_get_port<span class="op">(</span><span class="st">&quot;outP&quot;</span><span class="op">);</span></span>
<span id="cb146-6"><a href="#cb146-6" aria-hidden="true" tabindex="-1"></a>   <span class="dt">int</span> val<span class="op">;</span></span>
<span id="cb146-7"><a href="#cb146-7" aria-hidden="true" tabindex="-1"></a>   </span>
<span id="cb146-8"><a href="#cb146-8" aria-hidden="true" tabindex="-1"></a>   val <span class="op">=</span> c_read_port<span class="op">(</span>inP<span class="op">);</span></span>
<span id="cb146-9"><a href="#cb146-9" aria-hidden="true" tabindex="-1"></a>   c_write_port<span class="op">(</span>outP<span class="op">,</span>val<span class="op">);</span></span>
<span id="cb146-10"><a href="#cb146-10" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h3 id="is-that-all">7.4. Is that all?</h3>
<p>Technically, there is nothing else to describe hardware-software
interaction in HDLRuby. Hence, no shared memory, buffer, or other
complex communication or synchronization systems. But the reason is that
we do not need them in the core of HDLRuby, they can be described using
a mix of standard HDLRuby and software programming. With the same
method, you can also simulate external devices as black boxes.</p>
<p>To illustrate how this mix of HDLRuby and software can be
implemented, let us see three examples: a memory shared between software
and hardware, a model of an operating system, a real-time clock, and a
method for modeling program execution time. In all these examples we
will use Ruby as software language, but this can also be done with
C.</p>
<h4 id="modeling-a-memory-shared-between-software-and-hardware">7.4.1.
Modeling a memory shared between software and hardware</h4>
<p>There are two possibilities for modeling such a memory: either
describe it in plain HDLRuby as a full hardware component, and write a
program construct that simulates the access of the software part to this
memory, or describe the memory as a part of the software part and
simulate its access from the hardware part using a program construct.
The first approach is more accurate and may be useful when a specific
kind of memory is to be used, but it is slower than the second one.</p>
<h5 id="memory-described-as-a-hardware-component">7.4.1.1 Memory
described as a hardware component</h5>
<p>For the first approach, if we assume a memory with an 8-bit address
bus, and an 8-bit data bus the HDLRuby code could be as follows:</p>
<div class="sourceCode" id="cb147"><pre
class="sourceCode ruby"><code class="sourceCode ruby"><span id="cb147-1"><a href="#cb147-1" aria-hidden="true" tabindex="-1"></a><span class="fu">system</span> <span class="wa">:hw_sw_with_hw_memory</span> <span class="cf">do</span></span>
<span id="cb147-2"><a href="#cb147-2" aria-hidden="true" tabindex="-1"></a>   <span class="kw">[</span><span class="dv">8</span><span class="kw">]</span><span class="at">.inner</span> <span class="wa">:addr</span></span>
<span id="cb147-3"><a href="#cb147-3" aria-hidden="true" tabindex="-1"></a>   <span class="kw">[</span><span class="dv">8</span><span class="kw">]</span><span class="at">.inner</span> <span class="wa">:din</span>, <span class="wa">:dout</span></span>
<span id="cb147-4"><a href="#cb147-4" aria-hidden="true" tabindex="-1"></a>   inner     <span class="wa">:rwb</span>, <span class="wa">:ce</span></span>
<span id="cb147-5"><a href="#cb147-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb147-6"><a href="#cb147-6" aria-hidden="true" tabindex="-1"></a>   inner <span class="wa">:clk</span>, <span class="wa">:rst</span></span>
<span id="cb147-7"><a href="#cb147-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb147-8"><a href="#cb147-8" aria-hidden="true" tabindex="-1"></a>   <span class="co"># Instantiation of the memory.</span></span>
<span id="cb147-9"><a href="#cb147-9" aria-hidden="true" tabindex="-1"></a>   instance <span class="wa">:memory</span> <span class="cf">do</span></span>
<span id="cb147-10"><a href="#cb147-10" aria-hidden="true" tabindex="-1"></a>      inner      <span class="wa">:clk</span></span>
<span id="cb147-11"><a href="#cb147-11" aria-hidden="true" tabindex="-1"></a>      <span class="kw">[</span><span class="dv">8</span><span class="kw">]</span><span class="at">.input</span> <span class="wa">:addr</span></span>
<span id="cb147-12"><a href="#cb147-12" aria-hidden="true" tabindex="-1"></a>      <span class="kw">[</span><span class="dv">8</span><span class="kw">]</span><span class="at">.input</span>  <span class="wa">:din</span></span>
<span id="cb147-13"><a href="#cb147-13" aria-hidden="true" tabindex="-1"></a>      <span class="kw">[</span><span class="dv">8</span><span class="kw">]</span><span class="at">.output</span> <span class="wa">:dout</span></span>
<span id="cb147-14"><a href="#cb147-14" aria-hidden="true" tabindex="-1"></a>      input      <span class="wa">:rwb</span>, <span class="wa">:ce</span></span>
<span id="cb147-15"><a href="#cb147-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb147-16"><a href="#cb147-16" aria-hidden="true" tabindex="-1"></a>      bit<span class="kw">[</span><span class="dv">8</span><span class="kw">][-</span><span class="dv">256</span><span class="kw">]</span><span class="at">.inner</span> <span class="wa">:content</span></span>
<span id="cb147-17"><a href="#cb147-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb147-18"><a href="#cb147-18" aria-hidden="true" tabindex="-1"></a>      par(clk<span class="at">.posedge</span>) <span class="cf">do</span></span>
<span id="cb147-19"><a href="#cb147-19" aria-hidden="true" tabindex="-1"></a>         hif(ce) <span class="cf">do</span></span>
<span id="cb147-20"><a href="#cb147-20" aria-hidden="true" tabindex="-1"></a>            hif(rwb) <span class="kw">{</span> dout <span class="kw">&lt;=</span> content<span class="kw">[</span>addr<span class="kw">]</span> <span class="kw">}</span></span>
<span id="cb147-21"><a href="#cb147-21" aria-hidden="true" tabindex="-1"></a>            helse    <span class="kw">{</span> content<span class="kw">[</span>addr<span class="kw">]</span> <span class="kw">&lt;=</span> din <span class="kw">}</span></span>
<span id="cb147-22"><a href="#cb147-22" aria-hidden="true" tabindex="-1"></a>      <span class="cf">end</span></span>
<span id="cb147-23"><a href="#cb147-23" aria-hidden="true" tabindex="-1"></a>   <span class="cf">end</span><span class="kw">.</span>(clk,addr,din,dout,rwb,ce)</span>
<span id="cb147-24"><a href="#cb147-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb147-25"><a href="#cb147-25" aria-hidden="true" tabindex="-1"></a>   <span class="co"># The hw generating the tick activating the software part (e.g., an OS tick):</span></span>
<span id="cb147-26"><a href="#cb147-26" aria-hidden="true" tabindex="-1"></a>   <span class="co"># one tick every 10 clock cycles.</span></span>
<span id="cb147-27"><a href="#cb147-27" aria-hidden="true" tabindex="-1"></a>   inner <span class="wa">:tick</span></span>
<span id="cb147-28"><a href="#cb147-28" aria-hidden="true" tabindex="-1"></a>   (tick <span class="kw">&lt;=</span> <span class="kw">~</span>rst <span class="kw">&amp;</span> <span class="kw">~</span>tick)<span class="at">.at</span>(clk<span class="at">.posedge</span> <span class="kw">*</span> <span class="dv">5</span>)</span>
<span id="cb147-29"><a href="#cb147-29" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb147-30"><a href="#cb147-30" aria-hidden="true" tabindex="-1"></a>   inner <span class="wa">:req_sw</span>, <span class="wa">:ack_sw</span>, <span class="wa">:rwb_sw</span></span>
<span id="cb147-31"><a href="#cb147-31" aria-hidden="true" tabindex="-1"></a>   <span class="kw">[</span><span class="dv">8</span><span class="kw">]</span><span class="at">.inner</span> <span class="wa">:addr_sw</span></span>
<span id="cb147-32"><a href="#cb147-32" aria-hidden="true" tabindex="-1"></a>   <span class="kw">[</span><span class="dv">8</span><span class="kw">]</span><span class="at">.inner</span>  <span class="wa">:din_sw</span>, <span class="wa">:dout_sw</span></span>
<span id="cb147-33"><a href="#cb147-33" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb147-34"><a href="#cb147-34" aria-hidden="true" tabindex="-1"></a>   inner<span class="kw">[</span><span class="dv">16</span><span class="kw">]</span> <span class="wa">:addr_hw</span></span>
<span id="cb147-35"><a href="#cb147-35" aria-hidden="true" tabindex="-1"></a>   inner <span class="wa">:req_hw</span>, <span class="wa">:ack_hw</span>, <span class="wa">:rwb_hw</span></span>
<span id="cb147-36"><a href="#cb147-36" aria-hidden="true" tabindex="-1"></a>   <span class="kw">[</span><span class="dv">8</span><span class="kw">]</span><span class="at">.inner</span>  <span class="wa">:din_hw</span>, <span class="wa">:dout_hw</span></span>
<span id="cb147-37"><a href="#cb147-37" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb147-38"><a href="#cb147-38" aria-hidden="true" tabindex="-1"></a>   <span class="co"># Description of the software part.</span></span>
<span id="cb147-39"><a href="#cb147-39" aria-hidden="true" tabindex="-1"></a>   program(<span class="wa">:ruby</span>,<span class="wa">:some_sw</span>) <span class="cf">do</span></span>
<span id="cb147-40"><a href="#cb147-40" aria-hidden="true" tabindex="-1"></a>      actport tick<span class="at">.posedge</span></span>
<span id="cb147-41"><a href="#cb147-41" aria-hidden="true" tabindex="-1"></a>      outport req <span class="wa">:req_sw</span>, <span class="wa">ack: </span>ack_sw, <span class="wa">rwb: </span>rwb_sw</span>
<span id="cb147-42"><a href="#cb147-42" aria-hidden="true" tabindex="-1"></a>      outport <span class="wa">addr: </span>addr_sw</span>
<span id="cb147-43"><a href="#cb147-43" aria-hidden="true" tabindex="-1"></a>      outport <span class="wa">dout: </span>dout_sw</span>
<span id="cb147-44"><a href="#cb147-44" aria-hidden="true" tabindex="-1"></a>      inport  <span class="wa">din: </span> din_sw</span>
<span id="cb147-45"><a href="#cb147-45" aria-hidden="true" tabindex="-1"></a>      code <span class="st">&quot;some_sw.rb&quot;</span></span>
<span id="cb147-46"><a href="#cb147-46" aria-hidden="true" tabindex="-1"></a>   <span class="cf">end</span></span>
<span id="cb147-47"><a href="#cb147-47" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb147-48"><a href="#cb147-48" aria-hidden="true" tabindex="-1"></a>   inner <span class="wa">:priority</span>  <span class="co"># 0: priority in hw access, 1: priority in sw access.</span></span>
<span id="cb147-49"><a href="#cb147-49" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb147-50"><a href="#cb147-50" aria-hidden="true" tabindex="-1"></a>   <span class="co"># The arbiter, sharing the memory between software and hardware giving</span></span>
<span id="cb147-51"><a href="#cb147-51" aria-hidden="true" tabindex="-1"></a>   <span class="co"># priority to software. It uses a round-robin approach.</span></span>
<span id="cb147-52"><a href="#cb147-52" aria-hidden="true" tabindex="-1"></a>   par(clk<span class="at">.negedge</span>) <span class="cf">do</span></span>
<span id="cb147-53"><a href="#cb147-53" aria-hidden="true" tabindex="-1"></a>      hif(rst) <span class="kw">{</span> priority <span class="kw">&lt;=</span> <span class="dv">0</span> <span class="kw">}</span></span>
<span id="cb147-54"><a href="#cb147-54" aria-hidden="true" tabindex="-1"></a>      ack_sw <span class="kw">&lt;=</span> <span class="dv">0</span>    <span class="co"># By default no access granted to software.</span></span>
<span id="cb147-55"><a href="#cb147-55" aria-hidden="true" tabindex="-1"></a>      ack_hw <span class="kw">&lt;=</span> <span class="dv">0</span>    <span class="co"># Nor to hardware.</span></span>
<span id="cb147-56"><a href="#cb147-56" aria-hidden="true" tabindex="-1"></a>      ce     <span class="kw">&lt;=</span> <span class="dv">0</span></span>
<span id="cb147-57"><a href="#cb147-57" aria-hidden="true" tabindex="-1"></a>      hif(req_sw <span class="kw">&amp;</span> (priority <span class="kw">|</span> <span class="kw">~</span>req_hw)) <span class="cf">do</span></span>
<span id="cb147-58"><a href="#cb147-58" aria-hidden="true" tabindex="-1"></a>         ce     <span class="kw">&lt;=</span> <span class="dv">1</span></span>
<span id="cb147-59"><a href="#cb147-59" aria-hidden="true" tabindex="-1"></a>         ack_sw <span class="kw">&lt;=</span> <span class="dv">1</span></span>
<span id="cb147-60"><a href="#cb147-60" aria-hidden="true" tabindex="-1"></a>         rwb    <span class="kw">&lt;=</span> rwb_sw</span>
<span id="cb147-61"><a href="#cb147-61" aria-hidden="true" tabindex="-1"></a>         addr   <span class="kw">&lt;=</span> addr_sw</span>
<span id="cb147-62"><a href="#cb147-62" aria-hidden="true" tabindex="-1"></a>         din    <span class="kw">&lt;=</span> dout_sw</span>
<span id="cb147-63"><a href="#cb147-63" aria-hidden="true" tabindex="-1"></a>         din_sw <span class="kw">&lt;=</span> dout</span>
<span id="cb147-64"><a href="#cb147-64" aria-hidden="true" tabindex="-1"></a>         priority <span class="kw">&lt;=</span> <span class="kw">~</span>priority</span>
<span id="cb147-65"><a href="#cb147-65" aria-hidden="true" tabindex="-1"></a>      <span class="cf">end</span></span>
<span id="cb147-66"><a href="#cb147-66" aria-hidden="true" tabindex="-1"></a>      <span class="cf">if</span>(req_hw <span class="kw">&amp;</span> (<span class="kw">~</span>priority <span class="kw">|</span> <span class="kw">~</span>req_sw)) <span class="cf">do</span></span>
<span id="cb147-67"><a href="#cb147-67" aria-hidden="true" tabindex="-1"></a>         ce     <span class="kw">&lt;=</span> <span class="dv">1</span></span>
<span id="cb147-68"><a href="#cb147-68" aria-hidden="true" tabindex="-1"></a>         ack_hw <span class="kw">&lt;=</span> <span class="dv">1</span></span>
<span id="cb147-69"><a href="#cb147-69" aria-hidden="true" tabindex="-1"></a>         rwb    <span class="kw">&lt;=</span> rwb_hw</span>
<span id="cb147-70"><a href="#cb147-70" aria-hidden="true" tabindex="-1"></a>         addr   <span class="kw">&lt;=</span> addr_hw</span>
<span id="cb147-71"><a href="#cb147-71" aria-hidden="true" tabindex="-1"></a>         din    <span class="kw">&lt;=</span> dout_hw</span>
<span id="cb147-72"><a href="#cb147-72" aria-hidden="true" tabindex="-1"></a>         din_hw <span class="kw">&lt;=</span> dout</span>
<span id="cb147-73"><a href="#cb147-73" aria-hidden="true" tabindex="-1"></a>         priority <span class="kw">&lt;=</span> <span class="kw">~</span>priority</span>
<span id="cb147-74"><a href="#cb147-74" aria-hidden="true" tabindex="-1"></a>      <span class="cf">end</span></span>
<span id="cb147-75"><a href="#cb147-75" aria-hidden="true" tabindex="-1"></a>   <span class="cf">end</span></span>
<span id="cb147-76"><a href="#cb147-76" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb147-77"><a href="#cb147-77" aria-hidden="true" tabindex="-1"></a>   <span class="co"># Some hardware code accessing the memory.</span></span>
<span id="cb147-78"><a href="#cb147-78" aria-hidden="true" tabindex="-1"></a>   sequencer(clk,rst) <span class="cf">do</span></span>
<span id="cb147-79"><a href="#cb147-79" aria-hidden="true" tabindex="-1"></a>      <span class="co"># At first, fill the memory with 0.</span></span>
<span id="cb147-80"><a href="#cb147-80" aria-hidden="true" tabindex="-1"></a>      req_hw <span class="kw">&lt;=</span> <span class="dv">1</span>; rwb_hw <span class="kw">&lt;=</span> <span class="dv">0</span></span>
<span id="cb147-81"><a href="#cb147-81" aria-hidden="true" tabindex="-1"></a>      swhile(<span class="kw">~</span>ack_hw) <span class="co"># Wait for the access grant to memory.</span></span>
<span id="cb147-82"><a href="#cb147-82" aria-hidden="true" tabindex="-1"></a>      dout_hw <span class="kw">&lt;=</span> <span class="dv">0</span></span>
<span id="cb147-83"><a href="#cb147-83" aria-hidden="true" tabindex="-1"></a>      <span class="dv">256</span><span class="at">.stimes</span> <span class="kw">{</span> <span class="kw">|</span>i<span class="kw">|</span> addr_hw <span class="kw">&lt;=</span> i <span class="kw">}</span></span>
<span id="cb147-84"><a href="#cb147-84" aria-hidden="true" tabindex="-1"></a>      req_hw <span class="kw">&lt;=</span> <span class="dv">0</span> <span class="co"># End the transactions.</span></span>
<span id="cb147-85"><a href="#cb147-85" aria-hidden="true" tabindex="-1"></a>      <span class="co"># Now, do infinitely some arbitrary computations with the content</span></span>
<span id="cb147-86"><a href="#cb147-86" aria-hidden="true" tabindex="-1"></a>      <span class="co"># of the memory.</span></span>
<span id="cb147-87"><a href="#cb147-87" aria-hidden="true" tabindex="-1"></a>      sloop <span class="cf">do</span></span>
<span id="cb147-88"><a href="#cb147-88" aria-hidden="true" tabindex="-1"></a>         <span class="dv">128</span><span class="at">.stimes</span> <span class="cf">do</span> <span class="kw">|</span>i<span class="kw">|</span></span>
<span id="cb147-89"><a href="#cb147-89" aria-hidden="true" tabindex="-1"></a>            <span class="kw">[</span><span class="dv">8</span><span class="kw">]</span><span class="at">.inner</span> <span class="wa">:tmp</span></span>
<span id="cb147-90"><a href="#cb147-90" aria-hidden="true" tabindex="-1"></a>            req_hw <span class="kw">&lt;=</span> <span class="dv">1</span></span>
<span id="cb147-91"><a href="#cb147-91" aria-hidden="true" tabindex="-1"></a>            rwb_hw <span class="kw">&lt;=</span> <span class="dv">1</span></span>
<span id="cb147-92"><a href="#cb147-92" aria-hidden="true" tabindex="-1"></a>            addr_hw <span class="kw">&lt;=</span> i</span>
<span id="cb147-93"><a href="#cb147-93" aria-hidden="true" tabindex="-1"></a>            swhile(<span class="kw">~</span>ack_hw)</span>
<span id="cb147-94"><a href="#cb147-94" aria-hidden="true" tabindex="-1"></a>            tmp <span class="kw">&lt;=</span> din_hw</span>
<span id="cb147-95"><a href="#cb147-95" aria-hidden="true" tabindex="-1"></a>            step</span>
<span id="cb147-96"><a href="#cb147-96" aria-hidden="true" tabindex="-1"></a>            rwb_hw  <span class="kw">&lt;=</span> <span class="dv">0</span></span>
<span id="cb147-97"><a href="#cb147-97" aria-hidden="true" tabindex="-1"></a>            addr_hw <span class="kw">&lt;=</span> i <span class="kw">+</span> <span class="dv">128</span></span>
<span id="cb147-98"><a href="#cb147-98" aria-hidden="true" tabindex="-1"></a>            dout_hw <span class="kw">&lt;=</span> tmp <span class="kw">*</span> tmp   <span class="co"># Just some senseless data.</span></span>
<span id="cb147-99"><a href="#cb147-99" aria-hidden="true" tabindex="-1"></a>            step</span>
<span id="cb147-100"><a href="#cb147-100" aria-hidden="true" tabindex="-1"></a>            req_hw <span class="kw">&lt;=</span> <span class="dv">0</span></span>
<span id="cb147-101"><a href="#cb147-101" aria-hidden="true" tabindex="-1"></a>         <span class="cf">end</span></span>
<span id="cb147-102"><a href="#cb147-102" aria-hidden="true" tabindex="-1"></a>      <span class="cf">end</span></span>
<span id="cb147-103"><a href="#cb147-103" aria-hidden="true" tabindex="-1"></a>   <span class="cf">end</span></span></code></pre></div>
<p>This example contains four parts:</p>
<ul>
<li>A hardware description of a memory, described as an inline instance.
It has an address input <code>addr</code>, a data input <code>din</code>
a data outpout <code>dout</code> (it is common in FPGA nowadays to avoid
three-state buses), a signal <code>rwb</code> indicating if a read (1)
or a write (0) access is performed, and a chip enable signal
<code>ce</code>.</li>
</ul>
<p><em>NOTE:</em> an inline <code>instance</code> is a construct that
both describe a module (like <code>system</code>) and instantiates it in
place. When a component is to be used only once, it is a convenient way
to have fast access to the description of the module where it is used,
while keeping the hierarchy.</p>
<ul>
<li><p>A hardware description of an arbiter for granting access to this
memory to alternatively a software component and a hardware component
using round-robin. Both the software part and the hardware part have
their signals for accessing the memory (e.g., resp. <code>rwb_sw</code>
and <code>rwb_hw</code> for <code>rwb</code>), and the arbiter will
transmit them to the corresponding memory signal when their access is
granted. For requiring access, both have to raise a memory request
signal, resp. <code>req_sw</code> and <code>req_hw</code>, and will know
they have access when the corresponding acknowledge signals are raised,
resp., <code>ack_sw</code> and <code>ack_hw</code>.</p></li>
<li><p>A software component described with a sequencer reading and
writing the memory and performing arbitrary computations. This code is
activated on each rising edge of signal <code>tick</code>.</p></li>
<li><p>A hardware component described with a sequencer reading and
writing the memory and performing arbitrary computations.</p></li>
</ul>
<p>Then, the code of the software component in the file
<code>some_sw.rb</code> can be as follows:</p>
<div class="sourceCode" id="cb148"><pre
class="sourceCode ruby"><code class="sourceCode ruby"><span id="cb148-1"><a href="#cb148-1" aria-hidden="true" tabindex="-1"></a><span class="fu">require</span> <span class="vs">&#39;rubyHDL.rb&#39;</span></span>
<span id="cb148-2"><a href="#cb148-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb148-3"><a href="#cb148-3" aria-hidden="true" tabindex="-1"></a><span class="va">$addr</span> <span class="kw">=</span> <span class="dv">0</span></span>
<span id="cb148-4"><a href="#cb148-4" aria-hidden="true" tabindex="-1"></a><span class="va">$state</span> <span class="kw">=</span> <span class="dv">0</span></span>
<span id="cb148-5"><a href="#cb148-5" aria-hidden="true" tabindex="-1"></a><span class="va">$tmp</span> <span class="kw">=</span> <span class="dv">0</span></span>
<span id="cb148-6"><a href="#cb148-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb148-7"><a href="#cb148-7" aria-hidden="true" tabindex="-1"></a><span class="cf">def</span> some_sw</span>
<span id="cb148-8"><a href="#cb148-8" aria-hidden="true" tabindex="-1"></a>   <span class="cf">if</span>(<span class="dt">RubyHDL</span><span class="at">.ack</span> <span class="kw">==</span> <span class="dv">0</span>) <span class="cf">then</span></span>
<span id="cb148-9"><a href="#cb148-9" aria-hidden="true" tabindex="-1"></a>      <span class="dt">RubyHDL</span><span class="at">.req</span> <span class="kw">=</span> <span class="dv">1</span></span>
<span id="cb148-10"><a href="#cb148-10" aria-hidden="true" tabindex="-1"></a>   <span class="cf">else</span></span>
<span id="cb148-11"><a href="#cb148-11" aria-hidden="true" tabindex="-1"></a>      <span class="cf">case</span>(<span class="va">$state</span>)</span>
<span id="cb148-12"><a href="#cb148-12" aria-hidden="true" tabindex="-1"></a>      <span class="cf">when</span> <span class="dv">0</span>:</span>
<span id="cb148-13"><a href="#cb148-13" aria-hidden="true" tabindex="-1"></a>         <span class="dt">RubyHDL</span><span class="at">.addr</span> <span class="kw">=</span> <span class="dv">128</span><span class="kw">+</span><span class="va">$addr</span></span>
<span id="cb148-14"><a href="#cb148-14" aria-hidden="true" tabindex="-1"></a>         <span class="dt">RubyHDL</span><span class="at">.rwb</span>  <span class="kw">=</span> <span class="dv">1</span></span>
<span id="cb148-15"><a href="#cb148-15" aria-hidden="true" tabindex="-1"></a>         <span class="va">$state</span> <span class="kw">=</span> <span class="dv">1</span></span>
<span id="cb148-16"><a href="#cb148-16" aria-hidden="true" tabindex="-1"></a>      <span class="cf">when</span> <span class="dv">1</span>:</span>
<span id="cb148-17"><a href="#cb148-17" aria-hidden="true" tabindex="-1"></a>         <span class="va">$tmp</span> <span class="kw">=</span> <span class="dt">RubyHDL</span><span class="at">.din</span></span>
<span id="cb148-18"><a href="#cb148-18" aria-hidden="true" tabindex="-1"></a>         <span class="fu">puts</span> <span class="st">&quot;Read: </span><span class="sc">#{</span><span class="va">$tmp</span><span class="sc">}</span><span class="st">&quot;</span></span>
<span id="cb148-19"><a href="#cb148-19" aria-hidden="true" tabindex="-1"></a>         <span class="va">$state</span> <span class="kw">=</span> <span class="dv">2</span></span>
<span id="cb148-20"><a href="#cb148-20" aria-hidden="true" tabindex="-1"></a>      <span class="cf">when</span> <span class="dv">2</span>:</span>
<span id="cb148-21"><a href="#cb148-21" aria-hidden="true" tabindex="-1"></a>         <span class="dt">RubyHDL</span><span class="at">.rwb</span> <span class="kw">=</span> <span class="dv">0</span></span>
<span id="cb148-22"><a href="#cb148-22" aria-hidden="true" tabindex="-1"></a>         <span class="dt">RubyHDL</span><span class="at">.addr</span> <span class="kw">=</span> <span class="va">$addr</span></span>
<span id="cb148-23"><a href="#cb148-23" aria-hidden="true" tabindex="-1"></a>         <span class="fu">puts</span> <span class="st">&quot;Write: </span><span class="sc">#{</span><span class="va">$tmp</span> <span class="kw">+</span> <span class="dv">1</span><span class="sc">}</span><span class="st">&quot;</span></span>
<span id="cb148-24"><a href="#cb148-24" aria-hidden="true" tabindex="-1"></a>         <span class="dt">RubyHDL</span><span class="at">.dout</span> <span class="kw">=</span> <span class="va">$tmp</span> <span class="kw">+</span> <span class="dv">1</span>    <span class="co"># Write some random computation result from</span></span>
<span id="cb148-25"><a href="#cb148-25" aria-hidden="true" tabindex="-1"></a>         <span class="va">$state</span> <span class="kw">=</span> <span class="dv">0</span>                 <span class="co"># the previously read data. </span></span>
<span id="cb148-26"><a href="#cb148-26" aria-hidden="true" tabindex="-1"></a>         <span class="va">$addr</span>  <span class="kw">=</span> (<span class="va">$addr</span> <span class="kw">+</span> <span class="dv">1</span>) <span class="kw">&amp;</span> <span class="dv">255</span> <span class="co"># Next address.</span></span>
<span id="cb148-27"><a href="#cb148-27" aria-hidden="true" tabindex="-1"></a>      <span class="cf">end</span></span>
<span id="cb148-28"><a href="#cb148-28" aria-hidden="true" tabindex="-1"></a>   <span class="cf">end</span></span>
<span id="cb148-29"><a href="#cb148-29" aria-hidden="true" tabindex="-1"></a><span class="cf">end</span></span></code></pre></div>
<p>This program simply writes in the first half of the memory the result
of some arbitrary computation from the data read from the first half.
That is to say that it does the opposite of the hardware component
described in the HDLRuby code. This code makes sense only if the process
has access to the memory via explicit access to address and data
registers, which is the case for some embedded architectures. If the
memory is directly accessible by the processor, the access procedure
must be encapsulated by Ruby methods (or C functions) that are meant to
be replaced by standard memory accesses in the final code. Moreover,
since a software code is fully executed by the HDLRuby simulator before
giving back the hand to the simulation, this code has been written like
a state machine whose state is a global variable updated at each code,
so that it simulates an interaction with the hardware. This is valid if
the software code is meant to be a handler of interrupt for example, but
not for more conventional software. For the second case, a model of an
operating system will have to be described that handles the
synchronizations. Such a model as well as the encapsulation of the
hardware accesses will presented in section <a
href="#7-5-2-modeling-an-operating-system">7.5.2</a>.</p>
<h5 id="memory-described-as-a-software-component">7.4.1.1 Memory
described as a software component</h5>
<p>Usually, CPUs have privileged access to the main memory and give
direct access to it to software through a pointer, or an array.
Moreover, memories are usually IP components that are instantiated as
black boxes in HDL. For such cases, it is preferable to describe a
memory as a program construct whose code is a simulation of its behavior
described in software. This description is to be used when simulating,
but it can be ignored when synthesizing the final hardware. With this
approach, the previous HDLRuby code can be rewritten as follows:</p>
<div class="sourceCode" id="cb149"><pre
class="sourceCode ruby"><code class="sourceCode ruby"><span id="cb149-1"><a href="#cb149-1" aria-hidden="true" tabindex="-1"></a><span class="fu">system</span> <span class="wa">:hw_sw_with_sw_memory</span> <span class="cf">do</span></span>
<span id="cb149-2"><a href="#cb149-2" aria-hidden="true" tabindex="-1"></a>   <span class="kw">[</span><span class="dv">8</span><span class="kw">]</span><span class="at">.inner</span> <span class="wa">:addr</span></span>
<span id="cb149-3"><a href="#cb149-3" aria-hidden="true" tabindex="-1"></a>   <span class="kw">[</span><span class="dv">8</span><span class="kw">]</span><span class="at">.inner</span> <span class="wa">:din</span>, <span class="wa">:dout</span></span>
<span id="cb149-4"><a href="#cb149-4" aria-hidden="true" tabindex="-1"></a>   inner     <span class="wa">:rwb</span></span>
<span id="cb149-5"><a href="#cb149-5" aria-hidden="true" tabindex="-1"></a>   inner     <span class="wa">:req</span>, <span class="wa">:ack</span></span>
<span id="cb149-6"><a href="#cb149-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb149-7"><a href="#cb149-7" aria-hidden="true" tabindex="-1"></a>   inner <span class="wa">:clk</span>, <span class="wa">:rst</span></span>
<span id="cb149-8"><a href="#cb149-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb149-9"><a href="#cb149-9" aria-hidden="true" tabindex="-1"></a>   <span class="co"># Description of the memory as a black box simulated in software.</span></span>
<span id="cb149-10"><a href="#cb149-10" aria-hidden="true" tabindex="-1"></a>   program(<span class="wa">:ruby</span>,<span class="wa">:memory</span>) <span class="cf">do</span></span>
<span id="cb149-11"><a href="#cb149-11" aria-hidden="true" tabindex="-1"></a>      actport clk<span class="at">.posedge</span></span>
<span id="cb149-12"><a href="#cb149-12" aria-hidden="true" tabindex="-1"></a>      inport  <span class="wa">addr: </span>addr</span>
<span id="cb149-13"><a href="#cb149-13" aria-hidden="true" tabindex="-1"></a>      inport  <span class="wa">din: </span> din</span>
<span id="cb149-14"><a href="#cb149-14" aria-hidden="true" tabindex="-1"></a>      outport <span class="wa">dout: </span>dout</span>
<span id="cb149-15"><a href="#cb149-15" aria-hidden="true" tabindex="-1"></a>      inport  <span class="wa">rwb: </span> rwb</span>
<span id="cb149-16"><a href="#cb149-16" aria-hidden="true" tabindex="-1"></a>      inport  <span class="wa">req: </span> req</span>
<span id="cb149-17"><a href="#cb149-17" aria-hidden="true" tabindex="-1"></a>      outport <span class="wa">ack: </span> ack</span>
<span id="cb149-18"><a href="#cb149-18" aria-hidden="true" tabindex="-1"></a>      code <span class="st">&quot;some_sw.rb&quot;</span></span>
<span id="cb149-19"><a href="#cb149-19" aria-hidden="true" tabindex="-1"></a>   <span class="cf">end</span></span>
<span id="cb149-20"><a href="#cb149-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb149-21"><a href="#cb149-21" aria-hidden="true" tabindex="-1"></a>   <span class="co"># The hw generating the tick activating the software part (e.g., an OS tick):</span></span>
<span id="cb149-22"><a href="#cb149-22" aria-hidden="true" tabindex="-1"></a>   <span class="co"># one tick every 10 clock cycles.</span></span>
<span id="cb149-23"><a href="#cb149-23" aria-hidden="true" tabindex="-1"></a>   inner <span class="wa">:tick</span></span>
<span id="cb149-24"><a href="#cb149-24" aria-hidden="true" tabindex="-1"></a>   (tick <span class="kw">&lt;=</span> <span class="kw">~</span>rst <span class="kw">&amp;</span> <span class="kw">~</span>tick)<span class="at">.at</span>(clk<span class="at">.posedge</span> <span class="kw">*</span> <span class="dv">5</span>)</span>
<span id="cb149-25"><a href="#cb149-25" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb149-26"><a href="#cb149-26" aria-hidden="true" tabindex="-1"></a>   <span class="co"># Description of the software part.</span></span>
<span id="cb149-27"><a href="#cb149-27" aria-hidden="true" tabindex="-1"></a>   program(<span class="wa">:ruby</span>,<span class="wa">:some_sw</span>) <span class="cf">do</span></span>
<span id="cb149-28"><a href="#cb149-28" aria-hidden="true" tabindex="-1"></a>      actport tick</span>
<span id="cb149-29"><a href="#cb149-29" aria-hidden="true" tabindex="-1"></a>      code <span class="st">&quot;some_sw.rb&quot;</span></span>
<span id="cb149-30"><a href="#cb149-30" aria-hidden="true" tabindex="-1"></a>   <span class="cf">end</span></span>
<span id="cb149-31"><a href="#cb149-31" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb149-32"><a href="#cb149-32" aria-hidden="true" tabindex="-1"></a>   <span class="co"># Some hardware code accessing the memory.</span></span>
<span id="cb149-33"><a href="#cb149-33" aria-hidden="true" tabindex="-1"></a>   sequencer(clk,rst) <span class="cf">do</span></span>
<span id="cb149-34"><a href="#cb149-34" aria-hidden="true" tabindex="-1"></a>      <span class="co"># At first, fill the memory with 0.</span></span>
<span id="cb149-35"><a href="#cb149-35" aria-hidden="true" tabindex="-1"></a>      req <span class="kw">&lt;=</span> <span class="dv">1</span></span>
<span id="cb149-36"><a href="#cb149-36" aria-hidden="true" tabindex="-1"></a>      rwb <span class="kw">&lt;=</span> <span class="dv">0</span></span>
<span id="cb149-37"><a href="#cb149-37" aria-hidden="true" tabindex="-1"></a>      swhile(<span class="kw">~</span>ack) <span class="co"># Wait for the access grant to memory.</span></span>
<span id="cb149-38"><a href="#cb149-38" aria-hidden="true" tabindex="-1"></a>      dout <span class="kw">&lt;=</span> <span class="dv">0</span></span>
<span id="cb149-39"><a href="#cb149-39" aria-hidden="true" tabindex="-1"></a>      <span class="dv">256</span><span class="at">.stimes</span> <span class="kw">{</span> <span class="kw">|</span>i<span class="kw">|</span> addr_hw <span class="kw">&lt;=</span> i <span class="kw">}</span></span>
<span id="cb149-40"><a href="#cb149-40" aria-hidden="true" tabindex="-1"></a>      req <span class="kw">&lt;=</span> <span class="dv">0</span> <span class="co"># End the transactions.</span></span>
<span id="cb149-41"><a href="#cb149-41" aria-hidden="true" tabindex="-1"></a>      <span class="co"># Now, do infinitively some arbitrary computations with the content</span></span>
<span id="cb149-42"><a href="#cb149-42" aria-hidden="true" tabindex="-1"></a>      <span class="co"># of the memory.</span></span>
<span id="cb149-43"><a href="#cb149-43" aria-hidden="true" tabindex="-1"></a>      sloop <span class="cf">do</span></span>
<span id="cb149-44"><a href="#cb149-44" aria-hidden="true" tabindex="-1"></a>         <span class="dv">128</span><span class="at">.stimes</span> <span class="cf">do</span> <span class="kw">|</span>i<span class="kw">|</span></span>
<span id="cb149-45"><a href="#cb149-45" aria-hidden="true" tabindex="-1"></a>            <span class="kw">[</span><span class="dv">8</span><span class="kw">]</span><span class="at">.inner</span> <span class="wa">:tmp</span></span>
<span id="cb149-46"><a href="#cb149-46" aria-hidden="true" tabindex="-1"></a>            req <span class="kw">&lt;=</span> <span class="dv">1</span></span>
<span id="cb149-47"><a href="#cb149-47" aria-hidden="true" tabindex="-1"></a>            rwb <span class="kw">&lt;=</span> <span class="dv">1</span></span>
<span id="cb149-48"><a href="#cb149-48" aria-hidden="true" tabindex="-1"></a>            addr <span class="kw">&lt;=</span> i</span>
<span id="cb149-49"><a href="#cb149-49" aria-hidden="true" tabindex="-1"></a>            swhile(<span class="kw">~</span>ack)</span>
<span id="cb149-50"><a href="#cb149-50" aria-hidden="true" tabindex="-1"></a>            tmp <span class="kw">&lt;=</span> din</span>
<span id="cb149-51"><a href="#cb149-51" aria-hidden="true" tabindex="-1"></a>            step</span>
<span id="cb149-52"><a href="#cb149-52" aria-hidden="true" tabindex="-1"></a>            rwb  <span class="kw">&lt;=</span> <span class="dv">0</span></span>
<span id="cb149-53"><a href="#cb149-53" aria-hidden="true" tabindex="-1"></a>            addr <span class="kw">&lt;=</span> i <span class="kw">+</span> <span class="dv">128</span></span>
<span id="cb149-54"><a href="#cb149-54" aria-hidden="true" tabindex="-1"></a>            dout <span class="kw">&lt;=</span> tmp <span class="kw">*</span>tmp   <span class="co"># Just some senseless data.</span></span>
<span id="cb149-55"><a href="#cb149-55" aria-hidden="true" tabindex="-1"></a>            step</span>
<span id="cb149-56"><a href="#cb149-56" aria-hidden="true" tabindex="-1"></a>            req <span class="kw">&lt;=</span> <span class="dv">0</span></span>
<span id="cb149-57"><a href="#cb149-57" aria-hidden="true" tabindex="-1"></a>         <span class="cf">end</span></span>
<span id="cb149-58"><a href="#cb149-58" aria-hidden="true" tabindex="-1"></a>      <span class="cf">end</span></span>
<span id="cb149-59"><a href="#cb149-59" aria-hidden="true" tabindex="-1"></a>   <span class="cf">end</span></span></code></pre></div>
<p>This time the arbiter has been integrated into the black box modeling
the memory so that the hardware part only has to use the direct memory
signals <code>addr</code>, <code>din</code>, <code>dout</code>,
<code>rwb</code>, <code>req</code> and <code>ack</code>. The code of the
software part contains two functions, one for modeling the memory
<code>memory</code>, and the previous software function
<code>some_sw</code>. For the sake of concision, both are included in
the same file given below, but for a real design, it would be better to
put them in different files so that the real software is separated from
the black box simulation code.</p>
<div class="sourceCode" id="cb150"><pre
class="sourceCode ruby"><code class="sourceCode ruby"><span id="cb150-1"><a href="#cb150-1" aria-hidden="true" tabindex="-1"></a><span class="fu">require</span> <span class="vs">&#39;rubyHDL.rb&#39;</span></span>
<span id="cb150-2"><a href="#cb150-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb150-3"><a href="#cb150-3" aria-hidden="true" tabindex="-1"></a><span class="cn">MEM</span> <span class="kw">=</span> <span class="kw">[</span><span class="dv">0</span><span class="kw">]</span> <span class="kw">*</span> <span class="dv">256</span></span>
<span id="cb150-4"><a href="#cb150-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb150-5"><a href="#cb150-5" aria-hidden="true" tabindex="-1"></a><span class="va">$priority</span> <span class="kw">=</span> <span class="dv">0</span></span>
<span id="cb150-6"><a href="#cb150-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb150-7"><a href="#cb150-7" aria-hidden="true" tabindex="-1"></a><span class="cf">def</span> memory</span>
<span id="cb150-8"><a href="#cb150-8" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Is there an access request from the HW?</span></span>
<span id="cb150-9"><a href="#cb150-9" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span>(<span class="dt">RubyHDL</span><span class="at">.req</span> <span class="kw">==</span> <span class="dv">1</span>) <span class="cf">then</span></span>
<span id="cb150-10"><a href="#cb150-10" aria-hidden="true" tabindex="-1"></a>       <span class="co"># Is it being processed?</span></span>
<span id="cb150-11"><a href="#cb150-11" aria-hidden="true" tabindex="-1"></a>       <span class="cf">if</span> (<span class="dt">RubyHDL</span><span class="at">.ack</span> <span class="kw">==</span> <span class="dv">1</span>) <span class="cf">then</span></span>
<span id="cb150-12"><a href="#cb150-12" aria-hidden="true" tabindex="-1"></a>          <span class="co"># Yes, go on processing.</span></span>
<span id="cb150-13"><a href="#cb150-13" aria-hidden="true" tabindex="-1"></a>          <span class="cf">if</span> (<span class="dt">RubyHDL</span><span class="at">.rwb</span> <span class="kw">==</span> <span class="dv">1</span>) <span class="cf">then</span></span>
<span id="cb150-14"><a href="#cb150-14" aria-hidden="true" tabindex="-1"></a>             <span class="co"># Read access.</span></span>
<span id="cb150-15"><a href="#cb150-15" aria-hidden="true" tabindex="-1"></a>             <span class="dt">RubyHDL</span><span class="at">.dout</span> <span class="kw">=</span> <span class="cn">MEM</span><span class="kw">[</span><span class="dt">RubyHDL</span><span class="at">.addr</span><span class="kw">]</span></span>
<span id="cb150-16"><a href="#cb150-16" aria-hidden="true" tabindex="-1"></a>          <span class="cf">else</span></span>
<span id="cb150-17"><a href="#cb150-17" aria-hidden="true" tabindex="-1"></a>             <span class="co"># Write access.</span></span>
<span id="cb150-18"><a href="#cb150-18" aria-hidden="true" tabindex="-1"></a>             <span class="cn">MEM</span><span class="kw">[</span><span class="dt">RubyHDL</span><span class="at">.addr</span><span class="kw">]</span> <span class="kw">=</span> <span class="dt">RubyHDL</span><span class="at">.din</span></span>
<span id="cb150-19"><a href="#cb150-19" aria-hidden="true" tabindex="-1"></a>          <span class="cf">end</span></span>
<span id="cb150-20"><a href="#cb150-20" aria-hidden="true" tabindex="-1"></a>       <span class="cf">elsif</span> (<span class="va">$priority</span> <span class="kw">==</span> <span class="dv">0</span>)</span>
<span id="cb150-21"><a href="#cb150-21" aria-hidden="true" tabindex="-1"></a>          <span class="co"># Grant the access.</span></span>
<span id="cb150-22"><a href="#cb150-22" aria-hidden="true" tabindex="-1"></a>          <span class="dt">RubyHDL</span><span class="at">.ack</span> <span class="kw">=</span> <span class="dv">1</span></span>
<span id="cb150-23"><a href="#cb150-23" aria-hidden="true" tabindex="-1"></a>          <span class="va">$priority</span> <span class="kw">=</span> <span class="dv">1</span></span>
<span id="cb150-24"><a href="#cb150-24" aria-hidden="true" tabindex="-1"></a>       <span class="cf">end</span></span>
<span id="cb150-25"><a href="#cb150-25" aria-hidden="true" tabindex="-1"></a>    <span class="cf">end</span></span>
<span id="cb150-26"><a href="#cb150-26" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span></span>
<span id="cb150-27"><a href="#cb150-27" aria-hidden="true" tabindex="-1"></a>       <span class="co"># No, ensure the access grant is removed.</span></span>
<span id="cb150-28"><a href="#cb150-28" aria-hidden="true" tabindex="-1"></a>       <span class="dt">RubyHDL</span><span class="at">.ack</span> <span class="kw">=</span> <span class="dv">0</span></span>
<span id="cb150-29"><a href="#cb150-29" aria-hidden="true" tabindex="-1"></a>    <span class="cf">end</span></span>
<span id="cb150-30"><a href="#cb150-30" aria-hidden="true" tabindex="-1"></a><span class="cf">end</span></span>
<span id="cb150-31"><a href="#cb150-31" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb150-32"><a href="#cb150-32" aria-hidden="true" tabindex="-1"></a><span class="va">$addr</span> <span class="kw">=</span> <span class="dv">0</span></span>
<span id="cb150-33"><a href="#cb150-33" aria-hidden="true" tabindex="-1"></a><span class="va">$state</span> <span class="kw">=</span> <span class="dv">0</span></span>
<span id="cb150-34"><a href="#cb150-34" aria-hidden="true" tabindex="-1"></a><span class="va">$tmp</span> <span class="kw">=</span> <span class="dv">0</span></span>
<span id="cb150-35"><a href="#cb150-35" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb150-36"><a href="#cb150-36" aria-hidden="true" tabindex="-1"></a><span class="cf">def</span> some_sw</span>
<span id="cb150-37"><a href="#cb150-37" aria-hidden="true" tabindex="-1"></a>   <span class="cf">if</span>(<span class="dt">RubyHDL</span><span class="at">.ack</span> <span class="kw">==</span> <span class="dv">0</span>) <span class="cf">then</span></span>
<span id="cb150-38"><a href="#cb150-38" aria-hidden="true" tabindex="-1"></a>      <span class="co"># The access from HW to memory not granted, can go an.</span></span>
<span id="cb150-39"><a href="#cb150-39" aria-hidden="true" tabindex="-1"></a>      <span class="cf">case</span>(<span class="va">$state</span>)</span>
<span id="cb150-40"><a href="#cb150-40" aria-hidden="true" tabindex="-1"></a>      <span class="cf">when</span> <span class="dv">0</span>:</span>
<span id="cb150-41"><a href="#cb150-41" aria-hidden="true" tabindex="-1"></a>         <span class="cf">if</span> (<span class="va">$priority</span> <span class="kw">==</span> <span class="dv">1</span>) <span class="cf">then</span></span>
<span id="cb150-42"><a href="#cb150-42" aria-hidden="true" tabindex="-1"></a>            <span class="va">$state</span> <span class="kw">=</span> <span class="dv">1</span></span>
<span id="cb150-43"><a href="#cb150-43" aria-hidden="true" tabindex="-1"></a>         <span class="cf">end</span></span>
<span id="cb150-44"><a href="#cb150-44" aria-hidden="true" tabindex="-1"></a>      <span class="cf">when</span> <span class="dv">1</span>:</span>
<span id="cb150-45"><a href="#cb150-45" aria-hidden="true" tabindex="-1"></a>         <span class="va">$tmp</span> <span class="kw">=</span> <span class="cn">MEM</span><span class="kw">[</span><span class="va">$addr</span><span class="kw">+</span><span class="dv">128</span><span class="kw">]</span></span>
<span id="cb150-46"><a href="#cb150-46" aria-hidden="true" tabindex="-1"></a>         <span class="fu">puts</span> <span class="st">&quot;Read: </span><span class="sc">#{</span><span class="va">$tmp</span><span class="sc">}</span><span class="st">&quot;</span></span>
<span id="cb150-47"><a href="#cb150-47" aria-hidden="true" tabindex="-1"></a>         <span class="va">$state</span> <span class="kw">=</span> <span class="dv">2</span></span>
<span id="cb150-48"><a href="#cb150-48" aria-hidden="true" tabindex="-1"></a>      <span class="cf">when</span> <span class="dv">2</span>:</span>
<span id="cb150-49"><a href="#cb150-49" aria-hidden="true" tabindex="-1"></a>         <span class="fu">puts</span> <span class="st">&quot;Write: </span><span class="sc">#{</span><span class="va">$tmp</span> <span class="kw">+</span> <span class="dv">1</span><span class="sc">}</span><span class="st">&quot;</span></span>
<span id="cb150-50"><a href="#cb150-50" aria-hidden="true" tabindex="-1"></a>         <span class="cn">MEM</span><span class="kw">[</span><span class="va">$addr</span><span class="kw">]</span> <span class="kw">=</span> <span class="va">$tmp</span> <span class="kw">+</span> <span class="dv">1</span>      <span class="co"># Write some random computation result from</span></span>
<span id="cb150-51"><a href="#cb150-51" aria-hidden="true" tabindex="-1"></a>         <span class="va">$state</span> <span class="kw">=</span> <span class="dv">0</span>                 <span class="co"># the previously read data. </span></span>
<span id="cb150-52"><a href="#cb150-52" aria-hidden="true" tabindex="-1"></a>         <span class="va">$addr</span>  <span class="kw">=</span> (<span class="va">$addr</span> <span class="kw">+</span> <span class="dv">1</span>) <span class="kw">&amp;</span> <span class="dv">255</span> <span class="co"># Next address.</span></span>
<span id="cb150-53"><a href="#cb150-53" aria-hidden="true" tabindex="-1"></a>         <span class="va">$priority</span> <span class="kw">=</span> <span class="dv">0</span></span>
<span id="cb150-54"><a href="#cb150-54" aria-hidden="true" tabindex="-1"></a>      <span class="cf">end</span></span>
<span id="cb150-55"><a href="#cb150-55" aria-hidden="true" tabindex="-1"></a>   <span class="cf">end</span></span>
<span id="cb150-56"><a href="#cb150-56" aria-hidden="true" tabindex="-1"></a><span class="cf">end</span></span></code></pre></div>
<p>In this example, the memory is modeled by a simple array. The
function <code>memory</code> handles the accesses from the hardware and
the arbitration between software and hardware access using a round-robin
algorithm. The software program given by function <code>some_sw</code>
is identical to the previous one, apart from the memory access which is
a direct array access, and the check of the memory grant, since this
time no software-specific signal is used for the arbitration.</p>
<h5 id="modeling-an-operating-system">7.4.2 Modeling an operating
system</h5>
<p>Usually, software is executed on top of an operating system, or a
minimal runtime, e.g., even the plainest C runs on top of
<code>crt0</code>. This low-level software is usually fixed and highly
target-dependent. Hence, it is usually enough to simulate this behavior.
Since the HDLRuby simulator supports any compiled C (or other compatible
compiled language), or Ruby, all the techniques that can be used in
these languages for abstract low-level software can be used. Here, we
will use Ruby threads as an illustration for modeling a simple multitask
system with an interrupt handler. In the example, there will be two
tasks, one reading data from a dummy hardware device described in
HDLRuby, transmitting it using a pipe to another one which writes its
data to the standard output every second.</p>
<div class="sourceCode" id="cb151"><pre
class="sourceCode ruby"><code class="sourceCode ruby"><span id="cb151-1"><a href="#cb151-1" aria-hidden="true" tabindex="-1"></a><span class="fu">system</span> <span class="wa">:hw_sw_with_os</span> <span class="cf">do</span></span>
<span id="cb151-2"><a href="#cb151-2" aria-hidden="true" tabindex="-1"></a>   inner <span class="wa">:clk</span>,<span class="wa">:rst</span></span>
<span id="cb151-3"><a href="#cb151-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb151-4"><a href="#cb151-4" aria-hidden="true" tabindex="-1"></a>   <span class="co"># The OS tick</span></span>
<span id="cb151-5"><a href="#cb151-5" aria-hidden="true" tabindex="-1"></a>   inner <span class="wa">:tick</span></span>
<span id="cb151-6"><a href="#cb151-6" aria-hidden="true" tabindex="-1"></a>   (tick <span class="kw">&lt;=</span> <span class="kw">~</span>rst <span class="kw">&amp;</span> <span class="kw">~</span>tick)<span class="at">.at</span>(clk<span class="at">.posedge</span> <span class="kw">*</span> <span class="dv">5</span>)</span>
<span id="cb151-7"><a href="#cb151-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb151-8"><a href="#cb151-8" aria-hidden="true" tabindex="-1"></a>   <span class="co"># The general interrupt signal: interrupt request, acknowledge, and number</span></span>
<span id="cb151-9"><a href="#cb151-9" aria-hidden="true" tabindex="-1"></a>   inner <span class="wa">:irq</span>, <span class="wa">:iak</span></span>
<span id="cb151-10"><a href="#cb151-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb151-11"><a href="#cb151-11" aria-hidden="true" tabindex="-1"></a>   <span class="co"># A register that </span></span>
<span id="cb151-12"><a href="#cb151-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb151-13"><a href="#cb151-13" aria-hidden="true" tabindex="-1"></a>   <span class="co"># The os model.</span></span>
<span id="cb151-14"><a href="#cb151-14" aria-hidden="true" tabindex="-1"></a>   program(<span class="wa">:ruby</span>, <span class="wa">:os</span>) <span class="cf">do</span></span>
<span id="cb151-15"><a href="#cb151-15" aria-hidden="true" tabindex="-1"></a>      actport <span class="wa">tick: </span>tick</span>
<span id="cb151-16"><a href="#cb151-16" aria-hidden="true" tabindex="-1"></a>      inport <span class="wa">register: </span>register     <span class="co"># Some register direcly acessible by software</span></span>
<span id="cb151-17"><a href="#cb151-17" aria-hidden="true" tabindex="-1"></a>      code <span class="st">&quot;sw_with_os.rb&quot;</span></span>
<span id="cb151-18"><a href="#cb151-18" aria-hidden="true" tabindex="-1"></a>   <span class="cf">end</span></span>
<span id="cb151-19"><a href="#cb151-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb151-20"><a href="#cb151-20" aria-hidden="true" tabindex="-1"></a>   <span class="co"># The interrupt handler.</span></span>
<span id="cb151-21"><a href="#cb151-21" aria-hidden="true" tabindex="-1"></a>   program(<span class="wa">:ruby</span>,<span class="wa">:handler</span>) <span class="cf">do</span></span>
<span id="cb151-22"><a href="#cb151-22" aria-hidden="true" tabindex="-1"></a>      actport <span class="wa">irq: </span>irq</span>
<span id="cb151-23"><a href="#cb151-23" aria-hidden="true" tabindex="-1"></a>      outport <span class="wa">iak: </span>iak</span>
<span id="cb151-24"><a href="#cb151-24" aria-hidden="true" tabindex="-1"></a>      code <span class="st">&quot;sw_with_os.rb&quot;</span></span>
<span id="cb151-25"><a href="#cb151-25" aria-hidden="true" tabindex="-1"></a>   <span class="cf">end</span></span>
<span id="cb151-26"><a href="#cb151-26" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb151-27"><a href="#cb151-27" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb151-28"><a href="#cb151-28" aria-hidden="true" tabindex="-1"></a>   <span class="co"># Some dummy hardware generating data (counting clocks) and raising an</span></span>
<span id="cb151-29"><a href="#cb151-29" aria-hidden="true" tabindex="-1"></a>   <span class="co"># interrupt when the data is ready on a software-accessible register.</span></span>
<span id="cb151-30"><a href="#cb151-30" aria-hidden="true" tabindex="-1"></a>   par(clk<span class="at">.posedge</span>) <span class="cf">do</span></span>
<span id="cb151-31"><a href="#cb151-31" aria-hidden="true" tabindex="-1"></a>      hif(rst) <span class="kw">{</span> register <span class="kw">&lt;=</span> <span class="dv">0</span> <span class="kw">}</span></span>
<span id="cb151-32"><a href="#cb151-32" aria-hidden="true" tabindex="-1"></a>      helse <span class="cf">do</span></span>
<span id="cb151-33"><a href="#cb151-33" aria-hidden="true" tabindex="-1"></a>         <span class="co"># Increase the value of the register.</span></span>
<span id="cb151-34"><a href="#cb151-34" aria-hidden="true" tabindex="-1"></a>         register <span class="kw">&lt;=</span> register <span class="kw">+</span> <span class="dv">1</span></span>
<span id="cb151-35"><a href="#cb151-35" aria-hidden="true" tabindex="-1"></a>         <span class="co"># Handle the interrupts.</span></span>
<span id="cb151-36"><a href="#cb151-36" aria-hidden="true" tabindex="-1"></a>         hif(irq <span class="kw">==</span> <span class="dv">0</span>) <span class="cf">do</span></span>
<span id="cb151-37"><a href="#cb151-37" aria-hidden="true" tabindex="-1"></a>            <span class="co"># Is the prevous irq have been processed?</span></span>
<span id="cb151-38"><a href="#cb151-38" aria-hidden="true" tabindex="-1"></a>            hif (iak <span class="kw">==</span> <span class="dv">0</span>) <span class="cf">do</span></span>
<span id="cb151-39"><a href="#cb151-39" aria-hidden="true" tabindex="-1"></a>               <span class="co"># Yes, raise an interrupt.</span></span>
<span id="cb151-40"><a href="#cb151-40" aria-hidden="true" tabindex="-1"></a>               irq <span class="kw">&lt;=</span> <span class="dv">1</span></span>
<span id="cb151-41"><a href="#cb151-41" aria-hidden="true" tabindex="-1"></a>            <span class="cf">end</span></span>
<span id="cb151-42"><a href="#cb151-42" aria-hidden="true" tabindex="-1"></a>         <span class="cf">else</span></span>
<span id="cb151-43"><a href="#cb151-43" aria-hidden="true" tabindex="-1"></a>            <span class="co"># Wait for the irq to be acknowledge.</span></span>
<span id="cb151-44"><a href="#cb151-44" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> (iak <span class="kw">==</span> <span class="dv">1</span>) <span class="kw">{</span> irq <span class="kw">&lt;=</span> <span class="dv">0</span> <span class="kw">}</span></span>
<span id="cb151-45"><a href="#cb151-45" aria-hidden="true" tabindex="-1"></a>         <span class="cf">end</span></span>
<span id="cb151-46"><a href="#cb151-46" aria-hidden="true" tabindex="-1"></a>      <span class="cf">end</span></span>
<span id="cb151-47"><a href="#cb151-47" aria-hidden="true" tabindex="-1"></a>   <span class="cf">end</span></span>
<span id="cb151-48"><a href="#cb151-48" aria-hidden="true" tabindex="-1"></a><span class="cf">end</span></span></code></pre></div>
<p>The software code <code>sw_with_os.rb</code> is as follows:</p>
<div class="sourceCode" id="cb152"><pre
class="sourceCode ruby"><code class="sourceCode ruby"><span id="cb152-1"><a href="#cb152-1" aria-hidden="true" tabindex="-1"></a><span class="fu">require</span> <span class="vs">&#39;rubyHDL.rb&#39;</span></span>
<span id="cb152-2"><a href="#cb152-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb152-3"><a href="#cb152-3" aria-hidden="true" tabindex="-1"></a><span class="va">$register</span> <span class="kw">=</span> <span class="dv">0</span></span>
<span id="cb152-4"><a href="#cb152-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb152-5"><a href="#cb152-5" aria-hidden="true" tabindex="-1"></a><span class="va">$start</span> <span class="kw">=</span> <span class="dv">true</span></span>
<span id="cb152-6"><a href="#cb152-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb152-7"><a href="#cb152-7" aria-hidden="true" tabindex="-1"></a><span class="co"># The os simulation function. Initialize the tasks and the communication pipe</span></span>
<span id="cb152-8"><a href="#cb152-8" aria-hidden="true" tabindex="-1"></a><span class="co"># for the first call, then update the value of the $register variable.</span></span>
<span id="cb152-9"><a href="#cb152-9" aria-hidden="true" tabindex="-1"></a><span class="cf">def</span> os</span>
<span id="cb152-10"><a href="#cb152-10" aria-hidden="true" tabindex="-1"></a>   <span class="cf">if</span>(<span class="va">$start</span>) <span class="cf">then</span></span>
<span id="cb152-11"><a href="#cb152-11" aria-hidden="true" tabindex="-1"></a>      <span class="co"># Create the communication pipe.</span></span>
<span id="cb152-12"><a href="#cb152-12" aria-hidden="true" tabindex="-1"></a>      <span class="va">$pout</span>, <span class="va">$pin</span> <span class="kw">=</span> <span class="cn">IO</span><span class="at">.pipe</span></span>
<span id="cb152-13"><a href="#cb152-13" aria-hidden="true" tabindex="-1"></a>      <span class="va">$tasks</span> <span class="kw">=</span> <span class="kw">[]</span></span>
<span id="cb152-14"><a href="#cb152-14" aria-hidden="true" tabindex="-1"></a>      <span class="co"># Create the first task reading the values.</span></span>
<span id="cb152-15"><a href="#cb152-15" aria-hidden="true" tabindex="-1"></a>      <span class="va">$tasks</span> <span class="kw">&lt;&lt;</span> <span class="dt">Thread</span><span class="at">.new</span>(<span class="kw">&amp;</span><span class="dt">Kernel</span><span class="at">.method</span>(<span class="wa">:read_task</span>))</span>
<span id="cb152-16"><a href="#cb152-16" aria-hidden="true" tabindex="-1"></a>      <span class="co"># Create the second task displaying the values.</span></span>
<span id="cb152-17"><a href="#cb152-17" aria-hidden="true" tabindex="-1"></a>      <span class="va">$tasks</span> <span class="kw">&lt;&lt;</span> <span class="dt">Thread</span><span class="at">.new</span>(<span class="kw">&amp;</span><span class="dt">Kernel</span><span class="at">.method</span>(<span class="wa">:show_task</span>))</span>
<span id="cb152-18"><a href="#cb152-18" aria-hidden="true" tabindex="-1"></a>      <span class="va">$start</span> <span class="kw">=</span> <span class="dv">false</span></span>
<span id="cb152-19"><a href="#cb152-19" aria-hidden="true" tabindex="-1"></a>   <span class="cf">else</span></span>
<span id="cb152-20"><a href="#cb152-20" aria-hidden="true" tabindex="-1"></a>      <span class="co"># Update $register.</span></span>
<span id="cb152-21"><a href="#cb152-21" aria-hidden="true" tabindex="-1"></a>      <span class="va">$register</span> <span class="kw">=</span> <span class="dt">RubyHDL</span><span class="at">.register</span></span>
<span id="cb152-22"><a href="#cb152-22" aria-hidden="true" tabindex="-1"></a>   <span class="cf">end</span></span>
<span id="cb152-23"><a href="#cb152-23" aria-hidden="true" tabindex="-1"></a><span class="cf">end</span></span>
<span id="cb152-24"><a href="#cb152-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb152-25"><a href="#cb152-25" aria-hidden="true" tabindex="-1"></a><span class="co"># The interrupt handler: acknowledge the interrupt, wakes up the read task.</span></span>
<span id="cb152-26"><a href="#cb152-26" aria-hidden="true" tabindex="-1"></a><span class="cf">def</span> handler</span>
<span id="cb152-27"><a href="#cb152-27" aria-hidden="true" tabindex="-1"></a>   <span class="dt">RubyHDL</span><span class="at">.iak</span> <span class="kw">=</span> <span class="dv">1</span></span>
<span id="cb152-28"><a href="#cb152-28" aria-hidden="true" tabindex="-1"></a>   <span class="va">$tasks</span><span class="kw">[</span><span class="dv">0</span><span class="kw">]</span><span class="at">.run</span></span>
<span id="cb152-29"><a href="#cb152-29" aria-hidden="true" tabindex="-1"></a><span class="cf">end</span></span>
<span id="cb152-30"><a href="#cb152-30" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb152-31"><a href="#cb152-31" aria-hidden="true" tabindex="-1"></a><span class="co"># Waits an interrupt: sleep and when waked up tell another interrupt can come.</span></span>
<span id="cb152-32"><a href="#cb152-32" aria-hidden="true" tabindex="-1"></a><span class="cf">def</span> wait_irq</span>
<span id="cb152-33"><a href="#cb152-33" aria-hidden="true" tabindex="-1"></a>   <span class="fu">sleep</span></span>
<span id="cb152-34"><a href="#cb152-34" aria-hidden="true" tabindex="-1"></a>   <span class="dt">RubyHDL</span><span class="at">.iak</span> <span class="kw">=</span> <span class="dv">0</span></span>
<span id="cb152-35"><a href="#cb152-35" aria-hidden="true" tabindex="-1"></a><span class="cf">end</span></span>
<span id="cb152-36"><a href="#cb152-36" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb152-37"><a href="#cb152-37" aria-hidden="true" tabindex="-1"></a><span class="co"># The reading task: wait an interrupt then get a value and add it to the pipe.</span></span>
<span id="cb152-38"><a href="#cb152-38" aria-hidden="true" tabindex="-1"></a><span class="cf">def</span> read_task</span>
<span id="cb152-39"><a href="#cb152-39" aria-hidden="true" tabindex="-1"></a>   <span class="fu">loop</span> <span class="cf">do</span></span>
<span id="cb152-40"><a href="#cb152-40" aria-hidden="true" tabindex="-1"></a>      wait_irq</span>
<span id="cb152-41"><a href="#cb152-41" aria-hidden="true" tabindex="-1"></a>      <span class="va">$pin</span> <span class="kw">&lt;&lt;</span> <span class="va">$register</span><span class="at">.to_s</span></span>
<span id="cb152-42"><a href="#cb152-42" aria-hidden="true" tabindex="-1"></a>   <span class="cf">end</span></span>
<span id="cb152-43"><a href="#cb152-43" aria-hidden="true" tabindex="-1"></a><span class="cf">end</span></span>
<span id="cb152-44"><a href="#cb152-44" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb152-45"><a href="#cb152-45" aria-hidden="true" tabindex="-1"></a><span class="co"># The displaying task: write in stdout the data obtained from the pipe each</span></span>
<span id="cb152-46"><a href="#cb152-46" aria-hidden="true" tabindex="-1"></a><span class="co"># second.</span></span>
<span id="cb152-47"><a href="#cb152-47" aria-hidden="true" tabindex="-1"></a><span class="cf">def</span> show_task</span>
<span id="cb152-48"><a href="#cb152-48" aria-hidden="true" tabindex="-1"></a>   <span class="fu">loop</span> <span class="cf">do</span></span>
<span id="cb152-49"><a href="#cb152-49" aria-hidden="true" tabindex="-1"></a>      <span class="fu">sleep</span>(<span class="dv">1</span>)</span>
<span id="cb152-50"><a href="#cb152-50" aria-hidden="true" tabindex="-1"></a>      <span class="fu">puts</span> <span class="va">$pout</span><span class="at">.readline</span></span>
<span id="cb152-51"><a href="#cb152-51" aria-hidden="true" tabindex="-1"></a>   <span class="cf">end</span></span>
<span id="cb152-52"><a href="#cb152-52" aria-hidden="true" tabindex="-1"></a><span class="cf">end</span></span></code></pre></div>
<h3 id="hardware-software-co-synthesis">7.5. Hardware-software
co-synthesis</h3>
<p>The HDLRuby compiler can be applied to HDLRuby description containing
program. However, when producing Verilog HDL or VHDL files, the compiler
will ignore the prorgam session. The reason is because the integration
of hardware and software is highly target dependent and often licensed.
However, you can use the HDLRuby integration of programs using ports for
decribing the integration specific to a given target.</p>
<p>As an illustration, let us assume that we want to design an
application for a very basic SoC system including a CPU and a FPGA where
a set of 8-bit FPGA registers are memory-mapped to the CPU through a set
of predefined addresses: input with <code>fi0</code> to <code>fi3</code>
for respective addresses <code>0xC000</code> to <code>0xC009</code>, and
output with <code>fo0</code> to <code>fo3</code> for respective
addresses <code>0xC010</code> to <code>0xC020</code>. For this case, the
HDLRuby module representing the target system and the corresponding
program construct can be written as follows:</p>
<div class="sourceCode" id="cb153"><pre
class="sourceCode ruby"><code class="sourceCode ruby"><span id="cb153-1"><a href="#cb153-1" aria-hidden="true" tabindex="-1"></a><span class="fu">system</span> <span class="wa">:soc_basic</span> <span class="cf">do</span></span>
<span id="cb153-2"><a href="#cb153-2" aria-hidden="true" tabindex="-1"></a>  input <span class="wa">:clk</span></span>
<span id="cb153-3"><a href="#cb153-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">[</span><span class="dv">8</span><span class="kw">]</span><span class="at">.input</span>  <span class="wa">:fi0</span>, <span class="wa">:fi1</span>, <span class="wa">:fi2</span>, <span class="wa">:fi3</span></span>
<span id="cb153-4"><a href="#cb153-4" aria-hidden="true" tabindex="-1"></a>  <span class="kw">[</span><span class="dv">8</span><span class="kw">]</span><span class="at">.output</span> <span class="wa">:fo0</span>, <span class="wa">:fo1</span>, <span class="wa">:fo2</span>, <span class="wa">:fo3</span></span>
<span id="cb153-5"><a href="#cb153-5" aria-hidden="true" tabindex="-1"></a>  <span class="kw">...</span></span>
<span id="cb153-6"><a href="#cb153-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb153-7"><a href="#cb153-7" aria-hidden="true" tabindex="-1"></a>  program(<span class="wa">:c</span>, <span class="wa">:my_func</span>) <span class="cf">do</span></span>
<span id="cb153-8"><a href="#cb153-8" aria-hidden="true" tabindex="-1"></a>    actport clk<span class="at">.posedge</span></span>
<span id="cb153-9"><a href="#cb153-9" aria-hidden="true" tabindex="-1"></a>    outport <span class="wa">fi0: </span>fi0, <span class="wa">fi1: </span>fi1, <span class="wa">fi2: </span>fi2, <span class="wa">fi3: </span>fi3</span>
<span id="cb153-10"><a href="#cb153-10" aria-hidden="true" tabindex="-1"></a>    inport  <span class="wa">fo0: </span>fo0, <span class="wa">fo1: </span>fo1, <span class="wa">fo2: </span>fo2, <span class="wa">fo3: </span>fo3</span>
<span id="cb153-11"><a href="#cb153-11" aria-hidden="true" tabindex="-1"></a>    code <span class="st">&quot;my_soft.c&quot;</span></span>
<span id="cb153-12"><a href="#cb153-12" aria-hidden="true" tabindex="-1"></a>  <span class="cf">end</span></span>
<span id="cb153-13"><a href="#cb153-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb153-14"><a href="#cb153-14" aria-hidden="true" tabindex="-1"></a>  <span class="kw">&lt;</span> <span class="dt">Some</span> <span class="dt">HDLRuby</span> code describing the hardware part of the application <span class="kw">&gt;</span></span>
<span id="cb153-15"><a href="#cb153-15" aria-hidden="true" tabindex="-1"></a><span class="cf">end</span></span></code></pre></div>
<p>And the C program <code>my_soft.c</code> can be written as follows
using functions like <code>read_fo0()</code> for reading register
<code>fo0</code> and <code>write_fi1(val)</code> for writing to register
<code>fi1</code>, and calling only once <code>init_soclib</code> for
initializing the API library:</p>
<div class="sourceCode" id="cb154"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb154-1"><a href="#cb154-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&quot;soclib.h&quot;</span></span>
<span id="cb154-2"><a href="#cb154-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb154-3"><a href="#cb154-3" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> my_func<span class="op">()</span> <span class="op">{</span></span>
<span id="cb154-4"><a href="#cb154-4" aria-hidden="true" tabindex="-1"></a>    <span class="dt">static</span> <span class="dt">int</span> start <span class="op">=</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb154-5"><a href="#cb154-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span><span class="op">(</span>start<span class="op">)</span> <span class="op">{</span> init_scolib<span class="op">();</span> start <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> <span class="op">}</span></span>
<span id="cb154-6"><a href="#cb154-6" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb154-7"><a href="#cb154-7" aria-hidden="true" tabindex="-1"></a>    <span class="dt">char</span> fo0 <span class="op">=</span> read_fo0<span class="op">();</span></span>
<span id="cb154-8"><a href="#cb154-8" aria-hidden="true" tabindex="-1"></a>    <span class="op">...</span></span>
<span id="cb154-9"><a href="#cb154-9" aria-hidden="true" tabindex="-1"></a>    write_fi1<span class="op">(</span>val<span class="op">);</span></span>
<span id="cb154-10"><a href="#cb154-10" aria-hidden="true" tabindex="-1"></a>    <span class="op">...</span></span>
<span id="cb154-11"><a href="#cb154-11" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>Alternatively, the initialisation can be delegated to another program
construct in the HDLRuby code, activated on a reset signal. Then, the
respective hardware and software code becomes as follows:</p>
<div class="sourceCode" id="cb155"><pre
class="sourceCode ruby"><code class="sourceCode ruby"><span id="cb155-1"><a href="#cb155-1" aria-hidden="true" tabindex="-1"></a><span class="fu">system</span> <span class="wa">:soc_basic</span> <span class="cf">do</span></span>
<span id="cb155-2"><a href="#cb155-2" aria-hidden="true" tabindex="-1"></a>  input <span class="wa">:clk</span>, <span class="wa">:rst</span></span>
<span id="cb155-3"><a href="#cb155-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">[</span><span class="dv">8</span><span class="kw">]</span><span class="at">.input</span>  <span class="wa">:fi0</span>, <span class="wa">:fi1</span>, <span class="wa">:fi2</span>, <span class="wa">:fi3</span></span>
<span id="cb155-4"><a href="#cb155-4" aria-hidden="true" tabindex="-1"></a>  <span class="kw">[</span><span class="dv">8</span><span class="kw">]</span><span class="at">.output</span> <span class="wa">:fo0</span>, <span class="wa">:fo1</span>, <span class="wa">:fo2</span>, <span class="wa">:fo3</span></span>
<span id="cb155-5"><a href="#cb155-5" aria-hidden="true" tabindex="-1"></a>  <span class="kw">...</span></span>
<span id="cb155-6"><a href="#cb155-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb155-7"><a href="#cb155-7" aria-hidden="true" tabindex="-1"></a>  program(<span class="wa">:c</span>, <span class="wa">:init_soclib</span>) <span class="cf">do</span></span>
<span id="cb155-8"><a href="#cb155-8" aria-hidden="true" tabindex="-1"></a>    actport rst<span class="at">.posedge</span></span>
<span id="cb155-9"><a href="#cb155-9" aria-hidden="true" tabindex="-1"></a>  <span class="cf">end</span></span>
<span id="cb155-10"><a href="#cb155-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb155-11"><a href="#cb155-11" aria-hidden="true" tabindex="-1"></a>  program(<span class="wa">:c</span>, <span class="wa">:my_func</span>) <span class="cf">do</span></span>
<span id="cb155-12"><a href="#cb155-12" aria-hidden="true" tabindex="-1"></a>    actport clk<span class="at">.posedge</span></span>
<span id="cb155-13"><a href="#cb155-13" aria-hidden="true" tabindex="-1"></a>    outport <span class="wa">fi0: </span>fi0, <span class="wa">fi1: </span>fi1, <span class="wa">fi2: </span>fi2, <span class="wa">fi3: </span>fi3</span>
<span id="cb155-14"><a href="#cb155-14" aria-hidden="true" tabindex="-1"></a>    inport  <span class="wa">fo0: </span>fo0, <span class="wa">fo1: </span>fo1, <span class="wa">fo2: </span>fo2, <span class="wa">fo3: </span>fo3</span>
<span id="cb155-15"><a href="#cb155-15" aria-hidden="true" tabindex="-1"></a>    code <span class="st">&quot;my_soft.c&quot;</span></span>
<span id="cb155-16"><a href="#cb155-16" aria-hidden="true" tabindex="-1"></a>  <span class="cf">end</span></span>
<span id="cb155-17"><a href="#cb155-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb155-18"><a href="#cb155-18" aria-hidden="true" tabindex="-1"></a>  <span class="kw">&lt;</span> <span class="dt">Some</span> <span class="dt">HDLRuby</span> code describing the hardware part of the application <span class="kw">&gt;</span></span>
<span id="cb155-19"><a href="#cb155-19" aria-hidden="true" tabindex="-1"></a><span class="cf">end</span></span></code></pre></div>
<div class="sourceCode" id="cb156"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb156-1"><a href="#cb156-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&quot;soclib.h&quot;</span></span>
<span id="cb156-2"><a href="#cb156-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb156-3"><a href="#cb156-3" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> my_func<span class="op">()</span> <span class="op">{</span></span>
<span id="cb156-4"><a href="#cb156-4" aria-hidden="true" tabindex="-1"></a>    <span class="dt">char</span> fo0 <span class="op">=</span> read_fo0<span class="op">();</span></span>
<span id="cb156-5"><a href="#cb156-5" aria-hidden="true" tabindex="-1"></a>    <span class="op">...</span></span>
<span id="cb156-6"><a href="#cb156-6" aria-hidden="true" tabindex="-1"></a>    write_fi1<span class="op">(</span>val<span class="op">);</span></span>
<span id="cb156-7"><a href="#cb156-7" aria-hidden="true" tabindex="-1"></a>    <span class="op">...</span></span>
<span id="cb156-8"><a href="#cb156-8" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>Whatever the approach being used for the initialization, the read and
write functions are defined in the <code>soclib.h</code> file. Two
versions of this file are to be provided, one for running with the
HDLRuby simulator, and one for running for the target SoC. These two
files, with possible additional target constraints files (e.g., xcd file
for Xilinx platforms) are the sole additional file that are to be
provided by the user to have an application which can be both simulated
on the HDLRuby simulator, and synthesized for the target SoC. For the
example above, the HDLRuby version of <code>soclib.h</code> is as
follows:</p>
<div class="sourceCode" id="cb157"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb157-1"><a href="#cb157-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&quot;cHDL.h&quot;</span></span>
<span id="cb157-2"><a href="#cb157-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb157-3"><a href="#cb157-3" aria-hidden="true" tabindex="-1"></a><span class="dt">static</span> <span class="dt">void</span> <span class="op">*</span>fo0<span class="op">,</span> <span class="op">*</span>fo1<span class="op">,</span> <span class="op">*</span>fo2<span class="op">,</span> <span class="op">*</span>fo3<span class="op">;</span></span>
<span id="cb157-4"><a href="#cb157-4" aria-hidden="true" tabindex="-1"></a><span class="dt">static</span> <span class="dt">void</span> <span class="op">*</span>fi1<span class="op">,</span> <span class="op">*</span>fi1<span class="op">,</span> <span class="op">*</span>fi2<span class="op">,</span> <span class="op">*</span>fi3<span class="op">;</span></span>
<span id="cb157-5"><a href="#cb157-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb157-6"><a href="#cb157-6" aria-hidden="true" tabindex="-1"></a>soclib_init<span class="op">()</span> <span class="op">{</span></span>
<span id="cb157-7"><a href="#cb157-7" aria-hidden="true" tabindex="-1"></a>     fo0 <span class="op">=</span> c_get_port<span class="op">(</span><span class="st">&quot;fo0&quot;</span><span class="op">);</span></span>
<span id="cb157-8"><a href="#cb157-8" aria-hidden="true" tabindex="-1"></a>     <span class="op">...</span></span>
<span id="cb157-9"><a href="#cb157-9" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb157-10"><a href="#cb157-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb157-11"><a href="#cb157-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb157-12"><a href="#cb157-12" aria-hidden="true" tabindex="-1"></a><span class="pp">#define read_fo0</span><span class="op">()</span><span class="pp"> c_read_port</span><span class="op">(</span><span class="pp">fo0</span><span class="op">)</span></span>
<span id="cb157-13"><a href="#cb157-13" aria-hidden="true" tabindex="-1"></a><span class="op">...</span></span>
<span id="cb157-14"><a href="#cb157-14" aria-hidden="true" tabindex="-1"></a><span class="pp">#define write_fi1</span><span class="op">(</span><span class="pp">val</span><span class="op">)</span><span class="pp"> c_write_port</span><span class="op">(</span><span class="pp">fi1</span><span class="op">,(</span><span class="pp">val</span><span class="op">))</span></span>
<span id="cb157-15"><a href="#cb157-15" aria-hidden="true" tabindex="-1"></a><span class="op">...</span></span></code></pre></div>
<p>And the SoC specific version could look as follows, where
<code>target_soc_API.h</code> represents whatever include files required
for using the target SoC API:</p>
<div class="sourceCode" id="cb158"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb158-1"><a href="#cb158-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&quot;target_soc_API.h&quot;</span></span>
<span id="cb158-2"><a href="#cb158-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb158-3"><a href="#cb158-3" aria-hidden="true" tabindex="-1"></a>soclib_init<span class="op">()</span> <span class="op">{</span></span>
<span id="cb158-4"><a href="#cb158-4" aria-hidden="true" tabindex="-1"></a>   <span class="op">&lt;</span>Some initialization code <span class="cf">if</span> required by the target SoC API<span class="op">&gt;</span></span>
<span id="cb158-5"><a href="#cb158-5" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb158-6"><a href="#cb158-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb158-7"><a href="#cb158-7" aria-hidden="true" tabindex="-1"></a><span class="pp">#</span><span class="er">defined read_fo0() (*0xC010)</span></span>
<span id="cb158-8"><a href="#cb158-8" aria-hidden="true" tabindex="-1"></a><span class="op">...</span></span>
<span id="cb158-9"><a href="#cb158-9" aria-hidden="true" tabindex="-1"></a><span class="pp">#define write_fi1</span><span class="op">(</span><span class="pp">val</span><span class="op">)</span><span class="pp"> </span><span class="op">(*</span><span class="bn">0xC001</span><span class="pp"> </span><span class="op">=</span><span class="pp"> </span><span class="op">(</span><span class="pp">val</span><span class="op">))</span></span>
<span id="cb158-10"><a href="#cb158-10" aria-hidden="true" tabindex="-1"></a><span class="op">...</span></span></code></pre></div>
<h2 id="how-to-interact-with-the-simulator.">8. How to interact with the
simulator.</h2>
<h3 id="do-it-yourself-interaction.">8.1. Do-It-Yourself
interaction.</h3>
<p>Using the program construct presented in the prevous section, it easy
add basic interactions to the simulation of your module. For example,
you can read and write values from the standard input and map them to
HDLRuby signals using the following Ruby program
(<code>stdrw.rb</code>):</p>
<div class="sourceCode" id="cb159"><pre
class="sourceCode ruby"><code class="sourceCode ruby"><span id="cb159-1"><a href="#cb159-1" aria-hidden="true" tabindex="-1"></a><span class="fu">require</span> <span class="vs">&#39;RubyHDL&#39;</span></span>
<span id="cb159-2"><a href="#cb159-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb159-3"><a href="#cb159-3" aria-hidden="true" tabindex="-1"></a><span class="cf">def</span> stdrw</span>
<span id="cb159-4"><a href="#cb159-4" aria-hidden="true" tabindex="-1"></a>  <span class="dt">RubyHDL</span><span class="at">.sigI</span> <span class="kw">=</span> <span class="va">$stdin</span><span class="at">.read.to_i</span></span>
<span id="cb159-5"><a href="#cb159-5" aria-hidden="true" tabindex="-1"></a>  <span class="va">$stdout</span><span class="at">.puts</span>(<span class="dt">RubyHDL</span><span class="at">.sigO</span>)</span>
<span id="cb159-6"><a href="#cb159-6" aria-hidden="true" tabindex="-1"></a><span class="cf">end</span></span></code></pre></div>
<p>Then, a corresponding HDLRuby module that accumulates the read inputs
could be writen as follows:</p>
<div class="sourceCode" id="cb160"><pre
class="sourceCode ruby"><code class="sourceCode ruby"><span id="cb160-1"><a href="#cb160-1" aria-hidden="true" tabindex="-1"></a><span class="fu">system</span> <span class="wa">:accum</span> <span class="cf">do</span></span>
<span id="cb160-2"><a href="#cb160-2" aria-hidden="true" tabindex="-1"></a>  inner <span class="wa">:clk</span></span>
<span id="cb160-3"><a href="#cb160-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">[</span><span class="dv">32</span><span class="kw">]</span><span class="at">.inner</span> <span class="wa">:sigI</span>, <span class="wa">:sigO</span></span>
<span id="cb160-4"><a href="#cb160-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb160-5"><a href="#cb160-5" aria-hidden="true" tabindex="-1"></a>  program(<span class="wa">:ruby</span>,<span class="wa">:stdrw</span>) <span class="cf">do</span></span>
<span id="cb160-6"><a href="#cb160-6" aria-hidden="true" tabindex="-1"></a>    actport clk<span class="at">.posedge</span></span>
<span id="cb160-7"><a href="#cb160-7" aria-hidden="true" tabindex="-1"></a>    outport <span class="wa">sigI: </span>sigI</span>
<span id="cb160-8"><a href="#cb160-8" aria-hidden="true" tabindex="-1"></a>    inport  <span class="wa">sigO: </span>sigO</span>
<span id="cb160-9"><a href="#cb160-9" aria-hidden="true" tabindex="-1"></a>    code <span class="st">&quot;stdrw.rb&quot;</span></span>
<span id="cb160-10"><a href="#cb160-10" aria-hidden="true" tabindex="-1"></a>  <span class="cf">end</span></span>
<span id="cb160-11"><a href="#cb160-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb160-12"><a href="#cb160-12" aria-hidden="true" tabindex="-1"></a>  (sigO <span class="kw">&lt;=</span> sigO<span class="kw">+</span>sigI)<span class="at">.at</span>(clk<span class="at">.posedge</span>)</span>
<span id="cb160-13"><a href="#cb160-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb160-14"><a href="#cb160-14" aria-hidden="true" tabindex="-1"></a>  timed <span class="cf">do</span></span>
<span id="cb160-15"><a href="#cb160-15" aria-hidden="true" tabindex="-1"></a>    clk <span class="kw">&lt;=</span> <span class="dv">0</span></span>
<span id="cb160-16"><a href="#cb160-16" aria-hidden="true" tabindex="-1"></a>    sigO <span class="kw">&lt;=</span> <span class="dv">0</span></span>
<span id="cb160-17"><a href="#cb160-17" aria-hidden="true" tabindex="-1"></a>    sigI <span class="kw">&lt;=</span> <span class="dv">0</span></span>
<span id="cb160-18"><a href="#cb160-18" aria-hidden="true" tabindex="-1"></a>    repeat(<span class="dv">1000</span>) <span class="cf">do</span></span>
<span id="cb160-19"><a href="#cb160-19" aria-hidden="true" tabindex="-1"></a>       !<span class="dv">10</span><span class="at">.ns</span></span>
<span id="cb160-20"><a href="#cb160-20" aria-hidden="true" tabindex="-1"></a>       clk <span class="kw">&lt;=</span> <span class="kw">~</span>clk</span>
<span id="cb160-21"><a href="#cb160-21" aria-hidden="true" tabindex="-1"></a>    <span class="cf">end</span></span>
<span id="cb160-22"><a href="#cb160-22" aria-hidden="true" tabindex="-1"></a>  <span class="cf">end</span></span>
<span id="cb160-23"><a href="#cb160-23" aria-hidden="true" tabindex="-1"></a><span class="cf">end</span></span></code></pre></div>
<p><strong>Note</strong>: The input method used in the Ruby program
requires to input a number with the keyboard, press
<code>&lt;ENTER&gt;</code> then <code>&lt;CTRL&gt;-D</code> for
validating it.</p>
<p>Since a Ruby (or C) code can be used for the program construct, more
complex interactive interface can be made, for example, you can consult
the sample code <code>with_program_ruby_cpu.rb</code> which utilizes the
<code>curses</code> interface for simulating a UART keyboard and CRT
monitor.</p>
<h3 id="using-the-web-browser-based-gui">8.2. Using the web
browser-based GUI</h3>
<p>HDLRuby also provides a construct derivated for the programs for
easily building a web browser-based GUI. This GUI is described using a
<code>board</code> construct as follows:</p>
<div class="sourceCode" id="cb161"><pre
class="sourceCode ruby"><code class="sourceCode ruby"><span id="cb161-1"><a href="#cb161-1" aria-hidden="true" tabindex="-1"></a>board(:<span class="kw">&lt;</span>board name<span class="kw">&gt;</span>,<span class="kw">&lt;</span>server port<span class="kw">&gt;</span>) <span class="cf">do</span></span>
<span id="cb161-2"><a href="#cb161-2" aria-hidden="true" tabindex="-1"></a>  actport <span class="kw">&lt;</span>event<span class="kw">&gt;</span></span>
<span id="cb161-3"><a href="#cb161-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">&lt;</span>description of the <span class="cn">GUI</span><span class="kw">&gt;</span></span>
<span id="cb161-4"><a href="#cb161-4" aria-hidden="true" tabindex="-1"></a><span class="cf">end</span></span></code></pre></div>
<p>This construct can be declared within any module, and contains the
following elements as given in the code above:</p>
<ul>
<li><p><code>board name</code>: the name of the board.</p></li>
<li><p><code>server port</code>: the web port the GUI can be accessed
through, by default, it is <code>8000</code>.</p></li>
<li><p><code>event</code>: the event (edge of a signal) indicating when
the GUI is synchronized with the simulator. <strong>Note</strong>: the
more frequent the event is, the slower the simulation will be.</p></li>
<li><p><code>description of the GUI</code>: a set of statements
describing the content of the GUI.</p></li>
</ul>
<p>There are two types of statements for describing the GUI: the active
ones, that are connected to a HDLRuby signal, and the passive ones that
configure the shape of the GUI. The statements of the first type are
declared as follows:</p>
<div class="sourceCode" id="cb162"><pre
class="sourceCode ruby"><code class="sourceCode ruby"><span id="cb162-1"><a href="#cb162-1" aria-hidden="true" tabindex="-1"></a><span class="kw">&lt;</span>element<span class="kw">&gt;</span> <span class="kw">&lt;</span>element name<span class="kw">&gt;</span>: <span class="kw">&lt;</span><span class="dt">HDLRuby</span> signal<span class="kw">&gt;</span></span></code></pre></div>
<p>And the comprise the following:</p>
<ul>
<li><p><code>sw</code>: represents a set of slide switches, their number
is set to match the bit-width of the attached signal.</p></li>
<li><p><code>bt</code>: represents a set of push buttons, their number
is set to match the bit-width of the attached signal.</p></li>
<li><p><code>led</code>: represents a set of LEDs, their number is set
to match the bit-width of the attached signal.</p></li>
<li><p><code>hexa</code>: represents a hexadecimal number display, its
character width is set to match the width of the largest possible value
of the attached signal.</p></li>
<li><p><code>digit</code>: represents a decimal number display, its
character width is set to match the width of the largest possible
positive or the smallest possible negative value of the attached
signal.</p></li>
<li><p><code>scope</code>: represents an oscilloscope display, the
vertical axis represents the value of the attached signal, its range is
determined by its data type, and the horizontal axis represents the time
is number of synchronization of the GUI.</p></li>
</ul>
<p>There is for now only one statement of the second type:
<code>row</code>. This statement is used without any argument and adds a
new row to the GUI for placing components.</p>
<p>For example, we can use a GUI instead of the basic standard input and
output for the example given in <a
href="#8-1-do-it-yourself-interaction">the previous section</a>. The
code could be as follows, for having one slide switch for setting the
value to add, and LEDs for displaying the accumulation result
(<code>accum.rb</code>):</p>
<div class="sourceCode" id="cb163"><pre
class="sourceCode ruby"><code class="sourceCode ruby"><span id="cb163-1"><a href="#cb163-1" aria-hidden="true" tabindex="-1"></a><span class="fu">system</span> <span class="wa">:accum</span> <span class="cf">do</span></span>
<span id="cb163-2"><a href="#cb163-2" aria-hidden="true" tabindex="-1"></a>  inner <span class="wa">:clk</span></span>
<span id="cb163-3"><a href="#cb163-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">[</span><span class="dv">32</span><span class="kw">]</span><span class="at">.inner</span> <span class="wa">:sigI</span>, <span class="wa">:sigO</span></span>
<span id="cb163-4"><a href="#cb163-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb163-5"><a href="#cb163-5" aria-hidden="true" tabindex="-1"></a>  board(<span class="wa">:boardrw</span>) <span class="cf">do</span></span>
<span id="cb163-6"><a href="#cb163-6" aria-hidden="true" tabindex="-1"></a>    actport clk<span class="at">.posedge</span></span>
<span id="cb163-7"><a href="#cb163-7" aria-hidden="true" tabindex="-1"></a>    sw  <span class="wa">sigI: </span>sigI</span>
<span id="cb163-8"><a href="#cb163-8" aria-hidden="true" tabindex="-1"></a>    row</span>
<span id="cb163-9"><a href="#cb163-9" aria-hidden="true" tabindex="-1"></a>    led <span class="wa">sigO: </span>sigO</span>
<span id="cb163-10"><a href="#cb163-10" aria-hidden="true" tabindex="-1"></a>  <span class="cf">end</span></span>
<span id="cb163-11"><a href="#cb163-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb163-12"><a href="#cb163-12" aria-hidden="true" tabindex="-1"></a>  (sigO <span class="kw">&lt;=</span> sigO<span class="kw">+</span>sigI)<span class="at">.at</span>(clk<span class="at">.posedge</span>)</span>
<span id="cb163-13"><a href="#cb163-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb163-14"><a href="#cb163-14" aria-hidden="true" tabindex="-1"></a>  timed <span class="cf">do</span></span>
<span id="cb163-15"><a href="#cb163-15" aria-hidden="true" tabindex="-1"></a>    clk <span class="kw">&lt;=</span> <span class="dv">0</span></span>
<span id="cb163-16"><a href="#cb163-16" aria-hidden="true" tabindex="-1"></a>    sigO <span class="kw">&lt;=</span> <span class="dv">0</span></span>
<span id="cb163-17"><a href="#cb163-17" aria-hidden="true" tabindex="-1"></a>    sigI <span class="kw">&lt;=</span> <span class="dv">0</span></span>
<span id="cb163-18"><a href="#cb163-18" aria-hidden="true" tabindex="-1"></a>    repeat(<span class="dv">1000</span>) <span class="cf">do</span></span>
<span id="cb163-19"><a href="#cb163-19" aria-hidden="true" tabindex="-1"></a>       !<span class="dv">10</span><span class="at">.ns</span></span>
<span id="cb163-20"><a href="#cb163-20" aria-hidden="true" tabindex="-1"></a>       clk <span class="kw">&lt;=</span> <span class="kw">~</span>clk</span>
<span id="cb163-21"><a href="#cb163-21" aria-hidden="true" tabindex="-1"></a>    <span class="cf">end</span></span>
<span id="cb163-22"><a href="#cb163-22" aria-hidden="true" tabindex="-1"></a>  <span class="cf">end</span></span>
<span id="cb163-23"><a href="#cb163-23" aria-hidden="true" tabindex="-1"></a><span class="cf">end</span></span></code></pre></div>
<p>This code is simulated exactly like any other HDLRuby description,
e.g.:</p>
<div class="sourceCode" id="cb164"><pre
class="sourceCode bash"><code class="sourceCode bash"><span id="cb164-1"><a href="#cb164-1" aria-hidden="true" tabindex="-1"></a><span class="ex">hdrcc</span> <span class="at">--sim</span> <span class="at">--vcd</span> accum.rb accum</span></code></pre></div>
<p>However, the simulator will wait until a browser connects to it. For
that, you can open a web browser, and go to the local url:
<code>http://localhost:8000</code>. The simulation will then start and
you can interact with the GUI which should look as follows:</p>
<p align="center">
<img src="gui_accum.png"  width="80%">
</p>
<p>A more complete example can be found among the HDLRuby samples:
<code>with_board.rb</code>, which when simulated will use the following
GUI:</p>
<p align="center">
<img src="gui_board.png"  width="80%">
</p>
<h2 id="what-next">9. What next?</h2>
<p>There are still many aspects of HDLRuby that have not been addressed
in this tutorial. For example, finite state machines (FSM) and decoders
are crucial hardware components that you should learn about, and HDLRuby
provides specific constructs for easier design. So from now on, please
consult the main documentation of HDLRuby, and have a look at the code
samples provided in the HDLRuby distribution. They can be copied to your
working directory using the following command:</p>
<div class="sourceCode" id="cb165"><pre
class="sourceCode bash"><code class="sourceCode bash"><span id="cb165-1"><a href="#cb165-1" aria-hidden="true" tabindex="-1"></a><span class="ex">hdrcc</span> <span class="at">--get-samples</span></span></code></pre></div>
